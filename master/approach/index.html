<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approaches ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Approaches</a><ul class="internal"><li><a class="toctext" href="#Event-based-modeling-and-simulation-1">Event based modeling and simulation</a></li><li><a class="toctext" href="#Activity-based-modeling-and-simulation-1">Activity based modeling and simulation</a></li><li><a class="toctext" href="#State-based-modeling-and-simulation-1">State based modeling and simulation</a></li><li><a class="toctext" href="#Process-based-modeling-and-simulation-1">Process based modeling and simulation</a></li></ul></li><li><a class="toctext" href="../overview/">Overview</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Approaches</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/approach.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Approaches</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Approaches-to-modeling-and-simulation-1" href="#Approaches-to-modeling-and-simulation-1">Approaches to modeling and simulation</a></h1><p>I want to develop <code>Simulate.jl</code> to support four major approaches to modeling and simulation of <strong>discrete event systems (DES)</strong>:</p><ol><li><strong>event based</strong>: <em>events</em> occur in time and trigger actions causing further events ‚Ä¶</li><li><strong>activity based</strong>: <em>activities</em> occur in time and cause other activities ‚Ä¶</li><li><strong>state based</strong>: entities react to events occurring in time depending on their current <em>state</em>. Their actions may cause further events ‚Ä¶</li><li><strong>process based</strong>: entities are modeled as <em>processes</em> waiting for</li></ol><p>events and then acting according to the event and their current state ‚Ä¶</p><p>Choi and Kang have written an entire book about the first three approaches [1]. Cassandras and Lafortune in <em>Introduction to Discrete Event Systems</em> call the first three approaches &quot;the event scheduling scheme&quot; and the 4th one &quot;the process-oriented simulation scheme&quot;. Whoever is right, there are communities and their views behind those approaches and I want <code>Simulate.jl</code> to be useful for them all.</p><p><code>Simulate.jl</code> allows arbitrary Julia functions or expressions to be registered as &quot;events&quot; on the clocks time line and thus enables the first three approaches. That is because Julia functions can express events, activities or step-functions of a state machine. Under a few conditions Julia functions can run as &quot;processes&quot; simulating entities in a DES.</p><p>Then there are <strong>continuous systems</strong>, which are usually modeled by taking an action each Œît. We can register expressions or functions to the clock as sampling functions, which then are executed at each clock tick or we can register them as repeating events.  </p><p>All approaches fit together: e.g. functions registered as events can communicate with other functions running as processes acting on states and triggering other events or processes to start ‚Ä¶ Functions operating continuously can modify or evaluate conditions and states or trigger events ‚Ä¶ Thus we can model and simulate <strong>hybrid systems</strong>. All this gives us an expressive framework for simulation.</p><ul><li>[1] Choi and Kang: <em>Modeling and Simulation of Discrete-Event Systems</em>, Wiley, 2013</li><li>[2] Cassandras and Lafortune: <em>Introduction to Discrete Event Systems</em>, Springer, 2008, Ch. 10</li></ul><h2><a class="nav-anchor" id="Event-based-modeling-and-simulation-1" href="#Event-based-modeling-and-simulation-1">Event based modeling and simulation</a></h2><p>(empty)</p><h2><a class="nav-anchor" id="Activity-based-modeling-and-simulation-1" href="#Activity-based-modeling-and-simulation-1">Activity based modeling and simulation</a></h2><p>(empty, look at the table tennis example)</p><h2><a class="nav-anchor" id="State-based-modeling-and-simulation-1" href="#State-based-modeling-and-simulation-1">State based modeling and simulation</a></h2><p>(empty)</p><h2><a class="nav-anchor" id="Process-based-modeling-and-simulation-1" href="#Process-based-modeling-and-simulation-1">Process based modeling and simulation</a></h2><p>With the <code>/dev</code> version you can do something like this:</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><pre><code class="language-julia">using Simulate, Printf
reset!(ùê∂)

function foo(in::Channel, out::Channel, id)
    token = take!(in)
    @printf(&quot;%5.2f: foo %d took token %d\n&quot;, œÑ(), id, token)
    d = delay!(rand())
    put!(out, token+id)
end

function bar(in::Channel, out::Channel, id)
    token = take!(in)
    @printf(&quot;%5.2f: bar %d took token %d\n&quot;, œÑ(), id, token)
    d = delay!(rand())
    put!(out, token*id)
end

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8    # create and register 8 SimProcesses
    process!(ùê∂, SimProcess(i, foo, ch1, ch2, i))     # 4 foos
    process!(ùê∂, SimProcess(i+1, bar, ch2, ch1, i+1)) # 4 bars
end

start!(ùê∂) # start all registered processes
put!(ch1, 1) # put first token into channel 1

sleep(0.1) # we give the processes some time to startup

run!(ùê∂, 10)</code></pre><p>If we source this program, it runs a simulation:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels.jl&quot;)
 0.00: foo 7 took token 1
 0.25: bar 4 took token 8
 0.29: foo 3 took token 32
 0.55: bar 2 took token 35
 1.21: foo 5 took token 70
 1.33: bar 8 took token 75
 1.47: foo 1 took token 600
 1.57: bar 6 took token 601
 2.07: foo 7 took token 3606
 3.00: bar 4 took token 3613
 3.68: foo 3 took token 14452
 4.33: bar 2 took token 14455
 5.22: foo 5 took token 28910
 6.10: bar 8 took token 28915
 6.50: foo 1 took token 231320
 6.57: bar 6 took token 231321
 7.13: foo 7 took token 1387926
 8.05: bar 4 took token 1387933
 8.90: foo 3 took token 5551732
 9.10: bar 2 took token 5551735
 9.71: foo 5 took token 11103470
 9.97: bar 8 took token 11103475
10.09: foo 1 took token 88827800
&quot;run! finished with 22 events, simulation time: 10.0&quot;</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../overview/"><span class="direction">Next</span><span class="title">Overview</span></a></footer></article></body></html>
