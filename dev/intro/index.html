<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · DiscreteEvents.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiscreteEvents.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../news/">News</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Preparations-1">Preparations</a></li><li><a class="toctext" href="#Setup-a-clock-1">Setup a clock</a></li><li><a class="toctext" href="#Schedule-events-1">Schedule events</a></li><li><a class="toctext" href="#Run-the-clock-1">Run the clock</a></li><li><a class="toctext" href="#Processes-and-implicit-events-1">Processes and implicit events</a></li><li><a class="toctext" href="#Evaluation-1">Evaluation</a></li></ul></li><li><a class="toctext" href="../usage/">User guide</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Version history</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/pbayer/DiscreteEvents.jl/blob/master/docs/src/intro.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p><code>DiscreteEvents.jl</code> allows you to</p><ol><li>setup virtual or realtime clocks,</li><li>schedule events (Julia functions or expressions) to them,</li><li>run clocks to trigger events.</li></ol><h2><a class="nav-anchor" id="Preparations-1" href="#Preparations-1">Preparations</a></h2><p><code>DiscreteEvents.jl</code> is a registered package. You install it to your Julia environment with</p><pre><code class="language-julia-repl">] add DiscreteEvents</code></pre><p>You can install the development version with</p><pre><code class="language-julia-repl">] add https://github.com/pbayer/DiscreteEvents.jl</code></pre><p>You can then load it with</p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents</code></pre><h2><a class="nav-anchor" id="Setup-a-clock-1" href="#Setup-a-clock-1">Setup a clock</a></h2><p>Setting up a virtual clock is as easy as</p><pre><code class="language-julia-repl">julia&gt; clk = Clock()
Clock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre><p>You created a <a href="../usage/#DiscreteEvents.Clock"><code>Clock</code></a> variable <code>clk</code> with a master clock 0 at thread 1 with 0 active clocks (ac) and pretty much everything set to 0, without yet any scheduled events (ev), conditional events (cev) or sampling events (sampl).</p><h2><a class="nav-anchor" id="Schedule-events-1" href="#Schedule-events-1">Schedule events</a></h2><p>You can now schedule events to your clock. In order to demonstrate how it works we setup a small simulation. We want to simulate the easy life of a pet in the morning. First we define some data structures for pets:</p><pre><code class="language-julia">abstract type PetState end
struct Sleeping  &lt;: PetState end
struct Scuffing  &lt;: PetState end
struct Running   &lt;: PetState end

abstract type PetEvent end
struct GetWeary  &lt;: PetEvent end
struct GetHungry &lt;: PetEvent end
struct Scuff     &lt;: PetEvent end
struct LeapUp    &lt;: PetEvent end
struct Sleep     &lt;: PetEvent end

mutable struct Pet
    clk::Clock
    name::String
    state::PetState
    speak::String
end</code></pre><p>Then we need an API for Pet since we do not want to access its state directly.</p><pre><code class="language-julia">using Printf
state(p) = p.state
speak(p, n) = @printf(&quot;%5.2f %s: %s\n&quot;, tau(p.clk), p.name, p.speak^n)

function setstate!(p::Pet, q::PetState)
    p.state = q
    @printf(&quot;%5.2f %s: %s\n&quot;, tau(p.clk), p.name, repr(p.state))
end</code></pre><pre><code class="language-none">setstate! (generic function with 1 method)</code></pre><p>We describe the behaviour of the pet in time with some state-transition functions:</p><pre><code class="language-julia">function doit!(p::Pet, ::Sleeping, ::LeapUp)   # leap up after sleeping
    setstate!(p, Running())
    event!(p.clk, fun(doit!, p, fun(state, p), GetHungry()), after, 5*rand())
end

function doit!(p::Pet, ::Scuffing, ::LeapUp)   # leap up while scuffing
    setstate!(p, Running())
    event!(p.clk, fun(doit!, p, fun(state, p), GetWeary()), after, 2*rand())
end

function doit!(p::Pet, ::Running, ::GetHungry) # get hungry while running
    speak(p, 5)
    event!(p.clk, fun(doit!, p, fun(state, p), Scuff()), after, rand())
end

function doit!(p::Pet, ::Running, ::GetWeary)  # get weary while running
    speak(p, 2)
    event!(p.clk, fun(doit!, p, fun(state, p), Sleep()), after, 2*rand())
end

function doit!(p::Pet, ::Running, ::Scuff)     # scuff after running
    setstate!(p, Scuffing())
    event!(p.clk, fun(doit!, p, fun(state, p), LeapUp()), after, 2*rand())
end

function doit!(p::Pet, ::Running, ::Sleep)     # sleep after running
    setstate!(p, Sleeping())
    event!(p.clk, fun(doit!, p, fun(state, p), LeapUp()), after, 10*rand())
end</code></pre><pre><code class="language-none">doit! (generic function with 6 methods)</code></pre><p>We use here two features of <code>DiscreteEvents</code>:</p><ul><li>with <a href="../usage/#DiscreteEvents.event!"><code>event!</code></a> we schedule functions to the clock,</li><li><a href="../usage/#DiscreteEvents.fun"><code>fun</code></a> encapsulates those functions and their arguments in a function closure, so that they can be executed at event time. In this case – in order to have a current state at event time – we encapsulate <code>state(p)</code> into another <code>fun</code> closure.</li></ul><h2><a class="nav-anchor" id="Run-the-clock-1" href="#Run-the-clock-1">Run the clock</a></h2><p>Then we setup a pet, schedule the first event on it and run the clock:</p><pre><code class="language-julia">using Random; Random.seed!(123)     # we seed the random number generator for reprodicibility
snoopy = Pet(clk, &quot;Snoopy&quot;, Sleeping(), &quot;huff&quot;)
event!(clk, fun(doit!, snoopy, snoopy.state, LeapUp()), after, 5)</code></pre><pre><code class="language-julia">julia&gt; run!(clk, 25)
 5.00 Snoopy: Running()
 8.84 Snoopy: huffhuffhuffhuffhuff
 9.78 Snoopy: Scuffing()
11.13 Snoopy: Running()
11.92 Snoopy: huffhuff
12.55 Snoopy: Sleeping()
19.17 Snoopy: Running()
22.10 Snoopy: huffhuffhuffhuffhuff
22.16 Snoopy: Scuffing()
22.69 Snoopy: Running()
22.91 Snoopy: huffhuff
23.24 Snoopy: Sleeping()
&quot;run! finished with 12 clock events, 0 sample steps, simulation time: 25.0&quot;</code></pre><h2><a class="nav-anchor" id="Processes-and-implicit-events-1" href="#Processes-and-implicit-events-1">Processes and implicit events</a></h2><p><code>DiscreteEvents</code> provides also another approach: process-based simulation. In this case we implement the pet behaviour in a single function. For such a simple example this comes out simpler and more convenient:</p><pre><code class="language-julia">function pet(clk::Clock, p::Pet)
    setstate!(p, Running());  delay!(clk,  5*rand())
    speak(p, 5);              delay!(clk,    rand())  # get hungry
    setstate!(p, Scuffing()); delay!(clk,  2*rand())
    setstate!(p, Running());  delay!(clk,  2*rand())
    speak(p, 2);              delay!(clk,  2*rand())  # get weary
    setstate!(p, Sleeping()); delay!(clk, 10*rand())
end</code></pre><pre><code class="language-none">pet (generic function with 1 method)</code></pre><p>This describes one pet cycle. After each status change the pet function calls <a href="../usage/#DiscreteEvents.delay!"><code>delay!</code></a> for a given timeout on the clock. Note that the <code>pet</code> function takes the clock as its first argument. This is required for calling <code>delay!</code>.</p><p>We have to reimplement our <code>speak</code> and <code>setstate!</code> functions since now we print from an asynchronous process. With <a href="../usage/#DiscreteEvents.now!"><code>now!</code></a> we let the clock do the printing:</p><pre><code class="language-julia">speak(p, n) = now!(p.clk, fun(println, @sprintf(&quot;%5.2f %s: %s&quot;, tau(p.clk), p.name, p.speak^n)))

function setstate!(p::Pet, q::PetState)
    p.state = q
    now!(p.clk, fun(println, @sprintf(&quot;%5.2f %s: %s&quot;, tau(p.clk), p.name, repr(p.state))))
end</code></pre><pre><code class="language-none">setstate! (generic function with 1 method)</code></pre><p>In order to make this work we have to register the pet function to the clock.</p><pre><code class="language-julia">resetClock!(clk, t0=5)              # reset the clock, we start at 5
Random.seed!(123)                   # reseed the random generator
setstate!(snoopy, Sleeping())       # set snoopy sleeping
process!(clk, Prc(1, pet, snoopy));</code></pre><pre><code class="language-none">1</code></pre><p>We use <code>process!</code> and <code>Prc</code> to register <code>pet</code> to the clock and to start it as an asynchronous process (as a task). Then we can run the clock as before:</p><pre><code class="language-julia">julia&gt; run!(clk, 20)
 5.00 Snoopy: Running()
 8.84 Snoopy: huffhuffhuffhuffhuff
 9.78 Snoopy: Scuffing()
11.13 Snoopy: Running()
11.92 Snoopy: huffhuff
12.55 Snoopy: Sleeping()
19.17 Snoopy: Running()
22.10 Snoopy: huffhuffhuffhuffhuff
22.16 Snoopy: Scuffing()
22.69 Snoopy: Running()
22.91 Snoopy: huffhuff
23.24 Snoopy: Sleeping()
&quot;run! finished with 24 clock events, 0 sample steps, simulation time: 25.0&quot;</code></pre><p>We got the same output – with more implicit events for the <code>delay!</code> and <code>now!</code> calls).</p><h2><a class="nav-anchor" id="Evaluation-1" href="#Evaluation-1">Evaluation</a></h2><p>There is no point in doing simulations with such simple sequential examples, but if we do the same with more pets operating in parallel, things get messy very quickly and there is no way to do sequential programming for it. For such simulations we need parallel state machines, processes, actors etc. and their coordination on a time line. Our first approaches above scale well for such requirements.</p><footer><hr/><a class="previous" href="../news/"><span class="direction">Previous</span><span class="title">News</span></a><a class="next" href="../usage/"><span class="direction">Next</span><span class="title">User guide</span></a></footer></article></body></html>
