<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · DiscreteEvents.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiscreteEvents.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../news/">News</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Preparations-1">Preparations</a></li><li><a class="toctext" href="#Setup-a-clock-1">Setup a clock</a></li><li><a class="toctext" href="#Inventory-Control-Problem-1">Inventory Control Problem</a></li><li><a class="toctext" href="#A-B-Call-Center-Problem-1">A-B Call Center Problem</a></li><li><a class="toctext" href="#Evaluation-1">Evaluation</a></li><li><a class="toctext" href="#Further-examples-1">Further examples</a></li></ul></li><li><a class="toctext" href="../setup/">Installation</a></li><li><a class="toctext" href="../clocks/">Clocks</a></li><li><a class="toctext" href="../events/">Events</a></li><li><a class="toctext" href="../processes/">Processes</a></li><li><a class="toctext" href="../actors/">Actors</a></li><li><a class="toctext" href="../resources/">Resources</a></li><li><a class="toctext" href="../usage/">Utilities</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Version history</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/pbayer/DiscreteEvents.jl/blob/master/docs/src/intro.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p><code>DiscreteEvents.jl</code> allows you to</p><ol><li>setup virtual or realtime clocks,</li><li>schedule events (Julia functions or expressions) to them,</li><li>run clocks to trigger events.</li></ol><h2><a class="nav-anchor" id="Preparations-1" href="#Preparations-1">Preparations</a></h2><p><code>DiscreteEvents.jl</code> is a registered package. You install it to your Julia environment with</p><pre><code class="language-julia-repl">] add DiscreteEvents</code></pre><p>You can install the development version with</p><pre><code class="language-julia-repl">] add https://github.com/pbayer/DiscreteEvents.jl</code></pre><p>You can then load it with</p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents</code></pre><h2><a class="nav-anchor" id="Setup-a-clock-1" href="#Setup-a-clock-1">Setup a clock</a></h2><p>Setting up a virtual clock is as easy as</p><pre><code class="language-julia-repl">julia&gt; clock = Clock()
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre><p>You created a <a href="../clocks/#DiscreteEvents.Clock"><code>Clock</code></a> variable <code>clk</code> with a clock at thread 1 with pretty much everything set to 0, without yet any scheduled events (ev), conditional events (cev) or sampling events (sampl).</p><p>You can now schedule events to your clock. In order to demonstrate how it works we setup a small simulation. </p><h2><a class="nav-anchor" id="Inventory-Control-Problem-1" href="#Inventory-Control-Problem-1">Inventory Control Problem</a></h2><p>An inflammable is stored in a special tank at a filling station. Customers arrive according to a Poisson process with rate <span>$λ$</span> and ask for an amount <span>$\,X \sim \mathcal{N}(μ, σ^2)\,|\, a&lt;X\,$</span> of the product. Any demand that cannot be met is lost. Opportunities to replenish the stock in the tank occur according to a Poisson process with rate <span>$ρ$</span>. The two Poisson processes are assumed to be independent of each other. For reasons of security replenishment is only allowed when the tank is empty. At those opportunities it is replenished with a fixed amount <span>$Q$</span>. <a href="#footnote-1">[1]</a></p><p>We are interested to study the stock in the tank and the fraction of demand that is lost.</p><p>First we setup a data structure for a simulation:</p><pre><code class="language-julia">using DiscreteEvents, Distributions, Random

mutable struct Station
    q::Float64           # fuel amount
    t::Vector{Float64}   # time vector
    qt::Vector{Float64}  # fuel/time vector
    cs::Int              # customers served
    cl::Int              # customers lost
    qs::Float64          # fuel sold
    ql::Float64          # lost sales
end</code></pre><p>We have two events: <code>customer</code> and <code>replenishment</code> happening in the two interacting Poisson processes:</p><pre><code class="language-julia">function customer(c::Clock, s::Station, A::Distribution, X::Distribution)
    function fuel(s::Station, x::Float64)
        s.q -= x             # take x from tank
        push!(s.t, c.time)   # record time, amount, customer, sale
        push!(s.qt, s.q)
        s.cs += 1
        s.qs += x
    end

    x = rand(X)              # calculate demand
    if s.q ≥ x               # demand can be met
        fuel(s, x)
    elseif s.q ≥ a           # only partially in stock
        s.ql += x - s.q      # count the loss
        fuel(s, s.q)         # give em all we have
    else
        s.cl += 1            # count the lost customer
        s.ql += x            # count the lost demand
    end
    event!(c, fun(customer, c, s, A, X), after, rand(A))
end

function replenish(c::Clock, s::Station, A::Distribution, Q::Float64)
    if s.q &lt; a
        push!(s.t, c.time)
        push!(s.qt, s.q)
        s.q += Q
        push!(s.t, c.time)
        push!(s.qt, s.q)
    end
    event!(c, fun(replenish, c, s, A, Q), after, rand(A))
end</code></pre><p>We pass our event functions a <code>Clock</code> variable and schedule a repeat <code>event!</code> at the end of each of them.</p><p>Now we setup our constants and a simulation environment and run for 5000 virtual minutes:</p><pre><code class="language-julia">Random.seed(123)
const λ = 0.5      # ~ every two minutes a customer
const ρ = 1/180    # ~ every 3 hours a replenishment truck
const μ = 30       # ~ mean demand per customer 
const σ = 10       #   standard deviation
const a = 5        #   minimum amount 
const Q = 6000.0   # replenishment amount
const M₁ = Exponential(1/λ)  # customer arrival time distribution
const M₂ = Exponential(1/ρ)  # replenishment time distribution
const X = TruncatedNormal(μ, σ, a, Inf)  # demand distribution

clock = Clock()
s = Station(Q, Float64[0.0], Float64[Q], 0, 0, 0.0, 0.0)
event!(clock, fun(replenish, clock, s, M₂, Q), after, rand(M₂))
event!(clock, fun(customer, clock, s, M₁, X), after, rand(M₁))
println(run!(clock, 5000))

@show fuel_sold = s.qs;
@show loss_rate = s.ql/s.qs;
@show served_customers = s.cs;
@show lost_customers = s.cl;</code></pre><pre><code class="language-julia">run! finished with 2525 clock events, 0 sample steps, simulation time: 5000.0
fuel_sold = s.qs = 53999.999999999956
loss_rate = s.ql / s.qs = 0.3962195131252451
served_customers = s.cs = 1789
lost_customers = s.cl = 708</code></pre><p>We sold 9 tanks of fuel to 1789 customers. But we could have served 708 more customers and sold nearly 40% more fuel. Clearly we have some improvement potential:</p><pre><code class="language-julia">using Plots
plot(s.t, s.qt, title=&quot;Filling Station&quot;, xlabel=&quot;time [min]&quot;, ylabel=&quot;inventory [L]&quot;, legend=false)
savefig(&quot;invctrl.png&quot;)</code></pre><p><img src="../img/invctrl.png" alt/></p><p>If we could manage the replenishment immediately after the tank is empty, we would be much better off.</p><h2><a class="nav-anchor" id="A-B-Call-Center-Problem-1" href="#A-B-Call-Center-Problem-1">A-B Call Center Problem</a></h2><p><code>DiscreteEvents</code> also provides process-based simulation. A process is a typical sequence of events. This is particularly useful if we can describe our system in such terms.</p><p>One example is a call center with two servers, Able and Baker and a line for incoming calls. Able is more experienced and can provide service faster than Baker. We want to know if the system works and how long customers have to wait <a href="#footnote-2">[2]</a>.</p><p>First we describe some data structures for our system:</p><pre><code class="language-julia">using DiscreteEvents, Distributions, Random

mutable struct Caller
    id::Int
    t₁::Float64  # arrival time
    t₂::Float64  # beginning of service time
    t₃::Float64  # end of servive time
end

mutable struct Server
    id::Int
    S::Distribution  # service time distribution
    tbusy::Float64   # cumulative service time
end</code></pre><p>We have two processes in our system: <code>serve</code> and <code>arrive</code>. We describe them as functions:</p><pre><code class="language-julia">function serve(c::Clock, s::Server, input::Channel, output::Vector{Caller}, limit::Int)
    call = take!(input)         # take a call
    call.t₂ = c.time            # record the beginning of service time
    ts = rand(s.S)              # calculate service time
    delay!(c, ts)               # delay for service time
    call.t₃ = c.time            # record the end of service time 
    s.tbusy += ts               # log service time
    push!(output, call)         # hang up
    call.id ≥ limit &amp;&amp; stop!(c) # we stop the clock if all is done
end

function arrive(c::Clock, A::Distribution, input::Channel, N::Int)
    for i in 1:N
        delay!(c, rand(A))
        call = Caller(i, c.time, 0.0, 0.0)
        put!(input, call)
    end
end</code></pre><p>Here the two functions call a <code>delay!</code> from the clock. This will suspend the process for the required simulation time. Then we initialize our constants and simulation environment and run:</p><pre><code class="language-julia">Random.seed!(123)
const N = 1000
const M_arr = Exponential(2.5)
const M_a   = Exponential(3)
const M_b   = Exponential(4)

clock = Clock()
input = Channel{Caller}(Inf)
output = Caller[]
s1 = Server(1, M_a, 0.0)
s2 = Server(2, M_b, 0.0)
process!(clock, Prc(1, serve, s1, input, output, N))
process!(clock, Prc(2, serve, s2, input, output, N))
process!(clock, Prc(0, arrive, M_arr, input, N), 1)
run!(clock, 5000)</code></pre><pre><code class="language-none">&quot;run! halted with 2000 clock events, 0 sample steps, simulation time: 2302.09&quot;</code></pre><p>We could serve 1000 callers in 2302 minutes. This is an average lead time of 2.3 min. Doesn&#39;t seem so bad.</p><pre><code class="language-julia">julia&gt; s1.tbusy / clock.time
0.7255027971799999

julia&gt; s2.tbusy / clock.time
0.7392916075330213</code></pre><p>Also our servers have been busy only about 73% of the time. But how about waiting times for callers?</p><pre><code class="language-julia">using Plots
wt = [c.t₂ - c.t₁ for c in output]
plot(wt, title=&quot;A-B-Call center &quot;, xlabel=&quot;callers&quot;, ylabel=&quot;waiting time [min]&quot;, legend=false)
savefig(&quot;ccenter.png&quot;)</code></pre><p><img src="../img/ccenter.png" alt/></p><p>Waiting times often get way too long. If we want to shorten them, we must improve our service times or add more servers.</p><h2><a class="nav-anchor" id="Evaluation-1" href="#Evaluation-1">Evaluation</a></h2><p>It is easy to simulate discrete event systems such as stochastic processes or queueing systems with <code>DiscreteEvents</code>. It integrates well with Julia.</p><h2><a class="nav-anchor" id="Further-examples-1" href="#Further-examples-1">Further examples</a></h2><p>You can find more examples at <a href="https://pbayer.github.io/DiscreteEventsCompanion.jl/dev/examples/examples/"><code>DiscreteEventsCompanion</code></a>.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>This is a modified version of example 4.1.1 in Tijms: A First Course in Stochastic Models, Wiley 2003, p 143ff</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>This is a simplified version of the Able-Baker Call Center Problem in Banks, Carson, Nelson, Nicol: Discrete-Event System Simulation, Pearson 2005, p 35 ff</p></div><footer><hr/><a class="previous" href="../news/"><span class="direction">Previous</span><span class="title">News</span></a><a class="next" href="../setup/"><span class="direction">Next</span><span class="title">Installation</span></a></footer></article></body></html>
