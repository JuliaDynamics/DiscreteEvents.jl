<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Single server ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../approach/">Approaches</a></li><li><a class="toctext" href="../../overview/">Overview</a></li><li><a class="toctext" href="../../usage/">Usage</a></li><li><a class="toctext" href="../examples/">Examples</a><ul><li class="current"><a class="toctext" href>Single server</a><ul class="internal"></ul></li></ul></li><li><a class="toctext" href="../../internals/">Internals</a></li><li><a class="toctext" href="../../troubleshooting/">Troubeshooting</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="../examples/">Examples</a></li><li><a href>Single server</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/examples/singleserver.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Single server</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Single-server-1" href="#Single-server-1">Single server</a></h1><p>This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:</p><p><img src="../../images/sserver.svg" alt="single server"/></p><ol><li>Initially there are no jobs in the queue <span>$Q$</span> and the machine <span>$M$</span> is idle.</li><li>Jobs arrive with an inter-arrival-time <span>$t_a$</span>and are added to <span>$Q$</span>.</li><li>If <span>$M$</span> is idle, it loads a job, changes to busy and executes the job with service time <span>$t_s$</span>.</li><li>After that it changes to idle and, if <span>$Q$</span> is not empty, it loads the next job.</li></ol><h3><a class="nav-anchor" id="Implementing-it-1" href="#Implementing-it-1">Implementing it</a></h3><p>We use this simple example for illustration of how it can be modeled, simulated and analyzed using <code>Sim.jl</code>. First we have to import the necessary modules:</p><pre><code class="language-julia">using Simulate, Random, Distributions, DataFrames, Plots, LaTeXStrings
pyplot()</code></pre><p>We have to define some data structures, variables and a function for collecting stats:</p><pre><code class="language-julia">abstract type MState end

struct Idle &lt;: MState end
struct Busy &lt;: MState end

mutable struct Job
    no::Int64
    ts::Float64
    t1::Float64
    t2::Float64
    t3::Float64
end

mutable struct Machine
    state::MState
    job
end

Q = Job[]   # input queue
S = Job[]   # stock
M = Machine(Idle(), 0)
df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])
count = 1
printing = true

stats() = push!(df, (œÑ(), length(Q), M.state == Busy() ? 1 : 0, length(S)))</code></pre><p>We can model our system <strong>activity-based</strong> und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.</p><p>We use the arrival-function for modeling arrival rate <span>$t_a$</span> with an Erlang and service time <span>$t_s$</span> with a Normal distribution. We determine the capacity of the server with a <span>$c$</span> variable such that <span>$c &gt; 1$</span> gives us overcapacity and <span>$c = 1$</span> means that mean service time equals mean arrival rate <span>$\bar{t_s} = \bar{t_a}$</span>.</p><pre><code class="language-julia">function arrive(Œº, œÉ, c)
    @assert Œº ‚â• 1 &quot;Œº must be ‚â• 1&quot;
    ts = rand(Normal(Œº, œÉ))/c
    job = Job(count, ts, œÑ(), 0, 0)
    global count += 1
    push!(Q, job)
    ta = rand(Erlang())*Œº
    event!(ùê∂, SimFunction(arrive, Œº, œÉ, c), after, ta)  # we schedule the next arrival
    printing ? println(œÑ(), &quot;: job $(job.no) has arrived&quot;) : nothing # œÑ() is the current time
    if M.state == Idle()
        load()
    else
        stats()
    end
end

function load()
    M.state = Busy()
    M.job = popfirst!(Q)
    M.job.t2 = œÑ()
    event!(ùê∂, SimFunction(unload), after, M.job.ts)  # we schedule the unload
    printing ? println(œÑ(), &quot;: job $(M.job.no) has been loaded&quot;) : nothing
    stats()
end

function unload()
    M.state = Idle()
    M.job.t3 = œÑ()
    push!(S, M.job)
    printing ? println(œÑ(), &quot;: job $(M.job.no) has been finished&quot;) : nothing
    stats()
    M.job = 0
    if !isempty(Q)
        load()
    end
end</code></pre><p>We want to collect <code>stats()</code> at a sample rate of 0.1:</p><pre><code class="language-julia">sample_time!(ùê∂, 0.1)  # we determine the sample rate
Sim.sample!(ùê∂, SimFunction(stats));  # we register stats() as sampling function</code></pre><p>We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and <span>$\mu = 5$</span>, <span>$\sigma = 1/5$</span> and <span>$c = 1$</span> and let our system run for 30 minutes (let&#39;s assume our time unit be minutes):</p><pre><code class="language-julia">Random.seed!(2019)
arrive(5, 1/5, 1)  # we schedule the first event
run!(ùê∂, 30)        # and run the simulation</code></pre><p>This will give us as output:</p><pre><code class="language-julia">0: job 1 has arrived
0: job 1 has been loaded
4.947453062901819: job 1 has been finished
8.515206032139384: job 2 has arrived
8.515206032139384: job 2 has been loaded
8.56975795472613: job 3 has arrived
8.666481204359087: job 4 has arrived
10.338522593089287: job 5 has arrived
11.021099411385869: job 6 has arrived
13.267881315092211: job 7 has arrived
13.703372376147774: job 2 has been finished
13.703372376147774: job 3 has been loaded
18.726550601155594: job 3 has been finished
18.726550601155594: job 4 has been loaded
19.55941423914075: job 8 has arrived
19.58302738045451: job 9 has arrived
20.543366077813385: job 10 has arrived
22.752994020639125: job 11 has arrived
23.563550850400553: job 4 has been finished
23.563550850400553: job 5 has been loaded
23.960464112286694: job 12 has arrived
26.84742108339802: job 13 has arrived
28.18186102251928: job 5 has been finished
28.18186102251928: job 6 has been loaded
&quot;run! finished with 17 events, simulation time: 30.0&quot;</code></pre><p>Using our collected data, we can plot the simulation model trajectory:</p><pre><code class="language-julia">function trajectory_plot()
    p1 = plot(df.time, df.buffer, ylabel=&quot;buffer&quot;, fill=(0,0.1,:blue))
    p2 = plot(df.time, df.machine, ylabel=&quot;machine&quot;, fill=(0,0.1,:blue))
    p3 = plot(df.time, df.finished, xlabel=&quot;time [min]&quot;, ylabel=&quot;stock&quot;, fill=(0,0.1,:blue))
    plot(p1,p2,p3, layout=(3,1), legend=false)
end
trajectory_plot()</code></pre><p><img src="../../images/sserver1.png" alt="trajectory plot 1"/></p><p>It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 &quot;minutes&quot;.</p><pre><code class="language-julia">printing = false
run!(ùê∂, 970)        # we continue the simulation
trajectory_plot()</code></pre><p><img src="../../images/sserver2.png" alt="trajectory plot 2"/></p><p>It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren&#39;t very instructive, so let&#39;s compare lead time <span>$W$</span> and number of jobs in the system <span>$L = \text{buffer_size} + \text{machine_load}$</span>:</p><pre><code class="language-julia">function WvsL() # get more instructive info from simulation run
    t = [j.t1 for j ‚àà S]
    W = [j.t3 - j.t1 for j ‚àà S]
    ts = [j.t3 - j.t2 for j ‚àà S]
    subs = [i ‚àà t for i ‚àà df.time]
    L = (df.buffer + df.machine)[subs]
    l = df.machine[subs]
    DataFrame(time=t, load=l, W=W, L=L, ts=ts)
end
d = WvsL()
plot(d.time, d.W, label=&quot;W [min]&quot;, xlabel=&quot;time [min]&quot;, lw=2, legend=:topleft, title=&quot;L and W over time&quot;)
plot!(d.time, d.L, label=&quot;L [jobs]&quot;, lw=2)</code></pre><p><img src="../../images/sserver3.png" alt="L and W over time"/></p><p>Lead time <span>$W$</span> and unfinished jobs <span>$L$</span> are clearly increasing, the system is not stationary and gets jammed over time. Let&#39;s collect some stats:</p><pre><code class="language-julia">collect_stats() =
    (Lm = mean(d.L), Wm = mean(d.W), Œ∑ = mean(df.machine), tsm = mean(d.ts))
collect_stats()
(Lm = 16.21105527638191, Wm = 78.8196419189297, Œ∑ = 0.9778719397363466, tsm = 5.003771234356064)</code></pre><p>Server load of <span>$\overline{Œ∑} ‚âà 98\%$</span> is great, but the mean queue length <span>$\overline{L}$</span> of <span>$16$</span> and mean lead time <span>$\overline{W} ‚âà 79$</span> min are way too long for a service time of <span>$t_s ‚âà 5$</span> min. So let&#39;s analyze the dependency of mean queue length <span>$\overline{L}$</span> on server capacity <span>$c$</span>. For that we can manipulate the server capacity in the arrival function and collect the results in a table:</p><pre><code class="language-julia">df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], Œ∑=Float64[], tsm=Float64[])
for c ‚àà collect(0.97:0.01:1.7)
    global Q = Job[]   # input queue
    global S = Job[]   # stock
    global M = Machine(Idle(), 0)
    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])
    global count = 1

    reset!(ùê∂)                            # reset ùê∂
    sample_time!(ùê∂, 1)                   # set sample rate to 1
    Sim.sample!(ùê∂, SimFunction(stats))   # register the stats() function for sampling

    Random.seed!(2019)
    arrive(5, 1/5, c)
    run!(ùê∂, 1000)                        # run another simulation for 1000 &quot;min&quot;
    global d = WvsL()
    s = collect_stats()
    push!(df1, (c, s.Lm, s.Wm, s.Œ∑, s.tsm))
end</code></pre><p>We can look at it in a scatter plot:</p><pre><code class="language-julia">scatter(df1.c, df1.Wm, title=L&quot;\overline{W}&quot;*&quot; and &quot;*L&quot;\overline{L}&quot;*&quot; over server capacity&quot;,
    xlabel=&quot;server capacity&quot;, marker = (:o, 3, 0.4, :blue), label=L&quot;\overline{W}&quot;*&quot; [min]&quot;)
scatter!(df1.c, df1.Lm, marker = (:x, 4), label=L&quot;\overline{L}&quot;*&quot; [jobs]&quot;)</code></pre><p><img src="../../images/sserver4.png" alt="W and L over server capacity"/></p><p>We need to increase server capacity much in order to avoid long queues and waiting times.</p><h3><a class="nav-anchor" id="How-about-Little&#39;s-law?-1" href="#How-about-Little&#39;s-law?-1">How about Little&#39;s law?</a></h3><p><span>$\overline{W}$</span> and <span>$\overline{L}$</span> seem to be proportional. This is stated by <a href="https://en.wikipedia.org/wiki/Little%27s_law">Little&#39;s law</a>:</p><div>\[\begin{equation}
L = \lambda\times W
\end{equation}\]</div><p>for stationary systems with <span>$\lambda$</span> = arrival rate. In our case <span>$\lambda = t_a = 5$</span>. Let&#39;s look at it:</p><pre><code class="language-julia">scatter(df1.Lm, df1.Wm, xlabel=L&quot;\overline{L}&quot;*&quot; [jobs]&quot;, ylabel=L&quot;\overline{W}&quot;*&quot; [min]&quot;,
    marker = (:o, 4, 0.4, :blue), label=&quot;data&quot;, title=&quot;Little&#39;s law&quot;, legend=:topleft)
plot!(df1.Lm, df1.Lm*5, label=&quot;theory &quot;*L&quot;(\overline{L}\times 5)&quot;)</code></pre><p><img src="../../images/sserver5.png" alt="Little&#39;s law"/></p><p>Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little&#39;s law seems not to be a bad one. In order to analyze stability and <a href="https://en.wikipedia.org/wiki/Stationary_process">stationarity</a> and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with <code>Sim.jl</code> ...</p><h3><a class="nav-anchor" id="-1" href="#-1">üòÑ</a></h3><p>pb, 2019-11-01</p><footer><hr/><a class="previous" href="../tabletennis/"><span class="direction">Previous</span><span class="title">Table tennis</span></a><a class="next" href="../../internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
