<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../intro/">Getting started</a></li><li><a class="toctext" href="../approach/">Building models</a></li><li class="current"><a class="toctext" href>Usage</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#The-clock-1">The clock</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/examples/">Overview</a></li><li><a class="toctext" href="../examples/greeting/">Two guys meet</a></li><li><a class="toctext" href="../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../examples/postoffice/postoffice/">Post Office</a></li><li><a class="toctext" href="../examples/dicegame/dicegame/">Goldratt&#39;s Dice Game</a></li><li><a class="toctext" href="../examples/house_heating/house_heating/">House heating</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../performance/">Performance</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/usage.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>Simulate.jl</code> runs on Julia versions ‚â• v&quot;1.0&quot; <a href="#footnote-1">[1]</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Simulate" href="#Simulate.Simulate"><code>Simulate.Simulate</code></a> ‚Äî <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">Simulate</code></pre><p>A Julia package for discrete event simulation.</p><p>The current stable, registered version is installed with</p><pre><code class="language-julia">pkg&gt; add Simulate</code></pre><p>The development version is installed with:</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/Simulate.jl&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/Simulate.jl#L9-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.version" href="#Simulate.version"><code>Simulate.version</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">version</code></pre><p>Gives the package version:</p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; Simulate.version
v&quot;0.3.0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/Simulate.jl#L27-L38">source</a></section><h2><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Clock" href="#Simulate.Clock"><code>Simulate.Clock</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Œît::Number=0</code>: time increment. If no Œît is given, the simulation doesn&#39;t tick,   but jumps from event to event. Œît can be set later with <code>sample_time!</code>.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>state::SState</code>: clock state</li><li><code>time::Float64</code>: clock time</li><li><code>unit::FreeUnits</code>: time unit</li><li><code>events::PriorityQueue{SimEvent,Float64}</code>: scheduled events</li><li><code>cevents::Array{SimCond,1}</code>: conditional events</li><li><code>processes::Dict{Any, SimProcess}</code>: registered processes</li><li><code>end_time::Float64</code>: end time for simulation</li><li><code>evcount::Int64</code>: event counter</li><li><code>scount::Int64</code>: sample count</li><li><code>tev::Float64</code>: next event time</li><li><code>Œît::Float64</code>: sampling time, timestep between ticks</li><li><code>sexpr::Array{Sample,1}</code>: sampling expressions to evaluate at each tick</li><li><code>tsa::Float64</code>: next sample time</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                 # create a unitless clock (standard)
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; Simulate.init!(c)           # initialize it explicitly (normally done implicitly)
Simulate.Idle()

julia&gt; c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically
Clock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.016666666666666666

julia&gt; c = Clock(1s)               # create a clock with implicit unit setting
Clock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0

julia&gt; c = Clock(t0=60s)           # another example of implicit unit setting
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; c = Clock(1s, t0=1hr)       # if given times with different units, Œît takes precedence
Clock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/types.jl#L217-L270">source</a></section><p>The central clock  is ùê∂. You can set time units and query the current simulation time.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ùê∂" href="#Simulate.ùê∂"><code>Simulate.ùê∂</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">ùê∂
Clk</code></pre><p><code>ùê∂</code> (ùê∂ = \itC+[tab]) or <code>Clk</code> is the central simulation clock. If you do one simulation at a time, you can use ùê∂ or Clk for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;

julia&gt; ùê∂  # central clock
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; ùê∂ === Clk
true
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L82-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setUnit!" href="#Simulate.setUnit!"><code>Simulate.setUnit!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(sim::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; tau(c) # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c) # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; typeof(tau(c))       # tau(c) now returns a time Quantity ...
Quantity{Float64,ùêì,Unitful.FreeUnits{(minute,),ùêì,nothing}}

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L6-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau-Tuple{Clock}" href="#Simulate.tau-Tuple{Clock}"><code>Simulate.tau</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tau(sim::Clock=ùê∂)
œÑ(sim::Clock=ùê∂)</code></pre><p>Return the current simulation time (œÑ = \tau+tab).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;
julia&gt; tau() # gives the central time
0.0
julia&gt; œÑ() # alias, gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L108-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@tau-Tuple{Clock}" href="#Simulate.@tau-Tuple{Clock}"><code>Simulate.@tau</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@tau(sim::Clock)
@tau sim
@tau()
@tau</code></pre><p>return the current simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock argument is given, it returns ùê∂&#39;s time.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L149-L160">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Events are scheduled on the clock&#39;s timeline and are triggered at a given simulation time or under conditions which may become true during simulation.</p><h3><a class="nav-anchor" id="Expressions-and-functions-as-events-and-conditions-1" href="#Expressions-and-functions-as-events-and-conditions-1">Expressions and functions as events and conditions</a></h3><p>Julia expressions and functions can be scheduled as events.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Timing" href="#Simulate.Timing"><code>Simulate.Timing</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time,</li><li><code>after</code>: schedule an event a given time after current time,</li><li><code>every</code>: schedule an event every given time from now on,</li><li><code>before</code>: a timed condition is true before a given time,</li><li><code>until</code>: delay until t.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimFunction" href="#Simulate.SimFunction"><code>Simulate.SimFunction</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimFunction([emod::Module], efun::Function, arg...; kw...)
alias    SF([emod::Module], efun::Function, arg...; kw...)</code></pre><p>Store a function and its arguments for being called later as an event.</p><p><strong>Arguments, fields</strong></p><ul><li><code>emod::Module</code>: evaluation scope for symbols or expressions given as arguments.   If <code>emod</code> is not supplied, the evaluation scope is <code>Main</code>.</li><li><code>efun::Function</code>:  event function to be executed at event time,</li><li><code>arg...</code>: arguments to the event function,</li><li><code>kw...</code>: keyword arguments to the event function.</li></ul><p>Arguments and keyword arguments can be 1) values or variables mixed with 2) symbols, expressions or even other SimFunctions. In the 2nd cases they are evaluated at event time before they are passed to the event function.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Composite types or variables given symbolically can change until they are evaluated later at event time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; f(a,b,c; d=4, e=5) = a+b+c+d+e       # if you define a function and ...
f (generic function with 1 method)

julia&gt; sf = SF(f, 10, 20, 30, d=14, e=15);  # store it as SimFunction

julia&gt; sf.efun(sf.arg...; sf.kw...)         # it can be executed later
89

julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2);          # we set up a dictionary

julia&gt; g(t) = t[:a] + t[:b]                 # and a function adding :a and :b
g (generic function with 1 method)

julia&gt; g(d)                                 # our add function gives 3
3

julia&gt; ff = SimFunction(g, d);              # we set up a SimFunction

julia&gt; d[:a] = 10;                          # later somehow we change d

julia&gt; ff.efun(ff.arg...)                   # calling ff then gives a different result
12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/types.jl#L18-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SF" href="#Simulate.@SF"><code>Simulate.@SF</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SF(f::Symbol, arg...)
@SF f arg...</code></pre><p>create a <code>SimFunction</code> from arguments f, arg...</p><p><strong>Arguments</strong></p><ul><li><code>f::Symbol</code>: a function given as a symbol, e.g. <code>:f</code> if f() is your function,</li><li><code>arg...</code>: further arguments to your function</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>keyword arguments don&#39;t work with this macro, use SF instead.</li><li>if you give @SF as argument(s) to a function, you must enclose it/them  in parentheses ( @SF ... ) or ( (@SF ...), (@SF ...) )</li></ol></div></div><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; using Simulate

julia&gt; a = 1
1
julia&gt; incra() = global a += 1             # create a simple increment function
incra (generic function with 1 method)

julia&gt; event!((@SF incra), after, 3);      # schedule an increment after 3 time units

julia&gt; a                                   # nothing happened to a
1

julia&gt; run!(ùê∂, 5)                          # run the simulation
&quot;run! finished with 1 clock events, 0 sample steps, simulation time: 5.0&quot;

julia&gt; a                                   # now it should have been incremented
2

julia&gt; event!((@SF incra), (@tau :&gt;= 8));  # schedule a conditional event

julia&gt; run!(ùê∂, 5)
&quot;run! finished with 0 clock events, 301 sample steps, simulation time: 10.0&quot;

julia&gt; a                                   # the conditional event was triggered
3

julia&gt; event!(((@SF incra), (@SF incra)),  # two increments
        ((@tau :&gt;= 12), (@val :a :&lt;= 3))); # on two conditions

julia&gt; run!(ùê∂, 5)
&quot;run! finished with 0 clock events, 201 sample steps, simulation time: 15.0&quot;

julia&gt; a                                   # two increments happened
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L77-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimExpr" href="#Simulate.SimExpr"><code>Simulate.SimExpr</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SimExpr = Union{Expr, SimFunction}</code></pre><p>A type which is either a <code>SimFunction</code> or Julia expression, <code>Expr</code>-type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/types.jl#L88-L92">source</a></section><p>SimFunctions and expressions can be given to events on their own or in arrays or tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(SF(f, 1, 2, 3, diff=pi), every, 1)  # one SimFunction
    event!((:(i += 1), SF(g, j)), [:(tau() ‚â• 50), SF(isready, input), :(a ‚â§ 10)]) # two SimExpr under three conditions
end</code></pre><p>All given expressions or functions are then evaluated at a given simulation time or when during simulation the given conditions become true.</p><h3><a class="nav-anchor" id="Timed-events-1" href="#Timed-events-1">Timed events</a></h3><p>SimFunctions and expressions can be scheduled for execution at given clock times.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}"><code>Simulate.event!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!([sim::Clock], ex::Union{SimExpr, Array, Tuple}, t::Number;
       scope::Module=Main, cycle::Number=0.0)::Float64</code></pre><p>Schedule an event for a given simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: it not supplied, the event is scheduled to ùê∂,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>t::Real</code> or <code>t::Time</code>: simulation time, if t &lt; sim.time set t = sim.time,</li><li><code>scope::Module=Main</code>: scope for expressions to be evaluated in,</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event.</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event. May return a time <code>&gt; t</code> from repeated applications of <code>nextfloat(t)</code> if there are events scheduled for <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)

julia&gt; event!(ùê∂, SimFunction(myfunc, 1, 2), 1) # a 1st event to 1
1.0
julia&gt; event!(ùê∂, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time
1.0000000000000002

julia&gt; event!(ùê∂, SimFunction(myfunc, 3, 4), 1s)
Warning: clock has no time unit, ignoring units
1.0000000000000004

julia&gt; setUnit!(ùê∂, s)
0.0 s

julia&gt; event!(ùê∂, SimFunction(myfunc, 4, 5), 1minute)
60.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L312-L355">source</a></section><p>As a convenience the <code>Timing</code> can be also choosen using <code>at</code>, <code>after</code> or <code>every</code> <code>t</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}"><code>Simulate.event!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!([sim::Clock], ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number;
       scope::Module=Main)::Float64</code></pre><p>Schedule a timed event, that is an event with a timing.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not supplied, the event is scheduled to ùê∂,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>T::Timing</code>: a timing, <code>at</code>, <code>after</code> or <code>every</code> (<code>before</code> behaves like <code>at</code>),</li><li><code>t::Float64</code> or <code>t::Time</code>: simulation time,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; setUnit!(ùê∂, s)
0.0 s

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)

julia&gt; event!(SimFunction(myfunc, 5, 6), after, 1hr)
3600.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L371-L403">source</a></section><h3><a class="nav-anchor" id="Conditional-events-1" href="#Conditional-events-1">Conditional events</a></h3><p>They are evaluated at each clock tick (like sampling functions) and are fired when all conditions are met.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}"><code>Simulate.event!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!([sim::Clock], ex::Union{SimExpr, Array, Tuple},
       cond::Union{SimExpr, Array, Tuple}; scope::Module=Main):</code></pre><p>Schedule a conditional event.</p><p>It is executed immediately if the conditions are met, else the condition is checked at each clock tick Œît. A conditional event is triggered only once. After that it is removed from the clock. If no sampling rate Œît is setup, a default sampling rate is setup depending on the scale of the remaining simulation time <span>$Œît = scale(t_r)/100$</span> or <span>$0.01$</span> if <span>$t_r = 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is supplied, the event is scheduled to ùê∂,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>cond::{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true only if all expressions or SimFunctions   therein return true,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li></ul><p><strong>returns</strong></p><p>current simulation time <code>tau(sim)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; c = Clock()   # create a new clock
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; event!(c, SF((x)-&gt;println(tau(x), &quot;: now I&#39;m triggered&quot;), c), (@tau c :&gt;= 5))
0.0

julia&gt; c             # a conditional event turns sampling on
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 1, processes: 0, sampling: 0, sample rate Œît=0.01

julia&gt; run!(c, 10)   # sampling is not exact, so it takes 501 sample steps to fire the event
5.009999999999938: now I&#39;m triggered
&quot;run! finished with 0 clock events, 501 sample steps, simulation time: 10.0&quot;</code></pre><p>After the event is triggered, sampling is again switched off.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L437-L481">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since conditions often are not met exactly you should prefer inequalities like &lt;, ‚â§, ‚â•, &gt; to equality == in order to get sure that a fulfilled condition can be detected, e.g. <span>$:(tau() ‚â• 100)$</span> is preferable to <span>$:(tau() == 100)$</span>.</p></div></div><p>There are some helper functions and macros for defining conditions. It is usually more convenient to use the macros since the generate the necessary SimFunctions directly:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau-Tuple{Clock,Function,Union{Number, Symbol}}" href="#Simulate.tau-Tuple{Clock,Function,Union{Number, Symbol}}"><code>Simulate.tau</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tau(sim::Clock, check::Function, x::Union{Number,Symbol}; m::Module=Main)
tau(check::Function, x::Union{Number,Symbol}; m::Module=Main)</code></pre><p>Compare the current simulation time against a number or a variable.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock variable, if not given, it is ùê∂.</li><li><code>check::Function</code>: a comparison operator like ‚â•, &gt;, ==, &lt;, ‚â§,</li><li><code>x::Union{Number,Symbol}</code>: a number or a symbolic variable like <code>:a</code>, a   symbolic variable can be evaluated later at event time,</li><li><code>m::Module=Main</code>: the evaluation scope, if a symbolic variable is given.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; tau(&gt;=, 1)
false

julia&gt; tau(&lt;, 1)
true

julia&gt; a = 1
1

julia&gt; tau(&lt;=, :a, @__MODULE__)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L5-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@tau-Tuple{Any,QuoteNode,Union{Number, QuoteNode}}" href="#Simulate.@tau-Tuple{Any,QuoteNode,Union{Number, QuoteNode}}"><code>Simulate.@tau</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@tau(sim::Clock, check::Symbol, val)
@tau sim check val
@tau(check::Symbol, val)
@tau check val</code></pre><p>create a <code>SimFunction</code> comparing current simulation time with a given value or variable.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, it compares with ùê∂&#39;s time,</li><li><code>check::Symbol</code>: the check operator must be given as a symbol e.g. <code>:&lt;</code>,</li><li><code>val::Union{Number, QuoteNode}</code>: a value or a symbolic variable,</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you give @tau as argument(s) to a function, you must enclose it/them in parentheses ( @tau ... ) or ( (@tau ...), (@tau ...) )!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;
julia&gt; sf = @tau :‚â• 100;

julia&gt; Simulate.simExec(sf)
false

julia&gt; Simulate.simExec(@tau &lt; 100)                ### wrong !!
ERROR: syntax: &quot;&lt;&quot; is not a unary operator

julia&gt; Simulate.simExec(@tau :&lt; 100)               ### correct
true

julia&gt; a = 1
1

julia&gt; Simulate.simExec(@tau :&lt; :a)
true

julia&gt; event!(SF(()-&gt;global a+=1), (@tau :&gt;= 3))   ### create a conditional event
0.0

julia&gt; a
1

julia&gt; run!(ùê∂, 5)                                  ### run
&quot;run! finished with 0 clock events, 301 sample steps, simulation time: 5.0&quot;

julia&gt; a
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L168-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.val" href="#Simulate.val"><code>Simulate.val</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">val(a::Union{Number, Symbol}, check::Function, x::Union{Number, Symbol}, m::Module=Main)</code></pre><p>Compare two variables or numbers.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>, <code>xUnion{Number, Symbol}</code>: a number or a symbolic variable like <code>:a</code>, a   symbolic variable can be evaluated later at event time,</li><li><code>check::Function</code>: a comparison operator like ‚â•, &gt;, ==, &lt;, ‚â§,</li><li><code>m::Module=Main</code>: the evaluation scope, if a symbolic variable is given.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; val(1, &lt;=, 2)
true

julia&gt; a = 1
1

julia&gt; val(:a, &lt;=, 2, @__MODULE__)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L42-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@val" href="#Simulate.@val"><code>Simulate.@val</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@val(a, check::QuoteNode, b)
@val a check b</code></pre><p>Create a Simfunction comparing two values a and b or two symbolic variables :a and :b. The comparison operator must be given symbolically, e.g. <code>:‚â§</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a, b</code>:: a number, expression or symbol</li><li><code>check::QuoteNode</code>: a comparison operator as a symbol like <code>:&gt;</code> or <code>:‚â§</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you give @val as argument(s) to a function, you must enclose it/them in parentheses ( @val ... ) or e.g. ( (@tau ...), (@val ...) )!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;

julia&gt; Simulate.simExec(@val 1 :‚â§ 2)
true

julia&gt; a = 1
1

julia&gt; Simulate.simExec(@val :a :‚â§ 2)
true

julia&gt; event!(SF(()-&gt;global a+=1), ((@tau :&gt;= 3), (@val :a :&lt;= 3))); # a conditional event

julia&gt; run!(ùê∂, 5)
&quot;run! finished with 0 clock events, 301 sample steps, simulation time: 5.0&quot;

julia&gt; a
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L230-L270">source</a></section><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can be registered and run as processes. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimProcess" href="#Simulate.SimProcess"><code>Simulate.SimProcess</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimProcess( id, func::Function, arg...; kw...)
alias   SP( id, func::Function, arg...; kw...)</code></pre><p>Prepare a function to run as a process in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>id</code>: some unique identification for registration,</li><li><code>func::Function</code>: a function <code>f(arg...; kw...)</code></li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function as a SimProcess most often runs in a loop. It has to give back control by e.g. doing a <code>take!(input)</code> or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will starve everything else!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/types.jl#L179-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SP" href="#Simulate.@SP"><code>Simulate.@SP</code></a> ‚Äî <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SP(id, f::Symbol, arg...)
@SP id f arg...</code></pre><p>create a <code>SimProcess</code> from arguments f, arg...</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>keyword arguments don&#39;t work with this macro, use SP instead.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/utils.jl#L135-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimException" href="#Simulate.SimException"><code>Simulate.SimException</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimException(ev::SEvent, value=nothing)</code></pre><p>Define a SimException, which can be thrown to processes.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ev::SEvent</code>: delivers an event to the interrupted task</li><li><code>value=nothing</code>: deliver some other value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/types.jl#L164-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.process!" href="#Simulate.process!"><code>Simulate.process!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!([sim::Clock], p::SimProcess, cycles=Inf)</code></pre><p>Register a <a href="#Simulate.SimProcess"><code>SimProcess</code></a> to a clock, start it as an asynchronous process and return the <code>id</code> it was registered with. It can then be found under <code>sim.processes[id]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not provided, the process runs under ùê∂,</li><li><code>p::SimProcess</code>: it contains a function and its arguments,</li><li><code>cycles::Number=Inf</code>: number of cycles the process should run.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L43-L54">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.interrupt!" href="#Simulate.interrupt!"><code>Simulate.interrupt!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interrupt!(p::SimProcess, ev::SEvent, value=nothing)</code></pre><p>Interrupt a <code>SimProcess</code> by throwing a <code>SimException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L144-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}" href="#Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}"><code>Simulate.stop!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Stop a SimProcess</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L154">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-‚Ä¶-1" href="#Delay-and-wait-‚Ä¶-1">Delay and wait ‚Ä¶</a></h3><p>Processes do not need to handle their events explicitly, but can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> ‚Ä¶ on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.delay!" href="#Simulate.delay!"><code>Simulate.delay!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!([sim::Clock], t::Number)</code></pre><p>Delay a process for a time interval <code>t</code> on the clock <code>sim</code>. Suspend the calling process until being reactivated by the clock at the appropriate time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not provided, the delay goes to <code>ùê∂</code>.</li><li><code>t::Number</code>: the time interval for the delay.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L77-L87">source</a><div><div><pre><code class="language-none">delay!([sim::Clock], T::Timing, t::Number)</code></pre><p>Used for delaying a process <em>until</em> a given time t.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, the delay goes to ùê∂,</li><li><code>T::Timing</code>: only <code>until</code> is accepted,</li><li><code>t::Number</code>: delay until time t if t &gt; sim.time, else give a warning.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L95-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.wait!" href="#Simulate.wait!"><code>Simulate.wait!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!([sim::Clock], cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)</code></pre><p>Wait on a clock for a condition to become true. Suspend the calling process until the given condition is true.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is supplied, the delay goes to <code>ùê∂</code>,</li><li><code>cond::Union{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true only if all expressions or SimFunctions   therein return true,</li><li><code>scope::Module=Main</code>: evaluation scope for given expressions.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L119-L132">source</a></section><h3><a class="nav-anchor" id="Now-1" href="#Now-1">Now</a></h3><p>If processes want IO-operations to finish before letting the clock proceed, they can enclose those operations in a <code>now!</code> call.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.now!" href="#Simulate.now!"><code>Simulate.now!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">now!([sim::Clock], op::Union{SimExpr, Array, Tuple})</code></pre><p>Let the given operation be executed now by the clock. Thus the clock cannot proceed before the op is finished.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not provided, the operation is executed by ùê∂ (must be running),</li><li><code>op::Union{SimExpr, Array, Tuple}</code>: operation to execute.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/process.jl#L157-L167">source</a></section><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Œît.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample_time!" href="#Simulate.sample_time!"><code>Simulate.sample_time!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!([sim::Clock], Œît::Number)</code></pre><p>set the clock&#39;s sample rate starting from now (<code>tau(sim)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not supplied, set the sample rate on ùê∂,</li><li><code>Œît::Number</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L495-L504">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample!" href="#Simulate.sample!"><code>Simulate.sample!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample!([sim::Clock], ex::Union{Expr, SimFunction}, Œît::Number=sim.Œît; scope::Module=Main)</code></pre><p>enqueue an expression for sampling.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if not supplied, it samples on ùê∂,</li><li><code>ex::Union{Expr, SimFunction}</code>: an expression or function,</li><li><code>Œît::Number=sim.Œît</code>: set the clock&#39;s sampling rate, if no Œît is given, it takes   the current sampling rate, if that is 0, it calculates one,</li><li><code>scope::Module=Main</code>: optional, an evaluation scope for a given expression.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L511-L522">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed ‚Ä¶ Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.reset!" href="#Simulate.reset!"><code>Simulate.reset!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(sim::Clock, Œît::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)</code></pre><p>reset a clock</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>Œît::Number=0</code>: time increment</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Œît::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0

julia&gt; reset!(c)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;

julia&gt; c
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L162-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.incr!" href="#Simulate.incr!"><code>Simulate.incr!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(sim::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L719-L723">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.run!" href="#Simulate.run!"><code>Simulate.run!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(sim::Clock, duration::Number)</code></pre><p>Run a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L709-L714">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Clock}" href="#Simulate.stop!-Tuple{Clock}"><code>Simulate.stop!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(sim::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L726-L730">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.resume!" href="#Simulate.resume!"><code>Simulate.resume!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(sim::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L733-L737">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sync!" href="#Simulate.sync!"><code>Simulate.sync!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(sim::Clock, to::Clock=ùê∂)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>sim</code> accordingly. Convert or force sim.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/717d904012e96f5b36e3e4a31553e2101ac83b63/src/clock.jl#L131-L137">source</a></section><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>currently <a href="https://ci.appveyor.com/project/pbayer/simulate-jl-ueug1/branch/master">builds fail on x86 machines with Julia 1.0</a>, Appveyor is set to allow this. There is an <a href="https://github.com/pbayer/Simulate.jl/issues/8">issue in the repo</a>, maybe someone can look into it or fix it.</p></div><footer><hr/><a class="previous" href="../approach/"><span class="direction">Previous</span><span class="title">Building models</span></a><a class="next" href="../examples/examples/"><span class="direction">Next</span><span class="title">Overview</span></a></footer></article></body></html>
