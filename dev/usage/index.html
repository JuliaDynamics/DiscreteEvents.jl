<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../intro/">Getting started</a></li><li><a class="toctext" href="../approach/">Building models</a></li><li class="current"><a class="toctext" href>Usage</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#The-clock-1">The clock</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li><li><a class="toctext" href="#Logging-1">Logging</a></li></ul></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The current stable, registered version of <code>Simulate.jl</code> is installed with</p><pre><code class="language-julia">pkg&gt; add Simulate</code></pre><p>The development version is installed with:</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/Simulate.jl&quot;)</code></pre><p>The package is then loaded with</p><pre><code class="language-julia-repl">julia&gt; using Simulate</code></pre><h2><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Clock" href="#Simulate.Clock"><code>Simulate.Clock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Δt::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::Number=0</code>: time increment. If no Δt is given, the simulation doesn&#39;t tick,   but jumps from event to event. Δt can be set later with <code>sample_time!</code>.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>state::SState</code>: clock state</li><li><code>time::Float64</code>: clock time</li><li><code>unit::FreeUnits</code>: time unit</li><li><code>events::PriorityQueue{SimEvent,Float64}</code>: scheduled events</li><li><code>cevents::Array{SimCond,1}</code>: conditional events</li><li><code>processes::Dict{Any, SimProcess}</code>: registered processes</li><li><code>end_time::Float64</code>: end time for simulation</li><li><code>evcount::Int64</code>: event counter</li><li><code>scount::Int64</code>: sample count</li><li><code>tev::Float64</code>: next event time</li><li><code>Δt::Float64</code>: sampling time, timestep between ticks</li><li><code>sexpr::Array{Sample,1}</code>: sampling expressions to evaluate at each tick</li><li><code>tsa::Float64</code>: next sample time</li></ul><p>If necessary the fields can be accesses with <code>c.time</code> … if <code>c</code> is your clock variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; init!(c)
Simulate.Idle()
julia&gt; c = Clock(1s, unit=minute)
Clock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.016666666666666666
julia&gt; c = Clock(1s)
Clock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0
julia&gt; c = Clock(t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; c = Clock(1s, t0=1hr)
Clock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/types.jl#L220-L270">source</a></section><p>The central clock  is 𝐶. You can set time units and query the current simulation time.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.𝐶" href="#Simulate.𝐶"><code>Simulate.𝐶</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">𝐶
Clk</code></pre><p><code>𝐶</code> (𝐶 = \itC+tab) or <code>Clk</code> is the central simulation clock. Since most simulations work with <strong>one</strong> time, they should use 𝐶 for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; 𝐶  # central clock
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; Clk  # alias
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; 𝐶.time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L71-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setUnit!" href="#Simulate.setUnit!"><code>Simulate.setUnit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(sim::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60) # setup a new clock with t0=60
Clock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; tau(c) # current time is 60.0 NoUnits
60.0
julia&gt; setUnit!(c, s)  # set clock unit to Unitful.s
60.0 s
julia&gt; tau(c) # current time is now 60.0 s
60.0 s
julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute
julia&gt; tau(c) # current time is now 1.0 minute
1.0 minute
julia&gt; typeof(tau(c))  # tau(c) now returns a time Quantity ...
Quantity{Float64,𝐓,Unitful.FreeUnits{(minute,),𝐓,nothing}}
julia&gt; isa(tau(c), Time)
true
julia&gt; uconvert(s, tau(c)) # ... which can be converted to other time units
60.0 s
julia&gt; tau(c).val  # it has a value of 1.0
1.0
julia&gt; c.time  # internal clock time is set to 1.0 (is a Float64)
1.0
julia&gt; c.unit  # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L6-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau-Tuple{Clock}" href="#Simulate.tau-Tuple{Clock}"><code>Simulate.tau</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tau(sim::Clock=𝐶)
τ(sim::Clock=𝐶)</code></pre><p>Return the current simulation time (τ = \tau+tab).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; tau() # gives the central time
0.0
julia&gt; τ() # alias, gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L96-L115">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@tau-Tuple{Clock}" href="#Simulate.@tau-Tuple{Clock}"><code>Simulate.@tau</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@tau(sim::Clock)
@tau sim
@tau()
@tau</code></pre><p>return the current simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock argument is given, it returns 𝐶&#39;s time.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L129-L140">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Events are scheduled on the clock&#39;s timeline and are triggered at a given simulation time or under conditions which may become true during simulation.</p><h3><a class="nav-anchor" id="Expressions-and-functions-as-events-and-conditions-1" href="#Expressions-and-functions-as-events-and-conditions-1">Expressions and functions as events and conditions</a></h3><p>Julia expressions and functions can be scheduled as events.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Timing" href="#Simulate.Timing"><code>Simulate.Timing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time,</li><li><code>after</code>: schedule an event a given time after current time,</li><li><code>every</code>: schedule an event every given time from now on,</li><li><code>before</code>: a timed condition is true before a given time,</li><li><code>until</code>: delay until t.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimFunction" href="#Simulate.SimFunction"><code>Simulate.SimFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimFunction(func::Function, arg...; kw...)
SF(func::Function, arg...; kw...)</code></pre><p>Prepare a function for being called as an event in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>func::Function</code>: function to be executed at a later simulation time</li><li><code>arg...</code>: arguments to the function</li><li><code>kw...</code>: keyword arguments</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Be aware that, if the variables stored in a SimFunction are composite types, they can change until they are evaluated later by <code>func</code>. But that&#39;s the nature of simulation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; f(a,b,c; d=4, e=5) = a+b+c+d+e  # define a function
f (generic function with 1 method)

julia&gt; sf = SimFunction(f, 10, 20, 30, d=14, e=15)  # store it as SimFunction
SimFunction(f, (10, 20, 30), Base.Iterators.Pairs(:d =&gt; 14,:e =&gt; 15))

julia&gt; sf.func(sf.arg...; sf.kw...)  # and it can be executed later
89

julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2) # now we set up a dictionary
Dict{Symbol,Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; f(t) = t[:a] + t[:b] # and a function adding :a and :b
f (generic function with 2 methods)

julia&gt; f(d)  # our add function gives 3
3

julia&gt; ff = SimFunction(f, d)   # we set up a SimFunction
SimFunction(f, (Dict(:a =&gt; 1,:b =&gt; 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())

julia&gt; d[:a] = 10  # later somehow we need to change d
10

julia&gt; ff  # our SimFunction ff has changed too
SimFunction(f, (Dict(:a =&gt; 10,:b =&gt; 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())

julia&gt; ff.func(ff.arg...; ff.kw...)  # and calling it gives a different result
12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/types.jl#L18-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SF" href="#Simulate.@SF"><code>Simulate.@SF</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SF(f::Symbol, arg...)
@SF f arg...</code></pre><p>create a <code>SimFunction</code> from arguments f, arg...</p><p><strong>Arguments</strong></p><ul><li><code>f::Symbol</code>: a function given as a symbol, e.g. <code>:f</code> if f() is your function,</li><li><code>arg...</code>: further arguments to your function</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ol><li>keyword arguments don&#39;t work with this macro, use SF instead.</li><li>if you give @SF as argument(s) to a function, you must enclose it/them  in parentheses ( @SF ... ) or ( (@SF ...), (@SF ...) )</li></ol></div></div><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; using Simulate

julia&gt; @SF :sin pi
SimFunction(sin, (π,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())
julia&gt; a = 1
1
julia&gt; incra() = global a += 1             # create a simple increment function
incra (generic function with 1 method)
julia&gt; event!((@SF :incra), after, 3)      # schedule an increment after 3 time units
3.0
julia&gt; a
1
julia&gt; run!(𝐶, 5)
&quot;run! finished with 1 clock events, 0 sample steps, simulation time: 5.0&quot;
julia&gt; a
2
julia&gt; event!((@SF :incra), (@tau :&gt;= 8))  # schedule a conditional increment
5.0
julia&gt; run!(𝐶, 5)
&quot;run! finished with 0 clock events, 500 sample steps, simulation time: 10.0&quot;
julia&gt; a
3
julia&gt; event!(((@SF :incra), (@SF :incra)), ((@tau :&gt;= 12), (@val :a :&lt;= 3)))
10.0
julia&gt; run!(𝐶, 5)
&quot;run! finished with 0 clock events, 500 sample steps, simulation time: 15.0&quot;
julia&gt; a
5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L63-L110">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimExpr" href="#Simulate.SimExpr"><code>Simulate.SimExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SimExpr = Union{Expr, SimFunction}</code></pre><p>A type which is either a <code>SimFunction</code> or any Julia expression <code>Expr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/types.jl#L81-L85">source</a></section><p>SimFunctions and expressions can be given to events on their own or in arrays or tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(SF(f, 1, 2, 3, diff=pi), every, 1)  # one SimFunction
    event!((:(i += 1), SF(g, j)), [:(tau() ≥ 50), SF(isready, input), :(a ≤ 10)]) # two SimExpr under three conditions
end</code></pre><p>All given expressions or functions are then evaluated at a given simulation time or when during simulation the given conditions become true.</p><h3><a class="nav-anchor" id="Timed-events-1" href="#Timed-events-1">Timed events</a></h3><p>SimFunctions and expressions can be scheduled for execution at given clock times.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64
event!(ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)</code></pre><p>Schedule an event for a given simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>t::Float64</code> or <code>t::Time</code>: simulation time, if t &lt; sim.time set t = sim.time,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event. May return a time <code>&gt; t</code> from repeated applications of <code>nextfloat(t)</code> if there are events scheduled for <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)
julia&gt; event!(𝐶, SimFunction(myfunc, 1, 2), 1) # a 1st event
1.0
julia&gt; event!(𝐶, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time
1.0000000000000002
julia&gt; event!(𝐶, SimFunction(myfunc, 3, 4), 1s)
Warning: clock has no time unit, ignoring units
1.0000000000000004
julia&gt; setUnit!(𝐶, s)
0.0 s
julia&gt; event!(𝐶, SimFunction(myfunc, 4, 5), 1minute)
60.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L272-L311">source</a></section><p>As a convenience the <code>Timing</code> can be also choosen using <code>at</code>, <code>after</code> or <code>every</code> <code>t</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)::Float64
event!(ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)</code></pre><p>Schedule a timed event, that is an event with a timing.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>T::Timing</code>: a timing, <code>at</code>, <code>after</code> or <code>every</code> (<code>before</code> behaves like <code>at</code>),</li><li><code>t::Float64</code> or <code>t::Time</code>: simulation time,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; setUnit!(𝐶, s)
0.0 s
julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)
julia&gt; event!(𝐶, SimFunction(myfunc, 5, 6), after, 1hr)
3600.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L327-L357">source</a></section><h3><a class="nav-anchor" id="Conditional-events-1" href="#Conditional-events-1">Conditional events</a></h3><p>They are evaluated at each clock tick (like sampling functions) and are fired when all conditions are met.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main):
event!(ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)</code></pre><p>Schedule a conditional event.</p><p>It is executed immediately if the conditions are met, else the condition is checked at each clock tick Δt. After a conditional event is triggered, it is removed from the clock. If no sampling rate Δt is setup, a default sampling rate is setup depending on the scale of the remaining simulation time <span>$Δt = scale(t_r)/100$</span> or <span>$0.01$</span> if <span>$t_r = 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>cond::{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event</li></ul><p><strong>returns</strong></p><p>current simulation time <code>tau(sim)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L391-L423">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since conditions often are not met exactly you should prefer inequalities like &lt;, ≤, ≥, &gt; to equality == in order to get sure that a fulfilled condition can be detected, e.g. <span>$:(tau() ≥ 100)$</span> is preferable to <span>$:(tau() == 100)$</span>.</p></div></div><p>There are some helper functions and macros for defining conditions. It is usually more convenient to use the macros since the generate the necessary SimFunctions directly:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau-Tuple{Clock,Symbol,Union{Number, Symbol}}" href="#Simulate.tau-Tuple{Clock,Symbol,Union{Number, Symbol}}"><code>Simulate.tau</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tau(sim::Clock, check::Symbol, x::Union{Number,Symbol}; m::Module=Main)
tau(check::Symbol, x::Union{Number,Symbol}; m::Module=Main)</code></pre><p>Compare the current simulation time against a number or a variable.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock variable, if not given, it is 𝐶.</li><li><code>check::Symbol</code>: a comparison operator as a symbol like <code>:&gt;</code>,</li><li><code>x::Union{Number,Symbol}</code>: a number or a symbolic variable like <code>:a</code>,</li><li><code>m::Module=Main</code>: the evaluation scope, if a symbolic variable is given.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; tau(:&gt;=, 1)
false
julia&gt; tau(:&lt;, 1)
true
julia&gt; a = 1
1
julia&gt; tau(:&lt;=, :a)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L5-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@tau-Tuple{Any,Symbol,Union{Number, QuoteNode}}" href="#Simulate.@tau-Tuple{Any,Symbol,Union{Number, QuoteNode}}"><code>Simulate.@tau</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@tau(sim::Clock, check::Symbol, val)
@tau sim check val
@tau(check::Symbol, val)
@tau check val</code></pre><p>create a <code>SimFunction</code> comparing current simulation time with a given value or variable.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, it compares with 𝐶&#39;s time,</li><li><code>check::Symbol</code>: the check operator must be given as a symbol e.g. <code>:&lt;</code>,</li><li><code>val::Union{Number, QuoteNode}</code>: a value or a symbolic variable,</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you give @tau as argument(s) to a function, you must enclose it/them in parentheses ( @tau ... ) or ( (@tau ...), (@tau ...) )!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; s = @tau :≥ 100
SimFunction(Simulate.tau, (:≥, 100, Main), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())
julia&gt; Simulate.simExec(s)
false
julia&gt; Simulate.simExec(@tau &lt; 100)                ### wrong !!
ERROR: syntax: &quot;&lt;&quot; is not a unary operator
julia&gt; Simulate.simExec(@tau :&lt; 100)               ### correct
true
julia&gt; a = 1
1
julia&gt; Simulate.simExec(@tau :&lt; :a)
true
julia&gt; event!(SF(()-&gt;global a+=1), (@tau :&gt;= 3))   ### create a conditional event
0.0
julia&gt; a
1
julia&gt; run!(𝐶, 5)                                  ### run
&quot;run! finished with 0 clock events, 500 sample steps, simulation time: 5.0&quot;
julia&gt; a
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L148-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.val" href="#Simulate.val"><code>Simulate.val</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">val(a::Union{Number, Symbol}, check::Symbol, x::Union{Number, Symbol}, m::Module=Main)</code></pre><p>Compare two variables or numbers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; m = @__MODULE__;  # necessary for doctest

julia&gt; val(1, :&lt;=, 2)
true
julia&gt; a = 1
1
julia&gt; val(:a, :&lt;=, 2, m)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L36-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@val" href="#Simulate.@val"><code>Simulate.@val</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@val(a, check::QuoteNode, x)
@val a check b</code></pre><p>Create a Simfunction comparing two values a and b or two symbolic variables :a and :b. The comparison operator must be given symbolically, e.g. <code>:≤</code>.</p><p><strong>Arguments</strong></p><ul><li>`a, b::: a number, expression or symbol</li><li><code>check::QuoteNode</code>: a comparison operator as a symbol like <code>:≤</code></li><li><code>, m::Module=Main</code>: a module scope for evaluation of given symbolic variables</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If you give @val as argument(s) to a function, you must enclose it/them in parentheses ( @val ... ) or e.g. ( (@tau ...), (@val ...) )!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; @val 1 :≤ 2
SimFunction(Simulate.val, (1, :≤, 2, Main), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())
julia&gt; Simulate.simExec(@val 1 :≤ 2)
true
julia&gt; a = 1
1
julia&gt; Simulate.simExec(@val :a :≤ 2)
true
julia&gt; event!(SF(()-&gt;global a+=1), ((@tau :&gt;= 3), (@val :a :&lt;= 3))) ### a conditional event
0.0
julia&gt; run!(𝐶, 5)
&quot;run! finished with 0 clock events, 500 sample steps, simulation time: 5.0&quot;
julia&gt; a
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L202-L240">source</a></section><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can be registered and run as processes if they have an input and an output channel as their first two arguments. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimProcess" href="#Simulate.SimProcess"><code>Simulate.SimProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimProcess( id, func::Function, arg...; kw...)
SP(id, func::Function, arg...; kw...)</code></pre><p>Prepare a function to run as a process in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>id</code>: some unique identification, it should get registered with</li><li><code>func::Function</code>: a function <code>f(arg...; kw...)</code></li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function as a SimProcess most often runs in a loop. It has to give back control by e.g. doing a <code>take!(input)</code> or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will starve everything else!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/types.jl#L182-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SP" href="#Simulate.@SP"><code>Simulate.@SP</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SP(id, f::Symbol, input::Channel, output::Channel, arg...)
@SP id f input output arg...</code></pre><p>create a <code>SimProcess</code> from arguments f, arg...</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>keyword arguments don&#39;t work with this macro, use SP instead.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/utils.jl#L115-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimException" href="#Simulate.SimException"><code>Simulate.SimException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimException(ev::SEvent, value=nothing)</code></pre><p>Define a SimException, which can be thrown to processes.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ev::SEvent</code>: delivers an event to the interrupted task</li><li><code>value=nothing</code>: deliver some other value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/types.jl#L166-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.process!" href="#Simulate.process!"><code>Simulate.process!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!(sim::Clock, p::SimProcess, cycles=Inf)
process!(p::SimProcess, cycles=Inf)</code></pre><p>Register a <code>SimProcess</code> to a clock, start it as an asynchronous process and return the <code>id</code> it was registered with. It can then be found under <code>sim.processes[id]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock, if no clock is given, it runs under 𝐶,</li><li><code>p::SimProcess</code></li><li><code>cycles::Number=Inf</code>: number of cycles, the process should run.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L43-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.interrupt!" href="#Simulate.interrupt!"><code>Simulate.interrupt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interrupt!(p::SimProcess, ev::SEvent, value=nothing)</code></pre><p>Interrupt a <code>SimProcess</code> by throwing a <code>SimException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L154-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}" href="#Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Stop a SimProcess</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L164">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-…-1" href="#Delay-and-wait-…-1">Delay and wait …</a></h3><p>Processes must not handle their events explicitly, but can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> … on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.delay!" href="#Simulate.delay!"><code>Simulate.delay!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!(sim::Clock, t::Number)
delay!(t::Number)</code></pre><p>Delay a process for a time interval <code>t</code> on the clock <code>sim</code>. Suspend the calling process until being reactivated by the clock at the appropriate time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock, if no clock is given, the delay goes to <code>𝐶</code>.</li><li><code>t::Number</code>: the time interval for the delay.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L86-L97">source</a><div><div><pre><code class="language-none">delay!(sim::Clock, T::Timing, t::Number)
delay!(T::Timing, t::Number)</code></pre><p>Used for delaying a process <em>until</em> a given time t.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, the delay goes to 𝐶,</li><li><code>T::Timing</code>: only <code>until</code> is accepted,</li><li><code>t::Number</code>: delay until time t if t &gt; sim.time.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L106-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.wait!" href="#Simulate.wait!"><code>Simulate.wait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!(sim::Clock, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)
wait!(cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)</code></pre><p>Wait on a clock for a condition to become true. Suspend the calling process until the given condition is true.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock, if no clock is given, the delay goes to <code>𝐶</code>.</li><li><code>cond::Union{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.</li><li><code>scope::Module=Main</code>: evaluation scope for given expressions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L128-L142">source</a></section><h3><a class="nav-anchor" id="Now-1" href="#Now-1">Now</a></h3><p>If processes want IO-operations to finish before letting the clock proceed, they can enclose those operations in a <code>now!</code> call.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.now!" href="#Simulate.now!"><code>Simulate.now!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">now!(sim::Clock, op::Union{SimExpr, Array, Tuple})
now!(op::Union{SimExpr, Array, Tuple})</code></pre><p>Let the given operation be executed now! by the clock. Thus it cannot proceed before it is finished.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>:</li><li><code>op::Union{SimExpr, Array, Tuple}</code>:</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/process.jl#L167-L178">source</a></section><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Δt.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample_time!" href="#Simulate.sample_time!"><code>Simulate.sample_time!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!(sim::Clock, Δt::Number)
sample_time!(Δt::Number)</code></pre><p>set the clock&#39;s sample rate starting from now (<code>tau(sim)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, set the sample rate on 𝐶,</li><li><code>Δt::Number</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L437-L447">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample!" href="#Simulate.sample!"><code>Simulate.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample!(sim::Clock, ex::Union{Expr, SimFunction}; scope::Module=Main)
sample!(ex::Union{Expr, SimFunction}; scope::Module=Main)</code></pre><p>enqueue an expression for sampling.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given, it samples on 𝐶,</li><li><code>ex::Union{Expr, SimFunction}</code>: an expression or function,</li><li><code>Δt::Number=sim.Δt</code>: set the clock&#39;s sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,</li><li><code>scope::Module=Main</code>: optional, an evaluation scope for a given expression.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L454-L466">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed … Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.reset!" href="#Simulate.reset!"><code>Simulate.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(sim::Clock, Δt::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)</code></pre><p>reset a clock</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>Δt::Number=0</code>: time increment</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Δt::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0
julia&gt; reset!(c)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; c
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L150-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.incr!" href="#Simulate.incr!"><code>Simulate.incr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(sim::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L664-L668">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.run!" href="#Simulate.run!"><code>Simulate.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(sim::Clock, duration::Number)</code></pre><p>Run a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L654-L659">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Clock}" href="#Simulate.stop!-Tuple{Clock}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(sim::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L671-L675">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.resume!" href="#Simulate.resume!"><code>Simulate.resume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(sim::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L678-L682">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sync!" href="#Simulate.sync!"><code>Simulate.sync!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(sim::Clock, to::Clock=𝐶)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>sim</code> accordingly. Convert or force sim.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L119-L125">source</a></section><h2><a class="nav-anchor" id="Logging-1" href="#Logging-1">Logging</a></h2><p>A <code>Logger</code> allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger&#39;s state it can be printed or stored in a table.</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><pre><code class="language-julia-repl">julia&gt; sim = Clock(); # create a clock

julia&gt; l = Logger(); # create a logging variable

julia&gt; init!(l, sim); # initialize the logger

julia&gt; (a, b, c) = 1, 1, 1 # create some variables
(1, 1, 1)

julia&gt; setup!(l, [:a, :b, :c], scope = m); # register them for logging
ERROR: UndefVarError: m not defined

julia&gt; record!(l) # record the variables with the current clock time
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Log)

julia&gt; l.last # show the last record
NamedTuple()

julia&gt; function f()  # a function for increasing and recording the variables
         global a += 1
         global b = a^2
         global c = a^3
         record!(l)
       end
f (generic function with 1 method)

julia&gt; switch!(l, 1); # switch logger to printing
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Switch)

julia&gt; f() # increase and record the variables
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Log)

julia&gt; switch!(l, 2); # switch logger to storing in data table
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Switch)

julia&gt; for i in 1:10 # create some events
           event!(sim, :(f()), i, scope = m)
       end
ERROR: UndefVarError: m not defined

julia&gt; run!(sim, 10) # run a simulation
&quot;run! finished with 0 clock events, 0 sample steps, simulation time: 10.0&quot;

julia&gt; l.df # view the recorded values
0×0 DataFrames.DataFrame</code></pre><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Logger" href="#Simulate.Logger"><code>Simulate.Logger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Logger()</code></pre><p>Setup and return a logging variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L5-L9">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.init!" href="#Simulate.init!"><code>Simulate.init!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">init!(sim::Clock)</code></pre><p>initialize a clock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/clock.jl#L685-L689">source</a><div><div><pre><code class="language-none">init!(L::Logger, sim::Clock)</code></pre><p>Initialize a Logger.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L95-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setup!" href="#Simulate.setup!"><code>Simulate.setup!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setup!(L::Logger, vars::Array{Symbol})</code></pre><p>Setup a logger with logging variables.</p><p><strong>Arguments</strong></p><ul><li><code>L::Logger</code></li><li><code>vars::Array{Symbol}</code>: An array of symbols, e.g. of global variables</li><li><code>scope::Module = Main</code>: Scope in which to evaluate the variables</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L102-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.switch!" href="#Simulate.switch!"><code>Simulate.switch!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">switch!(L::Logger, to::Number=0)</code></pre><p>Switch the operating mode of a logger.</p><p><code>to = 0</code>: no output, <code>to = 1</code>: print, `to = 2: store in log table&quot;</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L86-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.record!" href="#Simulate.record!"><code>Simulate.record!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">record!(L::Logger)</code></pre><p>record the logging variables with the current operating mode.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L115-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.clear!" href="#Simulate.clear!"><code>Simulate.clear!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clear!(L::Logger)</code></pre><p>clear the loggers last record and data table.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/a9b70b750eb4dd3c8c3450fc517b3ffdea34acba/src/logger.jl#L122-L126">source</a></section><footer><hr/><a class="previous" href="../approach/"><span class="direction">Previous</span><span class="title">Building models</span></a><a class="next" href="../examples/examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
