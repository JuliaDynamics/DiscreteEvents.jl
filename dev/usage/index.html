<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../overview/">Overview</a></li><li class="current"><a class="toctext" href>Usage</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Modeling-1">Modeling</a></li><li><a class="toctext" href="#The-clock-1">The clock</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li><li><a class="toctext" href="#Logging-1">Logging</a></li></ul></li><li><a class="toctext" href="../approach/">Modeling approaches</a></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubeshooting</a></li><li><a class="toctext" href="../history/">History</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Usage</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Usage</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>Simulate.jl</code> is not yet an registered package and is installed with</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/jl&quot;)</code></pre><p>The package is then loaded with</p><pre><code class="language-julia-repl">julia&gt; using Simulate</code></pre><h2><a class="nav-anchor" id="Modeling-1" href="#Modeling-1">Modeling</a></h2><p>Before we can do a simulation, we have to develop a model. Apart from Julia expressions and functions we have four elements here:</p><ul><li>a clock,</li><li>events,</li><li>processes and</li><li>sampling</li></ul><h2><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h2><p>The clock is central to any model and simulation, since it establishes the timeline. Here the clock contains not only the time, but also the time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Δt.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Clock" href="#Simulate.Clock"><code>Simulate.Clock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Δt::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::Number=0</code>: time increment. If no Δt is given, the simulation doesn&#39;t tick,   but jumps from event to event. Δt can be set later with <code>sample_time!</code>.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; init!(c)
Simulate.Idle()
julia&gt; c = Clock(1s, unit=minute)
Clock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.016666666666666666
julia&gt; c = Clock(1s)
Clock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0
julia&gt; c = Clock(t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; c = Clock(1s, t0=1hr)
Clock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/types.jl#L226-L259">source</a></section><p>We introduce a central clock 𝐶, can set time units and query the current simulation time.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.𝐶" href="#Simulate.𝐶"><code>Simulate.𝐶</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">𝐶
Clk</code></pre><p><code>𝐶</code> (𝐶 = \itC+tab) or <code>Clk</code> is the central simulation clock. Since most simulations work with <strong>one</strong> time, they should use 𝐶 for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; 𝐶  # central clock
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; Clk  # alias
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; 𝐶.time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L71-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setUnit!" href="#Simulate.setUnit!"><code>Simulate.setUnit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(sim::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60) # setup a new clock with t0=60
Clock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0
julia&gt; τ(c) # current time is 60.0 NoUnits
60.0
julia&gt; setUnit!(c, s)  # set clock unit to Unitful.s
60.0 s
julia&gt; τ(c) # current time is now 60.0 s
60.0 s
julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute
julia&gt; τ(c) # current time is now 1.0 minute
1.0 minute
julia&gt; typeof(τ(c))  # τ(c) now returns a time Quantity ...
Quantity{Float64,𝐓,Unitful.FreeUnits{(minute,),𝐓,nothing}}
julia&gt; isa(τ(c), Time)
true
julia&gt; uconvert(s, τ(c)) # ... which can be converted to other time units
60.0 s
julia&gt; τ(c).val  # it has a value of 1.0
1.0
julia&gt; c.time  # internal clock time is set to 1.0 (is a Float64)
1.0
julia&gt; c.unit  # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L6-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.τ" href="#Simulate.τ"><code>Simulate.τ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">τ(sim::Clock=𝐶)
tau(sim::Clock=𝐶)</code></pre><p>Return the current simulation time (τ = \tau+tab).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; τ() # gives the central time
0.0
julia&gt; tau() # alias, gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L96-L115">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Julia expressions and functions can be scheduled on the clock&#39;s timeline to be executed later at a given simulation time or under given conditions which may become true during simulation. Thereby expressions and functions can be mixed or given in an array or tuple to an event or to a event condition.</p><h3><a class="nav-anchor" id="Expressions-and-functions-as-events-and-conditions-1" href="#Expressions-and-functions-as-events-and-conditions-1">Expressions and functions as events and conditions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Timing" href="#Simulate.Timing"><code>Simulate.Timing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time</li><li><code>after</code>: schedule an event a given time after current time</li><li><code>every</code>: schedule an event every given time from now on</li><li><code>before</code>: a timed condition is true before a given time.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/c6da87ff4bc7a855e217856757ad3413cf6d1f79/base/#L0-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimFunction" href="#Simulate.SimFunction"><code>Simulate.SimFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimFunction(func::Function, arg...; kw...)
SF(func::Function, arg...; kw...)</code></pre><p>Prepare a function for being called as event in a simulation.</p><p><strong>Arguments</strong></p><ul><li><code>func::Function</code>: function to be executed at a later simulation time</li><li><code>arg...</code>: arguments to the function</li><li><code>kw...</code>: keyword arguments</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Be aware that, if the variables stored in a SimFunction are composite types, they can change until they are evaluated later by <code>func</code>. But that&#39;s the nature of simulation.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; f(a,b,c; d=4, e=5) = a+b+c+d+e  # define a function
f (generic function with 1 method)

julia&gt; sf = SimFunction(f, 10, 20, 30, d=14, e=15)  # store it as SimFunction
SimFunction(f, (10, 20, 30), Base.Iterators.Pairs(:d =&gt; 14,:e =&gt; 15))

julia&gt; sf.func(sf.arg...; sf.kw...)  # and it can be executed later
89

julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2) # now we set up a dictionary
Dict{Symbol,Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; f(t) = t[:a] + t[:b] # and a function adding :a and :b
f (generic function with 2 methods)

julia&gt; f(d)  # our add function gives 3
3

julia&gt; ff = SimFunction(f, d)   # we set up a SimFunction
SimFunction(f, (Dict(:a =&gt; 1,:b =&gt; 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())

julia&gt; d[:a] = 10  # later somehow we need to change d
10

julia&gt; ff  # our SimFunction ff has changed too
SimFunction(f, (Dict(:a =&gt; 10,:b =&gt; 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())

julia&gt; ff.func(ff.arg...; ff.kw...)  # and calling it gives a different result
12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/types.jl#L17-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SF" href="#Simulate.@SF"><code>Simulate.@SF</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SF(f::Symbol, arg...)
@SF f arg...</code></pre><p>create a <code>SimFunction</code> from arguments f, arg...</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>keyword arguments don&#39;t work with this macro, use SF instead.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L61-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimExpr" href="#Simulate.SimExpr"><code>Simulate.SimExpr</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">SimExpr = Union{Expr, SimFunction}</code></pre><p>A type which is either a <code>SimFunction</code> or any Julia expression <code>Expr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/types.jl#L80-L84">source</a></section><p>SimFunctions and expressions can be given to events on their own  or in arrays or tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(SF(f, 1, 2, 3, diff=pi), every, 1)  # one SimFunction
    event!((:(i += 1), SF(g, j)), [:(τ() ≥ 50), SF(isready, input), :(a ≤ 10)]) # two SimExpr under three conditions
end</code></pre><p>All given expressions or functions are then evaluated at a certain event or when checking for conditions.</p><h3><a class="nav-anchor" id="Timed-events-1" href="#Timed-events-1">Timed events</a></h3><p>SimFunctions and expressions can be scheduled for execution at given clock times.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64
event!(ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)</code></pre><p>Schedule an event for a given simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>t::Float64</code> or <code>t::Time</code>: simulation time,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event. May return a time <code>&gt; t</code> from repeated applications of <code>nextfloat(t)</code> if there are events scheduled for <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)
julia&gt; event!(𝐶, SimFunction(myfunc, 1, 2), 1) # a 1st event
1.0
julia&gt; event!(𝐶, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time
1.0000000000000002
julia&gt; event!(𝐶, SimFunction(myfunc, 3, 4), 1s)
Warning: clock has no time unit, ignoring units
1.0000000000000004
julia&gt; setUnit!(𝐶, s)
0.0 s
julia&gt; event!(𝐶, SimFunction(myfunc, 4, 5), 1minute)
60.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L273-L312">source</a></section><p>As a convenience the timing can be also choosen using a <code>Timing</code> like <code>at</code>, <code>after</code> or <code>every</code> <code>t</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)::Float64
event!(ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)</code></pre><p>Schedule a timed event, that is an event with a timing.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>T::Timing</code>: a timing, <code>at</code>, <code>after</code> or <code>every</code> (<code>before</code> behaves like <code>at</code>),</li><li><code>t::Float64</code> or <code>t::Time</code>: simulation time,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; setUnit!(𝐶, s)
0.0 s
julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)
julia&gt; event!(𝐶, SimFunction(myfunc, 5, 6), after, 1hr)
3600.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L327-L357">source</a></section><h3><a class="nav-anchor" id="Conditional-events-1" href="#Conditional-events-1">Conditional events</a></h3><p>They are evaluated at each clock tick (like sampling functions) and are fired when all conditions are met.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}" href="#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}"><code>Simulate.event!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main):
event!(ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)</code></pre><p>Schedule a conditional event.</p><p>It is executed immediately if the conditions are met, else the condition is checked at each clock tick Δt. After a conditional event is triggered, it is removed from the clock. If no sampling rate Δt is setup, a default sampling rate is setup depending on the scale of the remaining simulation time <span>$Δt = scale(t_r)/100$</span> or <span>$0.01$</span> if <span>$t_r = 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: simulation clock, if no clock is given, the event goes to 𝐶,</li><li><code>ex::{SimExpr, Array, Tuple}</code>: an expression or SimFunction or an array or tuple of them,</li><li><code>cond::{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event</li></ul><p><strong>returns</strong></p><p>current simulation time <code>τ(sim)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L372-L404">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since conditions often are not met exactly you should prefer inequalities like &lt;, ≤, ≥, &gt; to equality == in order to get sure that a fulfilled condition can be detected, e.g. <span>$:(τ() ≥ 100)$</span> is preferable to <span>$:(τ() == 100)$</span>.</p></div></div><p>There are some helper functions and macros for defining conditions. It is usually more convenient to use the macros since the generate the necessary SimFunctions directly:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tauis" href="#Simulate.tauis"><code>Simulate.tauis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tauis(sim::Clock, check::Symbol, x::Union{Number,Symbol}; m::Module=Main)
tauis(check::Symbol, x::Union{Number,Symbol}; m::Module=Main)</code></pre><p>Compare the current simulation time against a number or a variable.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock variable, if not given, it is 𝐶.</li><li><code>check::Symbol</code>: a comparison operator as a symbol like <code>:&gt;</code>,</li><li><code>x::Union{Number,Symbol}</code>: a number or a symbolic variable like <code>:a</code>,</li><li><code>m::Module=Main</code>: the evaluation scope, if a symbolic variable is given.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; tauis(:&gt;=, 1)
false
julia&gt; tauis(:&lt;, 1)
true
julia&gt; a = 1
1
julia&gt; tauis(:&lt;=, :a)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L5-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@tauis" href="#Simulate.@tauis"><code>Simulate.@tauis</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@tauis(sim::Clock, check::Symbol, val::Number)
@tauis sim check val
@tauis(check::Symbol, val::Number)
@tauis check val</code></pre><p>create a <code>SimFunction</code> comparing current simulation time with a given value. The comparison operator must be given as a symbol like <code>:&lt;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; s = @tauis :≥ 100
SimFunction(Simulate.tauis, (:≥, 100), Base.Iterators.Pairs(:m =&gt; Main))
julia&gt; Simulate.simExec(s)
false
julia&gt; Simulate.simExec(@tauis &lt; 100)
ERROR: syntax: &quot;&lt;&quot; is not a unary operator
julia&gt; Simulate.simExec(@tauis :&lt; 100)
true
julia&gt; Simulate.simExec(@tauis :&gt;= 100)
false
julia&gt; a = 1
1
julia&gt; Simulate.simExec(@tauis :&lt; :a)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L89-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.checkval" href="#Simulate.checkval"><code>Simulate.checkval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">checkval(a::Union{Number, Symbol}, check::Symbol, x::Union{Number, Symbol}; m::Module=Main)</code></pre><p>Compare two variables or numbers.</p><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; using Simulate

julia&gt; checkval(1, :&lt;=, 2)
true
julia&gt; a = 1
1
julia&gt; checkval(:a, :&lt;=, 2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L36-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@checkval" href="#Simulate.@checkval"><code>Simulate.@checkval</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@checkval(a::Union{Number, QuoteNode}, check::QuoteNode, b::Union{Number, QuoteNode}, m::Module=Main)
@checkval a check b m
@checkval a check b</code></pre><p>Create a Simfunction comparing two values a and b or two symbolic variables :a and :b. The comparison operator must be given symbolically, e.g. <code>:≤</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a,b::Union{Number, QuoteNode}</code>: a number or a symbol like <code>:a</code></li><li><code>check::QuoteNode</code>: a comparison operator as a symbol like <code>:≤</code></li><li><code>, m::Module=Main</code>: a module scope for evaluation of given symbolic variables</li></ul><p><strong>Examples</strong></p><pre><code class="language-">julia&gt; using Simulate

julia&gt; @checkval 1 :≤ 2
SimFunction(checkval, (1, :≤, 2), Base.Iterators.Pairs(:m =&gt; Main))
julia&gt; Simulate.simExec(@checkval 1 :≤ 2)
true
julia&gt; a = 1
1
julia&gt; Simulate.simExec(@checkval :a :≤ 2)
true</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L126-L153">source</a></section><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can be registered and run as processes if they have an input and an output channel as their first two arguments. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimProcess" href="#Simulate.SimProcess"><code>Simulate.SimProcess</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimProcess( id, func::Function, body,
            input::Channel=Channel(Inf), output::Channel=Channel(Inf),
            arg...; kw...)
SP(id, func::Function, body,
  input::Channel=Channel(Inf), output::Channel=Channel(Inf), arg...; kw...)</code></pre><p>Prepare a function to run as a process in a simulation.</p><p><strong>Arguments</strong></p><ul><li><code>id</code>: some unique identification</li><li><code>func::Function</code>: a function <code>f(in::Channel, out::Channel, arg...; kw...)</code></li><li><code>input::Channel=Channel(Inf)</code>: <code>f</code>s input channel</li><li><code>output::Channel=Channel(Inf)</code>: <code>f</code>s output channel</li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function <code>f</code> running as a SimProcess is put in a loop. So it has to give back control by e.g. doing a <code>take!(input)</code> on its input channel or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will after start starve everything else!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/types.jl#L181-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.@SP" href="#Simulate.@SP"><code>Simulate.@SP</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@SP(id, f::Symbol, input::Channel, output::Channel, arg...)
@SP id f input output arg...</code></pre><p>create a <code>SimFunction</code> from arguments f, arg...</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>keyword arguments don&#39;t work with this macro, use SF instead.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/utils.jl#L75-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.SimException" href="#Simulate.SimException"><code>Simulate.SimException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimException(ev::SEvent, value=nothing)</code></pre><p>Define a SimException, which can be thrown to processes.</p><p><strong>Parameters</strong></p><ul><li><code>ev::SEvent</code>: delivers an event to the interrupted task</li><li><code>value=nothing</code>: deliver some other value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/types.jl#L165-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.process!" href="#Simulate.process!"><code>Simulate.process!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!(sim::Clock, p::SimProcess)</code></pre><p>Register a <code>SimProcess</code> to a clock and return the <code>id</code> it was registered with. It can then be found under <code>sim.processes[id]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/process.jl#L5-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.start!" href="#Simulate.start!"><code>Simulate.start!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">start!(sim::Clock)</code></pre><p>Start all registered processes in a clock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/process.jl#L127-L131">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}" href="#Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(p::SimProcess, ev::SEvent, value=nothing)</code></pre><p>Stop a <code>SimProcess</code> by throwing a <code>SimException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/process.jl#L134-L138">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-…-1" href="#Delay-and-wait-…-1">Delay and wait …</a></h3><p>Processes must not handle their events explicitly, but can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> … on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.delay!" href="#Simulate.delay!"><code>Simulate.delay!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!(sim::Clock, t::Number)
delay!(t::Number)</code></pre><p>Delay a process for a time interval <code>t</code> on the clock <code>sim</code>. Suspend the calling process until being reactivated by the clock at the appropriate time.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock, if no clock is given, the delay goes to <code>𝐶</code>.</li><li><code>t::Number</code>: the time interval for the delay.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/process.jl#L75-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.wait!" href="#Simulate.wait!"><code>Simulate.wait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!(sim::Clock, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)
wait!(cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)</code></pre><p>Wait on a clock for a condition to become true. Suspend the calling process until the given condition is true.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: clock, if no clock is given, the delay goes to <code>𝐶</code>.</li><li><code>cond::Union{SimExpr, Array, Tuple}</code>: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.</li><li><code>scope::Module=Main</code>: evaluation scope for given expressions</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/process.jl#L94-L108">source</a></section><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>SimProcess</code>es operate in a loop. They have to give back control to other processes by calling suspending functions, which will <code>yield()</code> them. Otherwise they will after start starve everything else!</p><p>On the other hand, functions running in the <code>Main</code> scope <strong>must not call</strong> those functions since they may suspend the main program.</p></div></div><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Δt.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample_time!" href="#Simulate.sample_time!"><code>Simulate.sample_time!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!(sim::Clock, Δt::Number)</code></pre><p>set the clock&#39;s sampling time starting from now (<code>τ(sim)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>Δt::Number</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L431-L438">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample!" href="#Simulate.sample!"><code>Simulate.sample!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample!(sim::Clock, ex::Union{Expr, SimFunction}; scope::Module=Main)
sample!(ex::Union{Expr, SimFunction}; scope::Module=Main)</code></pre><p>enqueue an expression for sampling.</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code>: if no clock is given it samples on 𝐶</li><li><code>ex::Union{Expr, SimFunction}</code>: an expression or function</li><li><code>scope::Module=Main</code>: optional, a scope for the expression to be evaluated in</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L444-L454">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed … Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.reset!" href="#Simulate.reset!"><code>Simulate.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(sim::Clock, Δt::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)</code></pre><p>reset a clock</p><p><strong>Arguments</strong></p><ul><li><code>sim::Clock</code></li><li><code>Δt::Number=0</code>: time increment</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Δt::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0
julia&gt; reset!(c)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; c
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L150-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.incr!" href="#Simulate.incr!"><code>Simulate.incr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(sim::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L637-L641">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.run!" href="#Simulate.run!"><code>Simulate.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(sim::Clock, duration::Number)</code></pre><p>Run a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L627-L632">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Clock}" href="#Simulate.stop!-Tuple{Clock}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(sim::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L644-L648">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.resume!" href="#Simulate.resume!"><code>Simulate.resume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(sim::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L651-L655">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sync!" href="#Simulate.sync!"><code>Simulate.sync!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(sim::Clock, to::Clock=𝐶)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>sim</code> accordingly. Convert or force sim.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L119-L125">source</a></section><h2><a class="nav-anchor" id="Logging-1" href="#Logging-1">Logging</a></h2><p>A <code>Logger</code> allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger&#39;s state it can be printed or stored in a table.</p><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><pre><code class="language-julia-repl">julia&gt; sim = Clock(); # create a clock

julia&gt; l = Logger(); # create a logging variable

julia&gt; init!(l, sim); # initialize the logger

julia&gt; (a, b, c) = 1, 1, 1 # create some variables
(1, 1, 1)

julia&gt; setup!(l, [:a, :b, :c], scope = m); # register them for logging
ERROR: UndefVarError: m not defined

julia&gt; record!(l) # record the variables with the current clock time
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Log)

julia&gt; l.last # show the last record
NamedTuple()

julia&gt; function f()  # a function for increasing and recording the variables
         global a += 1
         global b = a^2
         global c = a^3
         record!(l)
       end
f (generic function with 1 method)

julia&gt; switch!(l, 1); # switch logger to printing
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Switch)

julia&gt; f() # increase and record the variables
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Log)

julia&gt; switch!(l, 2); # switch logger to storing in data table
Warning: undefined transition Logger, ::Simulate.Empty, ::Simulate.Switch)

julia&gt; for i in 1:10 # create some events
           event!(sim, :(f()), i, scope = m)
       end
ERROR: UndefVarError: m not defined

julia&gt; run!(sim, 10) # run a simulation
&quot;run! finished with 0 clock events, 0 sample steps, simulation time: 10.0&quot;

julia&gt; l.df # view the recorded values
0×0 DataFrames.DataFrame</code></pre><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Logger" href="#Simulate.Logger"><code>Simulate.Logger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Logger()</code></pre><p>Setup and return a logging variable.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L5-L9">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.init!" href="#Simulate.init!"><code>Simulate.init!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">init!(sim::Clock)</code></pre><p>initialize a clock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/clock.jl#L658-L662">source</a><div><div><pre><code class="language-none">init!(L::Logger, sim::Clock)</code></pre><p>Initialize a Logger.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L95-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setup!" href="#Simulate.setup!"><code>Simulate.setup!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setup!(L::Logger, vars::Array{Symbol})</code></pre><p>Setup a logger with logging variables.</p><p><strong>Arguments</strong></p><ul><li><code>L::Logger</code></li><li><code>vars::Array{Symbol}</code>: An array of symbols, e.g. of global variables</li><li><code>scope::Module = Main</code>: Scope in which to evaluate the variables</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L102-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.switch!" href="#Simulate.switch!"><code>Simulate.switch!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">switch!(L::Logger, to::Number=0)</code></pre><p>Switch the operating mode of a logger.</p><p><code>to = 0</code>: no output, <code>to = 1</code>: print, `to = 2: store in log table&quot;</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L86-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.record!" href="#Simulate.record!"><code>Simulate.record!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">record!(L::Logger)</code></pre><p>record the logging variables with the current operating mode.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L115-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.clear!" href="#Simulate.clear!"><code>Simulate.clear!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">clear!(L::Logger)</code></pre><p>clear the loggers last record and data table.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/5fe3aa5d05bea11ada5547d3fbb31613a1f03685/src/logger.jl#L122-L126">source</a></section><footer><hr/><a class="previous" href="../overview/"><span class="direction">Previous</span><span class="title">Overview</span></a><a class="next" href="../approach/"><span class="direction">Next</span><span class="title">Modeling approaches</span></a></footer></article></body></html>
