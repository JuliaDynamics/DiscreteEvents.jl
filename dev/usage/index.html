<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · DiscreteEvents.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiscreteEvents.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../news/">News</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Introduction</a></li><li class="current"><a class="toctext" href>User guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Clocks-1">Clocks</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li><li><a class="toctext" href="#Resources-1">Resources</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Version history</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>User guide</a></li></ul><a class="edit-page" href="https://github.com/pbayer/DiscreteEvents.jl/blob/master/docs/src/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.DiscreteEvents" href="#DiscreteEvents.DiscreteEvents"><code>DiscreteEvents.DiscreteEvents</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">DiscreteEvents</code></pre><p>A Julia package for generating and simulating discrete events. It runs on Julia <code>VERSION ≥ v&quot;1.0&quot;</code>. Multithreading requires <code>VERSION ≥ v&quot;1.3&quot;</code>.</p><p>The current stable, registered version is installed with</p><pre><code class="language-julia">pkg&gt; add DiscreteEvents</code></pre><p>The development version is installed with:</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/DiscreteEvents.jl&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/DiscreteEvents.jl#L9-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.version" href="#DiscreteEvents.version"><code>DiscreteEvents.version</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">version</code></pre><p>Gives the package version:</p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; DiscreteEvents.version
v&quot;0.3.0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/DiscreteEvents.jl#L27-L38">source</a></section><h2><a class="nav-anchor" id="Clocks-1" href="#Clocks-1">Clocks</a></h2><p>Clock schedule and execute Julia functions or expressions as events at given times or under given conditions.</p><ul><li><code>Clock</code>s have virtual time and precede as fast as possible when they simulate chains of events. For parallel simulations they can control <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a>s on parallel threads.</li><li><code>RTClock</code>s schedule and execute events on a real (system) time line.</li></ul><p>Clocks have an ident number:</p><ul><li>a master <code>Clock</code> on thread has id = 0,</li><li>worker <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a>s on parallel threads have id ≥ 1,</li><li>real time <code>RTClock</code>s have id ≤ -1.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Clock" href="#DiscreteEvents.Clock"><code>DiscreteEvents.Clock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Δt::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::T=0.01</code>: time increment for sampling. Δt can be set later with <code>sample_time!</code>.</li><li><code>t0::U=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>id::Int</code>: clock ident number, 0: master clock, ≥ 1: parallel clock,</li><li><code>state::ClockState</code>: clock state,</li><li><code>time::Float64</code>: clock time,</li><li><code>unit::FreeUnits</code>: time unit,</li><li><code>end_time::Float64</code>: end time for simulation,</li><li><code>Δt::Float64</code>: sampling time, timestep between ticks,</li><li><code>ac::Vector{ClockChannel}</code>: <a href="../internals/#DiscreteEvents.ClockChannel"><code>channels</code></a> to active clocks on parallel threads,</li><li><code>sc::Schedule</code>: the clock <a href="../internals/#DiscreteEvents.Schedule"><code>Schedule</code></a> (events, cond events and sampling),</li><li><code>processes::Dict{Any, Prc}</code>: registered <code>Prc</code>es,</li><li><code>tn::Float64</code>: next timestep,</li><li><code>tev::Float64</code>: next event time,</li><li><code>evcount::Int</code>: event counter,</li><li><code>scount::Int</code>: sample counter</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                 # create a unitless clock (standard)
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c1 = Clock(1s, unit=minute)  # create a clock with unit [minute]
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 minute, Δt=0.01667 minute, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c2 = Clock(1s)               # create a clock with implicit unit [s]
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c3 = Clock(t0=60s)           # another clock with implicit unit [s]
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 s, Δt=0.01 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c4 = Clock(1s, t0=1hr)       # here Δt&#39;s unit [s] takes precedence
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=3600.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/types.jl#L181-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.RTClock" href="#DiscreteEvents.RTClock"><code>DiscreteEvents.RTClock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RTClock{E &lt;: ClockEvent} &lt;: AbstractClock</code></pre><p>A real time clock checks every given period for scheduled events and executes them. It has a time in seconds since its start or last reset and uses system time for updating.</p><p>Real time clocks are controlled over channels. Multiple real time clocks can be setup with arbitrary periods (≥ 1 ms). Real time clocks should not be created directly but rather with <code>CreateRTClock</code>.</p><p><strong>Fields</strong></p><ul><li><code>Timer::Timer</code>:     clock period in seconds, minimum is 0.001 (1 ms)</li><li><code>clock::Clock</code>:     clock work</li><li><code>cmd::Channel{T}</code>:  command channel to asynchronous clock</li><li><code>back::Channel{T}</code>: back channel from async clock</li><li><code>id::Int</code>:          arbitrary id number</li><li><code>thread::Int</code>:      thread the async clock is living in</li><li><code>time::Float64</code>:    clock time since start in seconds</li><li><code>t0::Float64</code>:      system time at clock start in seconds</li><li><code>T::Float64</code>:       clock period in seconds</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/types.jl#L330-L350">source</a></section><p>You can set time units and query the current clock time.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.setUnit!" href="#DiscreteEvents.setUnit!"><code>DiscreteEvents.setUnit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(clk::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; tau(c) # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c) # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L34-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.tau" href="#DiscreteEvents.tau"><code>DiscreteEvents.tau</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tau(clk::Clock=𝐶)</code></pre><p>Return the current simulation time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;
julia&gt; tau() # gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L109-L123">source</a></section><p>There is a default clock <code>𝐶</code>, which can be used for experimental work.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.𝐶" href="#DiscreteEvents.𝐶"><code>DiscreteEvents.𝐶</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">𝐶</code></pre><p><code>𝐶</code> (𝐶 = <code>\itC</code>+<code>tab</code>) is the default simulation clock. If you do one simulation at a time, you can use it for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;

julia&gt; 𝐶  # default clock
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Idle(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L9-L27">source</a></section><p>You can create a clock with parallel active clocks on all available threads or fork existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a>s and diagnose them.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.PClock" href="#DiscreteEvents.PClock"><code>DiscreteEvents.PClock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">PClock(Δt::T=0.01; t0::U=0.0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Setup a clock with parallel clocks on all available threads.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::T=0.01</code>: time increment &gt; 0. If given Δt ≤ 0, it gets set to 0.01.</li><li><code>t0::U=0.0</code>: start time for simulation,</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit for explicitl unit setting.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Processes on multiple threads are possible in Julia ≥ 1.3 and with <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS &gt; 1</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L176-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.fork!" href="#DiscreteEvents.fork!"><code>DiscreteEvents.fork!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fork!(master::Clock)</code></pre><p>Establish copies of a master clock (thread 1) on all parallel threads.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L117-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.pclock" href="#DiscreteEvents.pclock"><code>DiscreteEvents.pclock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pclock(clk::Clock, id::Int ) :: C where {C&lt;:AbstractClock}
pclock(ac::ActiveClock, id::Int ) :: C where {C&lt;:AbstractClock}</code></pre><p>Get a parallel clock to a given clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: a master clock or</li><li><code>ac::ActiveClock</code>: an active clock,</li><li><code>id::Int=threadid()</code>: thread id, defaults to the caller&#39;s current thread.</li></ul><p><strong>Returns</strong></p><ul><li>the master <code>Clock</code> if id==0,</li><li>a parallel <code>ActiveClock</code> else</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L201-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.collapse!" href="#DiscreteEvents.collapse!"><code>DiscreteEvents.collapse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collapse!(master::Clock)</code></pre><p>Transfer the schedules of the parallel clocks to master and them stop them.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If there are processes on other threads registered to parallel clocks, make sure that they aren&#39;t needed anymore before calling <code>collapse</code>. They are not transferred to and cannot be controlled by master.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L145-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.diagnose" href="#DiscreteEvents.diagnose"><code>DiscreteEvents.diagnose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diagnose(master::Clock, id::Int)</code></pre><p>Return the stacktrace from parallel clock id.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L236-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.createRTClock" href="#DiscreteEvents.createRTClock"><code>DiscreteEvents.createRTClock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">createRTClock(T::Float64, id::Int, thrd::Int=nthreads(); ch_size::Int=256)</code></pre><p>Create, start and return a real time Clock.</p><p>The clock takes the current system time and starts to count in seconds with the given period <code>T</code>. Events or sampling functions can then be scheduled to it.</p><p><strong>Arguments</strong></p><ul><li><code>T::Float64</code>:           period (clock resolution) in seconds, T ≥ 0.001</li><li><code>id::Int</code>:              clock identification number other than 0:(nthreads()-1)</li><li><code>thrd::Int=nthreads()</code>: thread, the clock task should run in</li><li><code>ch_size::Int=256</code>:     clock communication channel size</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/timer.jl#L82-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.stopRTClock" href="#DiscreteEvents.stopRTClock"><code>DiscreteEvents.stopRTClock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stopRTClock(rtc::RTClock)</code></pre><p>Stop a real time clock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/timer.jl#L110-L114">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Julia functions and expressions can be scheduled for execution</p><ol><li>at given clock times and</li><li>under specified conditions.</li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Action" href="#DiscreteEvents.Action"><code>DiscreteEvents.Action</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">Action</code></pre><p>An action is either  a <code>Function</code> or an <code>Expr</code> or a <code>Tuple</code> of them. It can be scheduled in an event for later execution.</p><div class="admonition warning"><div class="admonition-title">Evaluating expressions is slow</div><div class="admonition-text"><p>Expr should be avoided in time critical parts of applications. You will get a one time warning if you use them. They can be replaced easily by <code>fun</code>s or function closures. They are evaluated at global scope in Module <code>Main</code> only. Other modules using <code>DiscreteEvents.jl</code> cannot use Expr in events and have to use functions.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/types.jl#L33-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Timing" href="#DiscreteEvents.Timing"><code>DiscreteEvents.Timing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time,</li><li><code>after</code>: schedule an event a given time after current time,</li><li><code>every</code>: schedule an event every given time from now on,</li><li><code>before</code>: a timed condition is true before a given time,</li><li><code>until</code>: delay until t.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/96786e22ccabfdafd073122abb1fb69cea921e17/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.fun" href="#DiscreteEvents.fun"><code>DiscreteEvents.fun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fun(f::Function, args...; kwargs...)</code></pre><p>Save a function <code>f</code> and its arguments in a closure for later execution.</p><p><strong>Arguments</strong></p><p>The arguments <code>args...</code> and keyword arguments <code>kwargs...</code> to fun are passed to <code>f</code> at execution but may change their values between beeing captured in <code>fun</code> and <code>f</code>s later execution. If <code>f</code> needs their current values at execution time there are two possibilities:</p><ol><li><code>fun</code> can take <code>fun</code>s, function closures, symbols or expressions at the place of values  or variable arguments. They are evaluated at event time just before being passed to f.  There is one exception: if <code>f</code> is an <code>event!</code>, its arguments are passed on unevaluated.</li><li>A mutable type argument (Array, struct ...) is always current. You can  also change its content from within a function.</li></ol><div class="admonition warning"><div class="admonition-title">Evaluating symbols and expressions is slow</div><div class="admonition-text"><p>Symbols and Expr should be avoided in time critical parts of applications. You will get a one time warning if you use that feature. They can be replaced easily by <code>fun</code>s or function closures. They are evaluated at global scope in Module <code>Main</code> only. Other modules using <code>DiscreteEvents.jl</code> cannot use this feature and have to use functions.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; g(x; y=1) = x+y
g (generic function with 1 method)

julia&gt; x = 1
1

julia&gt; gg = fun(g, :x, y=2);   # we pass x as a symbol to fun

julia&gt; x += 1   # a becomes 2
2

julia&gt; gg()     # at execution g gets a current x and gives a warning
┌ Warning: Evaluating expressions is slow, use functions instead
└ @ DiscreteEvents ~/.julia/dev/DiscreteEvents/src/fclosure.jl:37
4

julia&gt; hh = fun(g, fun(()-&gt;x), y=3);   # reference x with an anonymous fun

julia&gt; x += 1   # x becomes 3
3

julia&gt; hh()     # at execution g gets again a current x
6

julia&gt; ii = fun(g, ()-&gt;x, y=4);  # reference x with an anonymous function

julia&gt; x += 1   # x becomes 4
4

julia&gt; ii()     # ok, g gets an updated x
8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/fclosure.jl#L53-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.event!" href="#DiscreteEvents.event!"><code>DiscreteEvents.event!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">event!([clk], ex, t; &lt;keyword arguments&gt;)
event!([clk], ex, T, t; &lt;keyword arguments&gt;)</code></pre><p>Schedule an event for a given simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>clk&lt;:AbstractClock</code>: clock, it not supplied, the event is scheduled to 𝐶,</li><li><code>ex&lt;:Action</code>: an expression or function or a tuple of them,</li><li><code>T::Timing</code>: a timing, one of <code>at</code>, <code>after</code> or <code>every</code>,</li><li><code>t&lt;:Number</code>: simulation time, if t &lt; clk.time set t = clk.time,</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>cycle&lt;:Number=0.0</code>: repeat cycle time for an event,</li><li><code>cid::Int=clk.id</code>: if cid ≠ clk.id, assign the event to the parallel clock   with id == cid. This overrides <code>spawn</code>,</li><li><code>spawn::Bool=false</code>: if true, spawn the event at other available threads,</li><li><code>sync::Bool=false</code>: if true, force a synchronization of all parallel clocks   before executing the event.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)

julia&gt; event!(𝐶, fun(myfunc, 1, 2), 1) # a 1st event to 1

julia&gt; event!(𝐶, fun(myfunc, 2, 3), 1) #  a 2nd event to the same time

julia&gt; event!(𝐶, fun(myfunc, 3, 4), 1s)
Warning: clock has no time unit, ignoring units

julia&gt; setUnit!(𝐶, s)
0.0 s

julia&gt; event!(𝐶, fun(myfunc, 4, 5), 1minute)

julia&gt; event!(fun(myfunc, 5, 6), after, 1hr)
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/schedule.jl#L9-L54">source</a><div><div><pre><code class="language-none">event!([clk], ex, cond; &lt;keyword arguments&gt;)</code></pre><p>Schedule ex as a conditional event, conditions cond get evaluated at each clock tick.</p><p><strong>Arguments</strong></p><ul><li><code>clk&lt;:AbstractClock</code>: if no clock is supplied, the event is scheduled to 𝐶,</li><li><code>ex&lt;:Action</code>: an expression or function or a tuple of them,</li><li><code>cond&lt;:Action</code>: a condition is true if all functions or expressions therein return true,</li><li><code>cid::Int=clk.id</code>: assign the event to the parallel clock cid. This overrides <code>spawn</code>,</li><li><code>spawn::Bool=false</code>: if true, spawn the event at other available threads.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; c = Clock()   # create a new clock
Clock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; event!(c, fun((x)-&gt;println(tau(x), &quot;: now I&#39;m triggered&quot;), c), fun(&gt;=, fun(tau, c), 5))

julia&gt; run!(c, 10)   # sampling is not exact, so it takes 502 sample steps to fire the event
5.009999999999938: now I&#39;m triggered
&quot;run! finished with 0 clock events, 502 sample steps, simulation time: 10.0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/schedule.jl#L81-L107">source</a></section><p>Functions and expressions can be given to events on their own or in tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(fun(f, 1, 2, 3, diff=pi), every, 1)  # one fun
    event!((:(i += 1), fun(g, j)), (()-&gt;tau() ≥ 50, fun(isready, input), :(a ≤ 10))) # two funs under three conditions
end</code></pre><p>Events are called or evaluated at a their scheduled times or by sampling when their preconditions become true.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>For conditions you should prefer inequalities like &lt;, ≤, ≥, &gt; to equality == in order to make sure that a condition can be detected, e.g. <code>tau() ≥ 100</code> is preferable to <code>tau() == 100</code>.</p></div></div><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Δt. The default clock sample rate Δt is 0.01 time units.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.sample_time!" href="#DiscreteEvents.sample_time!"><code>DiscreteEvents.sample_time!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!([clk::Clock], Δt::N) where {N&lt;:Number}</code></pre><p>Set the clock&#39;s sample rate starting from now (<code>tau(clk)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not supplied, set the sample rate on 𝐶,</li><li><code>Δt::N</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L249-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.periodic!" href="#DiscreteEvents.periodic!"><code>DiscreteEvents.periodic!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">periodic!([clk], ex, Δt; spawn)</code></pre><p>Register a function or expression for periodic execution at the clock`s sample rate.</p><p><strong>Arguments</strong></p><ul><li><code>clk&lt;:AbstractClock</code>: if not supplied, it registers on 𝐶,</li><li><code>ex&lt;:Action</code>: an expression or function or a tuple of them,</li><li><code>Δt&lt;:Number=clk.Δt</code>: set the clock&#39;s sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,</li><li><code>spawn::Bool=false</code>: if true, spawn the periodic event to other available threads.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/schedule.jl#L122-L133">source</a></section><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can run as processes (asynchronous tasks) registered to a clock.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Prc" href="#DiscreteEvents.Prc"><code>DiscreteEvents.Prc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Prc(id, f, arg...; kw...)</code></pre><p>Prepare a function to run as a process (asynchronous task) in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>id</code>: some unique identification for registration,</li><li><code>f::Function</code>: a function <code>f(clk, arg...; kw...)</code>, must take <code>clk</code> (a <a href="#DiscreteEvents.Clock"><code>Clock</code></a>)   as its first argument,</li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><p><strong>Fields</strong></p><ul><li><code>task::Union{Task,Nothing}</code>: a task structure,</li><li><code>clk::Union{AbstractClock,Nothing}</code>: clock where the process is registered,</li><li><code>state::ClockState</code>: process state,</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function started as a Prc runs in a loop. It has to give back control by e.g. doing a <code>take!(input)</code> or by calling <a href="#DiscreteEvents.delay!"><code>delay!</code></a> or <a href="#DiscreteEvents.wait!"><code>wait!</code></a>, which will <code>yield</code> it. Otherwise it will starve everything else!</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/types.jl#L109-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.process!" href="#DiscreteEvents.process!"><code>DiscreteEvents.process!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!([clk], prc, cycles; spawn)</code></pre><p>Register a <a href="#DiscreteEvents.Prc"><code>Prc</code></a> to a clock, start it as an asynchronous process and return the <code>id</code> it was registered with. It can then be found under <code>clk.processes[id]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c&lt;:AbstractClock</code>: if not provided, the process runs under <code>𝐶</code>,</li><li><code>prc::Prc</code>: it contains a function and its arguments,</li><li><code>cycles&lt;:Number=Inf</code>: number of cycles the process should run,</li><li><code>spawn::Bool=false</code>: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>spawn</code>ing a process is possible only with parallel clocks setup with <a href="#DiscreteEvents.PClock"><code>PClock</code></a> or <a href="#DiscreteEvents.fork!"><code>fork!</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L86-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.interrupt!" href="#DiscreteEvents.interrupt!"><code>DiscreteEvents.interrupt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interrupt!(p::Prc, ev::ClockEvent, value=nothing)</code></pre><p>Interrupt a <code>Prc</code> by throwing a <code>ClockException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L159-L163">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-…-1" href="#Delay-and-wait-…-1">Delay and wait …</a></h3><p>Processes then can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> … on their channels. They are then suspended until a given time or until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.delay!" href="#DiscreteEvents.delay!"><code>DiscreteEvents.delay!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!(clk, Δt)
delay!(clk, T, t)</code></pre><p>Delay (suspend) a process for a time interval <code>Δt</code> on the clock <code>clk</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Δt&lt;:Number</code>: time interval,</li><li><code>T::Timing</code>: only <code>until</code> is accepted,</li><li><code>t&lt;:Number</code>: delay until time t if t &gt; clk.time, else give a warning.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L113-L124">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.wait!" href="#DiscreteEvents.wait!"><code>DiscreteEvents.wait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!(clk, cond)</code></pre><p>Delay (suspend) a process on a clock clk until a condition has become true.</p><p><strong>Arguments</strong></p><ul><li><code>cond&lt;:Action</code>: a condition is is true if all expressions or functions therein return true.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L141-L148">source</a></section><h3><a class="nav-anchor" id="Now-1" href="#Now-1">Now</a></h3><p>Processes in a simulation enclose IO-operations in a <code>now!</code> call to make sure they finish before the clock proceeds.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.now!" href="#DiscreteEvents.now!"><code>DiscreteEvents.now!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">now!(clk::Clock, ex::A) where {A&lt;:Action}</code></pre><p>Tell the clock to execute an IO-operation ex and not to proceed before ex is finished.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L172-L176">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>Virtual clocks can be run, stopped or stepped through and thereby used to simulate chains of events.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.run!" href="#DiscreteEvents.run!"><code>DiscreteEvents.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(clk::Clock, duration::N) where {N&lt;:Number}</code></pre><p>Run a simulation for a given duration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L392-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.incr!" href="#DiscreteEvents.incr!"><code>DiscreteEvents.incr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(clk::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L404-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.resetClock!" href="#DiscreteEvents.resetClock!"><code>DiscreteEvents.resetClock!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetClock!(clk::Clock, Δt::T=0.01; t0::U=0; &lt;keyword arguments&gt;) where {T&lt;:Number, U&lt;:Number}</code></pre><p>Reset a clock.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>Δt::T=0.01</code>: sample rate</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Δt::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; resetClock!(c)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;

julia&gt; c
Clock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Idle(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L156-L190">source</a><div><div><pre><code class="language-none">resetClock!(rtc::RTClock)</code></pre><p>Reset a real time clock. Set its time to zero and delete all scheduled and sampling events.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/timer.jl#L14-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.stop!" href="#DiscreteEvents.stop!"><code>DiscreteEvents.stop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stop!(clk::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L411-L415">source</a><div><div><p>Stop a Prc</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/process.jl#L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.resume!" href="#DiscreteEvents.resume!"><code>DiscreteEvents.resume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(clk::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L418-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.sync!" href="#DiscreteEvents.sync!"><code>DiscreteEvents.sync!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(clk::Clock, to::Clock=𝐶)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>clk</code> accordingly. Convert or force clk.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/clock.jl#L126-L131">source</a></section><h2><a class="nav-anchor" id="Resources-1" href="#Resources-1">Resources</a></h2><p>Shared resources with limited capacity are often needed in simulations.</p><ol><li>One approach to model them is to use Julia <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.Channel"><code>Channel</code></a>s with its API. This is threadsafe and thus should be preferred for multithreading applications.</li><li>Using <code>Resource</code> is a second possibility to model shared resources. Its interface gives more flexibility and is faster in single threaded applications, but in multithreading the user must avoid race conditions by explicitly wrapping access with <code>lock -… access …- unlock</code>.</li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Resource" href="#DiscreteEvents.Resource"><code>DiscreteEvents.Resource</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Resource{T}(capacity)</code></pre><p>A Resource implements a <a href="https://juliacollections.github.io/DataStructures.jl/latest/deque/"><code>Deque</code></a> with a limited capacity. If used in multithreading applications, the user must avoid race conditions by explicitly wrapping modifying calls with <code>lock-unlock</code>.</p><p><strong>Fields</strong></p><ul><li><code>items::Deque{T}</code>: resource buffer</li><li><code>capacity::Number=Inf</code>: the capacity is limited to the given integer,</li><li><code>lock::ReentrantLock</code>: a lock for coordinating resource access by tasks.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; </code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In order to use the full interface to <code>Resource</code> you have to load <code>DataStructures</code>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L11-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.capacity" href="#DataStructures.capacity"><code>DataStructures.capacity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">capacity(r::Resource)</code></pre><p>Get the capacity of a resource</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L44-L48">source</a><div><div><pre><code class="language-none">capacity(ch::Channel)</code></pre><p>Get the capacity of a channel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L181-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.isfull" href="#DataStructures.isfull"><code>DataStructures.isfull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isfull(r::Resource)</code></pre><p>Test whether the resource is full</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L51-L55">source</a><div><div><pre><code class="language-none">isfull(ch::Channel)</code></pre><p>Test whether a channel is full.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L195-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isready" href="#Base.isready"><code>Base.isready</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isready(r::Resource)</code></pre><p>Test whether an item is available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isempty(r::Resource)</code></pre><p>Test whether the resource is empty.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L65-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">empty!(r::Resource)</code></pre><p>Reset the resource buffer (deque).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L72-L76">source</a><div><div><pre><code class="language-none">empty!(ch::Channel)</code></pre><p>Reset a channel, throw away the elements stored to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">length(r::Resource)</code></pre><p>Get the number of elements available.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L79-L83">source</a><div><div><pre><code class="language-none">length(ch::Channel)</code></pre><p>Get the number of items in a channel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L188-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">push!(r::Resource, x)</code></pre><p>Add an element to the back of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L86-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pop!(r::Resource)</code></pre><p>Remove an element from the back of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L94-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pushfirst!(r::Resource, x)</code></pre><p>Add an element to the front of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L101-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">popfirst!(r::Resource)</code></pre><p>Remove an element from the front of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L109-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">first(r::Resource)</code></pre><p>Get the element at the front of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L125-L129">source</a><div><div><pre><code class="language-none">first(ch::Channel)</code></pre><p>Get the first item in a channel without removing it. Throws an error if the channel is empty. If you want a blocking operation, use <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.fetch-Tuple{Channel}"><code>fetch</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L202-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">last(r::Resource)</code></pre><p>Get the element at the back of a resource deque.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L132-L136">source</a></section><p><code>Resource</code> provides a <code>lock-unlock</code> API for multithreading applications.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.lock" href="#Base.lock"><code>Base.lock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">lock(r::Resource)</code></pre><p>Acquire the resource lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.</p><p>Each lock must be matched by an unlock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L139-L146">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.unlock" href="#Base.unlock"><code>Base.unlock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unlock(r::Resource)</code></pre><p>Releases ownership of the resource lock.</p><p>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L149-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.islocked" href="#Base.islocked"><code>Base.islocked</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">islocked(r::Resource)</code></pre><p>Check whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L159-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.trylock" href="#Base.trylock"><code>Base.trylock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">trylock(r::Resource)</code></pre><p>Acquire the resource lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.</p><p>Each successful trylock must be matched by an unlock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/resources.jl#L167-L174">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.onthread" href="#DiscreteEvents.onthread"><code>DiscreteEvents.onthread</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">onthread(f::F, tid::Int; wait::Bool=true) where {F&lt;:Function}</code></pre><p>Execute a function f on thread tid (to speed it up).</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>:     function to execute</li><li><code>tid::Int</code>:        thread id</li><li><code>wait::Bool=true</code>: if true, it waits for function to finish</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, .Threads

julia&gt; onthread(2) do; threadid(); end
2</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/b09c41d5690fd44c74335d00ee87002ed7ab12db/src/threads.jl#L258-L275">source</a></section><footer><hr/><a class="previous" href="../intro/"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
