<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approaches ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Approaches</a><ul class="internal"><li><a class="toctext" href="#Event-based-modeling-1">Event based modeling</a></li><li><a class="toctext" href="#State-based-modeling-1">State based modeling</a></li><li><a class="toctext" href="#Activity-based-modeling-1">Activity based modeling</a></li><li><a class="toctext" href="#Process-based-modeling-1">Process based modeling</a></li><li><a class="toctext" href="#Comparison-1">Comparison</a></li><li><a class="toctext" href="#Combined-approach-1">Combined approach</a></li><li><a class="toctext" href="#Hybrid-systems-1">Hybrid systems</a></li><li><a class="toctext" href="#References,-Footnotes-1">References, Footnotes</a></li></ul></li><li><a class="toctext" href="../overview/">Overview</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubeshooting</a></li><li><a class="toctext" href="../history/">History</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Approaches</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/approach.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Approaches</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Approaches-to-modeling-and-simulation-1" href="#Approaches-to-modeling-and-simulation-1">Approaches to modeling and simulation</a></h1><p><code>Simulate.jl</code> aims to support four major approaches to modeling and simulation of <strong>discrete event systems (DES)</strong>:</p><ol><li><strong>event based</strong>: <em>events</em> occur in time and trigger actions causing further events ‚Ä¶</li><li><strong>state based</strong>: events cause transitions between  <em>states</em>. State actions cause further events ‚Ä¶</li><li><strong>activity based</strong>: <em>activities</em> occur in time and cause other activities ‚Ä¶</li><li><strong>process based</strong>: <em>processes</em> wait for and act according to events and their current state ‚Ä¶</li></ol><p>Choi and Kang <a href="#ref1">1</a> have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune <a href="#ref2">2</a> call those &quot;the event scheduling scheme&quot; and the 4th approach &quot;the process-oriented simulation scheme&quot; <a href="#ref3">3</a>. There are communities behind the various views and <code>Simulate.jl</code> wants to be useful for them all.</p><p><code>Simulate.jl</code> allows arbitrary Julia functions or expressions to be registered as &quot;events&quot; on the clock&#39;s time line and thus enables the first three approaches. Under a few conditions Julia functions can run as &quot;processes&quot; simulating entities in a DES.</p><p>Then there are <strong>continuous systems</strong>, which are usually modeled by taking an action each time step Œît. We can register expressions or functions to the clock as sampling functions, which then are executed at each clock tick or we can register them as repeating events.  </p><p>All approaches fit together: e.g. functions registered as events can communicate with other functions running as processes acting on states and triggering other events or processes to start ‚Ä¶ Functions operating continuously can modify or evaluate conditions and states or trigger events ‚Ä¶ Thus we can model and simulate <strong>hybrid systems</strong> combining continuous processes and discrete events. All this gives us an expressive framework for simulation.</p><h2><a class="nav-anchor" id="Event-based-modeling-1" href="#Event-based-modeling-1">Event based modeling</a></h2><p>A simple server <code>takes</code> something from an input, <code>processes</code> it for some time and <code>puts</code> it out to an output. Here the three actions are seen as events and described in an event graph:</p><p><img src="../images/event.png" alt="event graph"/></p><p>In our example we want to have 8 such entities in our system, 4 foos and 4 bars, which communicate with each other via two channels. Therefore we have to define a data structure for the entity:</p><pre><code class="language-julia">using Simulate, Printf, Random

mutable struct Server
  id::Int64
  name::AbstractString
  input::Channel
  output::Channel
  op     # operation to take
  token  # current token

  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)
end

function take(en::Server)
    isempty(en.input) || event!(ùê∂, SimFunction(take, en), :(!isempty(en.input)))
    en.token = take!(en.input)
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), en.name, en.id, en.token)
    proc(en)
end

proc(en) = event!(ùê∂, SimFunction(put, en), after, rand())

function put(en)
    put!(en.output, en.op(en.id, en.token))
    en.token = nothing
    take(en)
end

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8
    take(Server(i, &quot;foo&quot;, ch1, ch2, +))
    take(Server(i+1, &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt;
conditional events are not yet implemented !!</code></pre><h2><a class="nav-anchor" id="State-based-modeling-1" href="#State-based-modeling-1">State based modeling</a></h2><p>Our server has three states: <code>Idle</code>, <code>Busy</code> and <code>End</code> (where <em>End</em> does nothing). On an arrival event it resets its internal clock <span>$x=0$</span> and determines the service time <span>$t_s$</span>, moves to <em>Busy</em>, <em>works</em> on its input and puts it out when service time is over. Then it goes back to <em>Idle</em>. A state transition diagram (Mealy model) of the timed automaton would look like:</p><p><img src="../images/state.png" alt="timed automaton"/></p><p>We define states and events and implement a <code>Œ¥</code> transition function with two methods. Thereby we dispatch on states and events. Since we don&#39;t implement all combinations of states and events, we may implement a fallback transition.</p><pre><code class="language-julia">abstract type Q end  # states
struct Idle &lt;: Q end
struct Busy &lt;: Q end
abstract type Œ£ end  # events
struct Arrive &lt;: Œ£ end
struct Leave &lt;: Œ£ end

mutable struct Server
  id::Int64
  name::AbstractString
  input::Channel
  output::Channel
  op     # operation to take
  state::Q
  token  # current token

  Server(id, name, input, output, op) = new(id, name, input, output, op, Idle, nothing)
end

Œ¥(A::Server, ::Idle, ::Arrive) = (A.state=Busy(); event!(ùê∂,SimFunction(Œ¥,A,A.state,Leave()),after,rand())
Œ¥(A::Server, ::Busy, ::Leave) = put(A)
Œ¥(A::Server, q::Q, œÉ::Œ£) = println(stderr, &quot;$(A.name) $(A.id) undefined transition $q, $œÉ&quot;)

function take(A::Server)
  if isempty(A.input)
    event!(ùê∂, SimFunction(take, A), !isempty(A.input))
  else
    A.token = take!(en.input)
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), A.name, A.id, A.token)
    Œ¥(A,Idle(),Arrive())
  end
end

function put(A::Server)
  put!(A.output, A.op(A.id,A.token))
  A.state=Idle()
  take(A))
end

reset!(ùê∂)

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8
    serve(Server(i, &quot;foo&quot;, ch1, ch2, +))
    serve(Server(i+1, &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt;
conditional events are not yet implemented !!</code></pre><h2><a class="nav-anchor" id="Activity-based-modeling-1" href="#Activity-based-modeling-1">Activity based modeling</a></h2><p>Our server&#39;s activity is the processing of the token. A timed Petri net would look like:</p><p><img src="../images/activity.png" alt="timed petri net"/></p><p>The <code>arrive</code> transition puts a token in the <code>Queue</code>. If both places <code>Idle</code> and <code>Queue</code> have tokens, the server <code>take</code>s them, shifts one to <code>Busy</code> and <code>put</code>s out two after a timed transition with delay <span>$v_{put}$</span>. Then it is <code>Idle</code> again and the cycle restarts. The serve activity is described by the blue box. Following the Petri net, we should implement a state variable with states Idle and Busy, but we don&#39;t need to if we separate the activities in time.</p><pre><code class="language-julia">mutable struct Server
  id::Int64
  name::AbstractString
  input::Channel
  output::Channel
  op     # operation to take
  token  # current token

  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)
end

cond(en) = !isempty(en.input) &amp;&amp; en.state == Idle

function serve(en::Server)
    if isempty(en.input)
      event!(ùê∂, SimFunction(take, en), !isempty(en.input))
    else
      en.token = take!(en.input)
      @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), en.name, en.id, en.token)
      event!(ùê∂, (SimFunction(put!, en.output, token), SimFunction(serve, en)), after, rand())
    end
end

reset!(ùê∂)

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8
    serve(Server(i, &quot;foo&quot;, ch1, ch2, +))
    serve(Server(i+1, &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt;
conditional events are not yet implemented !!</code></pre><h2><a class="nav-anchor" id="Process-based-modeling-1" href="#Process-based-modeling-1">Process based modeling</a></h2><p>Here we combine it all in a simple process of <code>take!</code>-<code>delay!</code>-<code>put!</code> running in a loop. This is much like in the activity based scheme. But implementation is simpler because processes can wait or delay and are suspended and reactivated by Julia&#39;s scheduler according to background events. We don&#39;t need to handle events explicitly here and we don&#39;t need a server type since each process contains its own data:</p><pre><code class="language-julia">reset!(ùê∂)

function simple(input::Channel, output::Channel, name, id, op)
    token = take!(input)         # take something, eventually wait for it
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), name, id, token)
    d = delay!(rand())           # wait for a given time
    put!(output, op(token, id))  # put something else out, eventually wait
end

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8    # create and register 8 SimProcesses
    process!(ùê∂, SimProcess(i, simple, ch1, ch2, &quot;foo&quot;, i, +))
    process!(ùê∂, SimProcess(i+1, simple, ch2, ch1, &quot;bar&quot;, i+1, *))
end

start!(ùê∂) # start all registered processes
put!(ch1, 1) # put first token into channel 1

sleep(0.1) # we give the processes some time to startup

run!(ùê∂, 10)</code></pre><p>and runs like:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels.jl&quot;)
 0.00: foo 7 took token 1
 0.25: bar 4 took token 8
 0.29: foo 3 took token 32
 0.55: bar 2 took token 35
 1.21: foo 5 took token 70
 1.33: bar 8 took token 75
 1.47: foo 1 took token 600
 1.57: bar 6 took token 601
 2.07: foo 7 took token 3606
 3.00: bar 4 took token 3613
 3.68: foo 3 took token 14452
 4.33: bar 2 took token 14455
 5.22: foo 5 took token 28910
 6.10: bar 8 took token 28915
 6.50: foo 1 took token 231320
 6.57: bar 6 took token 231321
 7.13: foo 7 took token 1387926
 8.05: bar 4 took token 1387933
 8.90: foo 3 took token 5551732
 9.10: bar 2 took token 5551735
 9.71: foo 5 took token 11103470
 9.97: bar 8 took token 11103475
10.09: foo 1 took token 88827800
&quot;run! finished with 22 events, simulation time: 10.0&quot;</code></pre><h2><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h2><p>All four approaches can be expressed in <code>Simulate.jl</code>. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured, which comes in handy for more complicated examples. After all parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.</p><h2><a class="nav-anchor" id="Combined-approach-1" href="#Combined-approach-1">Combined approach</a></h2><p>(empty)</p><h2><a class="nav-anchor" id="Hybrid-systems-1" href="#Hybrid-systems-1">Hybrid systems</a></h2><p>(empty)</p><h2><a class="nav-anchor" id="References,-Footnotes-1" href="#References,-Footnotes-1">References, Footnotes</a></h2><ul><li>&lt;a name=&quot;ref1&quot;&gt;[1]&lt;/a&gt;:  <a href="https://books.google.com/books?id=0QpwAAAAQBAJ">Choi and Kang: <em>Modeling and Simulation of Discrete-Event Systems</em>, Wiley, 2013</a></li><li>&lt;a name=&quot;ref2&quot;&gt;[2]&lt;/a&gt;:  <a href="https://books.google.com/books?id=AxguNHDtO7MC">Cassandras and Lafortune: <em>Introduction to Discrete Event Systems</em>, Springer, 2008, Ch. 10</a></li><li>&lt;a name=&quot;ref3&quot;&gt;[3]&lt;/a&gt;: to be fair, the 4th approach is called by Choi and Kang &quot;parallel simulation&quot;.</li><li>&lt;a name=&quot;ref4&quot;&gt;[4]&lt;/a&gt;: since the two separate take and put functions are initiated by setting the state to Idle or Busy, we don&#39;t in this case really need the state variable.</li></ul><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../overview/"><span class="direction">Next</span><span class="title">Overview</span></a></footer></article></body></html>
