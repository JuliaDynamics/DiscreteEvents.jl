<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling approaches ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../overview/">Overview</a></li><li><a class="toctext" href="../usage/">Usage</a></li><li class="current"><a class="toctext" href>Modeling approaches</a><ul class="internal"><li><a class="toctext" href="#Event-based-modeling-1">Event based modeling</a></li><li><a class="toctext" href="#State-based-modeling-1">State based modeling</a></li><li><a class="toctext" href="#Activity-based-modeling-1">Activity based modeling</a></li><li><a class="toctext" href="#Process-based-modeling-1">Process based modeling</a></li><li><a class="toctext" href="#Comparison-1">Comparison</a></li><li><a class="toctext" href="#Combined-approach-1">Combined approach</a></li><li><a class="toctext" href="#Theories-1">Theories</a></li></ul></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubeshooting</a></li><li><a class="toctext" href="../history/">History</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Modeling approaches</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/approach.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modeling approaches</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Approaches-to-modeling-and-simulation-1" href="#Approaches-to-modeling-and-simulation-1">Approaches to modeling and simulation</a></h1><p><code>Simulate.jl</code> supports different approaches to modeling and simulation of <strong>discrete event systems (DES)</strong>. It provides three major schemes:</p><ul><li>an event-scheduling scheme,</li><li>a process-oriented scheme and</li><li>continuous sampling.</li></ul><p>With them different modeling strategies can be applied. We look at how a simple problem can be expressed differently through various modeling approaches:</p><p><strong>Simple problem:</strong>&lt;br&gt; A server <strong>takes</strong> something from an input, <strong>processes</strong> it for some time and <strong>puts</strong> it out to an output. We have 8 servers in our system, 4 foos and 4 bars, which communicate with each other via two channels.</p><h2><a class="nav-anchor" id="Event-based-modeling-1" href="#Event-based-modeling-1">Event based modeling</a></h2><p>In this view <em>events</em> occur in time and trigger further events. Here the three server actions are seen as events and can be described in an event graph:</p><p><img src="../images/event.png" alt="event graph"/></p><p>We define a data structure for the server, provide functions for the three actions, create channels and servers and start:</p><pre><code class="language-julia">using Simulate, Printf, Random

mutable struct Server
  id::Int64
  name::AbstractString
  input::Channel
  output::Channel
  op     # operation to take
  token  # current token

  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)
end

function take(S::Server)
    if isready(S.input)
        S.token = take!(S.input)
        @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), S.name, S.id, S.token)
        event!(SF(put, S), after, rand())         # call put after some time
    else
        event!(SF(take, S), SF(isready, S.input)) # call again if input is ready
    end
end

function put(S::Server)
    put!(S.output, S.op(S.id, S.token))
    S.token = nothing
    take(S)
end

reset!(ùê∂)
Random.seed!(123)

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

s = shuffle(1:8)
for i in 1:2:8
    take(Server(s[i], &quot;foo&quot;, ch1, ch2, +))
    take(Server(s[i+1], &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels1.jl&quot;)
 0.01: foo 4 took token 1
 0.12: bar 6 took token 5
 0.29: foo 1 took token 30
 0.77: bar 8 took token 31
 1.64: foo 2 took token 248
 2.26: bar 3 took token 250
 2.55: foo 7 took token 750
 3.02: bar 5 took token 757
 3.30: foo 4 took token 3785
 3.75: bar 6 took token 3789
 4.34: foo 1 took token 22734
 4.60: bar 8 took token 22735
 5.31: foo 2 took token 181880
 5.61: bar 3 took token 181882
 5.90: foo 7 took token 545646
 6.70: bar 5 took token 545653
 6.91: foo 4 took token 2728265
 7.83: bar 6 took token 2728269
 8.45: foo 1 took token 16369614
 9.26: bar 8 took token 16369615
 9.82: foo 2 took token 130956920
&quot;run! finished with 20 clock events, simulation time: 10.0&quot;</code></pre><h2><a class="nav-anchor" id="State-based-modeling-1" href="#State-based-modeling-1">State based modeling</a></h2><p>Here our server has three states: <strong>Idle</strong>, <strong>Busy</strong> and <strong>End</strong> (where <em>End</em> does nothing). On an arrival event it resets its internal clock <span>$x=0$</span> and determines the service time <span>$t_s$</span>, moves to <em>Busy</em>, <em>works</em> on its input and puts it out when service time is over. Then it goes back to <em>Idle</em>. A state transition diagram (Mealy model) of the timed automaton would look like:</p><p><img src="../images/state.png" alt="timed automaton"/></p><p>Again we have a data structure for the server (containing a state). We define states and events and implement a <code>Œ¥</code> transition function with two methods. Thereby we dispatch on states and events. Since we don&#39;t implement all combinations of states and events, we may implement a fallback transition.</p><pre><code class="language-julia">using Simulate, Printf, Random

abstract type Q end  # states
struct Idle &lt;: Q end
struct Busy &lt;: Q end
abstract type Œ£ end  # events
struct Arrive &lt;: Œ£ end
struct Leave &lt;: Œ£ end

mutable struct Server
    id::Int64
    name::AbstractString
    input::Channel
    output::Channel
    op     # operation to take
    state::Q
    token  # current token

    Server(id, name, input, output, op) = new(id, name, input, output, op, Idle(), nothing)
end

arrive(A) = event!(SF(Œ¥, A, A.state, Arrive()), SF(isready, A.input))

function Œ¥(A::Server, ::Idle, ::Arrive)
    A.token = take!(A.input)
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), A.name, A.id, A.token)
    A.state=Busy()
    event!(SF(Œ¥, A, A.state, Leave()), after, rand())
end

function Œ¥(A::Server, ::Busy, ::Leave)
    put!(A.output, A.op(A.id,A.token))
    A.state=Idle()
    arrive(A)
end

Œ¥(A::Server, q::Q, œÉ::Œ£) =               # fallback transition
        println(stderr, &quot;$(A.name) $(A.id) undefined transition $q, $œÉ&quot;)

reset!(ùê∂)
Random.seed!(123)

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

s = shuffle(1:8)
for i in 1:2:8
    arrive(Server(s[i], &quot;foo&quot;, ch1, ch2, +))
    arrive(Server(s[i+1], &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels2.jl&quot;)
 0.01: foo 4 took token 1
 0.12: bar 6 took token 5
 0.29: foo 1 took token 30
 0.77: bar 8 took token 31
 1.64: foo 2 took token 248
 2.26: bar 3 took token 250
 2.55: foo 7 took token 750
 3.02: bar 5 took token 757
 3.30: foo 4 took token 3785
 3.75: bar 6 took token 3789
 4.34: foo 1 took token 22734
 4.60: bar 8 took token 22735
 5.31: foo 2 took token 181880
 5.61: bar 3 took token 181882
 5.90: foo 7 took token 545646
 6.70: bar 5 took token 545653
 6.91: foo 4 took token 2728265
 7.83: bar 6 took token 2728269
 8.45: foo 1 took token 16369614
 9.26: bar 8 took token 16369615
 9.82: foo 2 took token 130956920
&quot;run! finished with 20 clock events, simulation time: 10.0&quot;</code></pre><h2><a class="nav-anchor" id="Activity-based-modeling-1" href="#Activity-based-modeling-1">Activity based modeling</a></h2><p>Our server&#39;s <em>activity</em> is the processing of the token. A timed Petri net would look like:</p><p><img src="../images/activity.png" alt="timed petri net"/></p><p>The <strong>arrive</strong> transition puts a token in the <strong>Queue</strong>. If both places <strong>Idle</strong> and <strong>Queue</strong> have tokens, the server <strong>takes</strong> them, shifts one to <strong>Busy</strong> and <strong>puts</strong> out two after a timed transition with delay <span>$v_{put}$</span>. Then it is <em>Idle</em> again and the cycle restarts.</p><p>The server&#39;s activity is described by the blue box. Following the Petri net, we should implement a state variable with states Idle and Busy, but we don&#39;t need to if we separate the activities in time. We need a data structure for the server and define a function for the activity:</p><pre><code class="language-julia">using Simulate, Printf, Random

mutable struct Server
  id::Int64
  name::AbstractString
  input::Channel
  output::Channel
  op     # operation
  token  # current token

  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)
end

arrive(S::Server) = event!(SF(serve, S), SF(isready, S.input))

function serve(S::Server)
    S.token = take!(S.input)
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), S.name, S.id, S.token)
    event!((SF(put!, S.output, S.op(S.id, S.token)), SF(arrive, S)), after, rand())
end

reset!(ùê∂)
Random.seed!(123)

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

s = shuffle(1:8)
for i in 1:2:8
    arrive(Server(s[i], &quot;foo&quot;, ch1, ch2, +))
    arrive(Server(s[i+1], &quot;bar&quot;, ch2, ch1, *))
end

put!(ch1, 1) # put first token into channel 1

run!(ùê∂, 10)</code></pre><p>When running, this gives us as output:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels3.jl&quot;)
 0.01: foo 4 took token 1
 0.12: bar 6 took token 5
 0.29: foo 1 took token 30
 0.77: bar 8 took token 31
 1.64: foo 2 took token 248
 2.26: bar 3 took token 250
 2.55: foo 7 took token 750
 3.02: bar 5 took token 757
 3.30: foo 4 took token 3785
 3.75: bar 6 took token 3789
 4.34: foo 1 took token 22734
 4.60: bar 8 took token 22735
 5.31: foo 2 took token 181880
 5.61: bar 3 took token 181882
 5.90: foo 7 took token 545646
 6.70: bar 5 took token 545653
 6.91: foo 4 took token 2728265
 7.83: bar 6 took token 2728269
 8.45: foo 1 took token 16369614
 9.26: bar 8 took token 16369615
 9.82: foo 2 took token 130956920
&quot;run! finished with 20 clock events, simulation time: 10.0&quot;</code></pre><h2><a class="nav-anchor" id="Process-based-modeling-1" href="#Process-based-modeling-1">Process based modeling</a></h2><p>Here we combine it all in a simple function of <strong>take!</strong>-<strong>delay!</strong>-<strong>put!</strong> like in the activity based example, but running in a loop of a process. Processes can wait or delay and are suspended and reactivated by Julia&#39;s scheduler according to background events. There is no need to handle events explicitly and no need for a server type since a process keeps its own data:</p><pre><code class="language-julia">reset!(ùê∂)

function simple(input::Channel, output::Channel, name, id, op)
    token = take!(input)         # take something, eventually wait for it
    @printf(&quot;%5.2f: %s %d took token %d\n&quot;, œÑ(), name, id, token)
    d = delay!(rand())           # wait for a given time
    put!(output, op(token, id))  # put something else out, eventually wait
end

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8    # create and register 8 SimProcesses
    process!(ùê∂, SimProcess(i, simple, ch1, ch2, &quot;foo&quot;, i, +))
    process!(ùê∂, SimProcess(i+1, simple, ch2, ch1, &quot;bar&quot;, i+1, *))
end

start!(ùê∂) # start all registered processes
put!(ch1, 1) # put first token into channel 1

sleep(0.1) # we give the processes some time to startup

run!(ùê∂, 10)</code></pre><p>and runs like:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels4.jl&quot;)
 0.00: foo 7 took token 1
 0.77: bar 4 took token 8
 1.71: foo 3 took token 32
 2.38: bar 2 took token 35
 2.78: foo 5 took token 70
 3.09: bar 8 took token 75
 3.75: foo 1 took token 600
 4.34: bar 6 took token 601
 4.39: foo 7 took token 3606
 4.66: bar 4 took token 3613
 4.77: foo 3 took token 14452
 4.93: bar 2 took token 14455
 5.41: foo 5 took token 28910
 6.27: bar 8 took token 28915
 6.89: foo 1 took token 231320
 7.18: bar 6 took token 231321
 7.64: foo 7 took token 1387926
 7.91: bar 4 took token 1387933
 8.36: foo 3 took token 5551732
 8.94: bar 2 took token 5551735
 9.20: foo 5 took token 11103470
 9.91: bar 8 took token 11103475
&quot;run! finished with 21 clock events, simulation time: 10.0&quot;</code></pre><h2><a class="nav-anchor" id="Comparison-1" href="#Comparison-1">Comparison</a></h2><p>The output of the last example is different from the first three approaches because we did not need to shuffle and the shuffling of the processes is done by the scheduler. So if the output depends very much on the sequence of events and you need to have reproducible results, explicitly controlling for the events like in the first three examples is preferable. If you are more interested in statistical evaluation - which is often the case -, the 4th approach is also appropriate.</p><p>All four approaches can be expressed in <code>Simulate.jl</code>. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured and controllable , which comes in handy for more complicated examples. After all, parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.</p><h2><a class="nav-anchor" id="Combined-approach-1" href="#Combined-approach-1">Combined approach</a></h2><p>Physical systems can be modeled as <strong>continuous systems</strong> (nature does not jump), <strong>discrete systems</strong> (nature jumps here!) or <strong>hybrid systems</strong> (nature jumps sometimes).</p><p>While continuous systems are the domain of differential equations, discrete and hybrid systems may be modeled easier with <code>Simulate.jl</code> by combining the <em>event-scheduling</em>, the <em>process-based</em> and the <em>continuous-sampling</em> schemes.</p><h3><a class="nav-anchor" id="A-hybrid-system-1" href="#A-hybrid-system-1">A hybrid system</a></h3><p>(empty)</p><h2><a class="nav-anchor" id="Theories-1" href="#Theories-1">Theories</a></h2><p>There are some theories about the different approaches (1) event based, (2) state based, (3) activity based and (4) process based. Choi and Kang <a href="#footnote-1">[1]</a> have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune <a href="#footnote-2">[2]</a> call those &quot;the event scheduling scheme&quot; and the 4th approach &quot;the process-oriented simulation scheme&quot; <a href="#footnote-3">[3]</a>. There are communities behind the various views and <code>Simulate.jl</code> wants to be useful for them all.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p><a href="https://books.google.com/books?id=0QpwAAAAQBAJ">Choi and Kang: <em>Modeling and Simulation of Discrete-Event Systems</em>, Wiley, 2013</a></p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p><a href="https://books.google.com/books?id=AxguNHDtO7MC">Cassandras and Lafortune: <em>Introduction to Discrete Event Systems</em>, Springer, 2008, Ch. 10</a></p></div><div class="footnote" id="footnote-3"><a href="#footnote-3"><strong>[3]</strong></a><p>to be fair, the 4th approach is called by Choi and Kang &quot;parallel simulation&quot;.</p></div><footer><hr/><a class="previous" href="../usage/"><span class="direction">Previous</span><span class="title">Usage</span></a><a class="next" href="../examples/examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
