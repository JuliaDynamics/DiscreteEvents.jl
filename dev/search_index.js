var documenterSearchIndex = {"docs":
[{"location":"manual/internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"CurrentModule = Simulate","category":"page"},{"location":"manual/internals/#Clocks-1","page":"Internals","title":"Clocks","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"AbstractClock","category":"page"},{"location":"manual/internals/#Simulate.AbstractClock","page":"Internals","title":"Simulate.AbstractClock","text":"supertype for clocks in Simulate.jl\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"Simulate.jl contains several clock types: Clock, ActiveClock and RTClock. They are implemented as state machines. Their implementation are internal and not exported.","category":"page"},{"location":"manual/internals/#Clock-states-1","page":"Internals","title":"Clock states","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"Defined clock states.","category":"page"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"ClockState\nUndefined\nIdle\nEmpty\nBusy\nHalted","category":"page"},{"location":"manual/internals/#Simulate.ClockState","page":"Internals","title":"Simulate.ClockState","text":"supertype for clock states\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Undefined","page":"Internals","title":"Simulate.Undefined","text":"a state machine is undefined (after creation)\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Idle","page":"Internals","title":"Simulate.Idle","text":"a state machine is idle\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Empty","page":"Internals","title":"Simulate.Empty","text":"a state machine is empty\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Busy","page":"Internals","title":"Simulate.Busy","text":"a state machine is busy\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Halted","page":"Internals","title":"Simulate.Halted","text":"a state machine is halted\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Clock-events-1","page":"Internals","title":"Clock events","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"Defined clock events.","category":"page"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"ClockEvent\nInit\nSetup\nStep\nRun\nReset\nQuery\nDiag\nResponse\nRegister\nForward\nDone\nSync\nStart\nStop\nResume\nClear","category":"page"},{"location":"manual/internals/#Simulate.ClockEvent","page":"Internals","title":"Simulate.ClockEvent","text":"supertype for clock events\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Init","page":"Internals","title":"Simulate.Init","text":"Init(info): Init event with some info.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Setup","page":"Internals","title":"Simulate.Setup","text":"Setup(vars::Array{Symbol,1}, scope::Module): setup a logger with some info.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Step","page":"Internals","title":"Simulate.Step","text":"Step(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Run","page":"Internals","title":"Simulate.Run","text":"Run(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Reset","page":"Internals","title":"Simulate.Reset","text":"Reset(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Query","page":"Internals","title":"Simulate.Query","text":"Query(): command, causes an active clock to send its clock data.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Diag","page":"Internals","title":"Simulate.Diag","text":"Diag(): command, causes an active clock to send the last stacktrace.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Response","page":"Internals","title":"Simulate.Response","text":"Response(): response from an active clock\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Register","page":"Internals","title":"Simulate.Register","text":"Register(): command from master to an active clock.\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Forward","page":"Internals","title":"Simulate.Forward","text":"Forward(): forward an event or sample from an active clock to master\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Done","page":"Internals","title":"Simulate.Done","text":"Done(): event from an active clock containing the elapsed time in ns\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Sync","page":"Internals","title":"Simulate.Sync","text":"Sync(): event for syncing of parallel clocks\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Start","page":"Internals","title":"Simulate.Start","text":"Start(): event used for transferring start data to an active clock\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Stop","page":"Internals","title":"Simulate.Stop","text":"Stop(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Resume","page":"Internals","title":"Simulate.Resume","text":"Resume(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Simulate.Clear","page":"Internals","title":"Simulate.Clear","text":"Clear(): command\n\n\n\n\n\n","category":"type"},{"location":"manual/internals/#Multithreading-1","page":"Internals","title":"Multithreading","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"Internal functions used for multithreading.","category":"page"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"start_threads\nactiveClock\nspawnid","category":"page"},{"location":"manual/internals/#Simulate.start_threads","page":"Internals","title":"Simulate.start_threads","text":"start_threads(f::Function, mul::Int=3)\n\nStart a task on each available thread (other than 1).\n\nArguments\n\nf::Function: function to start, has to take two channels as arguments,\nmul::Int=3: startup multiplication factor,\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.activeClock","page":"Internals","title":"Simulate.activeClock","text":"activeClock(ch::Channel)\n\nOperate an active clock on a given channel. This is its event loop.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.spawnid","page":"Internals","title":"Simulate.spawnid","text":"spawnid(clk::Clock) :: Int\n\nReturn a random number out of the thread ids of all available parallel clocks. This is used for spawning tasks or events to them.\n\nnote: Note\nThis function may be used for workload balancing between threads in the future.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Transition-functions-1","page":"Internals","title":"Transition functions","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"The internal clock transition function has several methods for different combinations of clock types, states and events:","category":"page"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"step!","category":"page"},{"location":"manual/internals/#Simulate.step!","page":"Internals","title":"Simulate.step!","text":"step!(A::AbstractClock, q::ClockState, σ::ClockEvent)\n\nDefault transition for clock state machines.\n\nThis is called if no otherwise defined transition occurs.\n\nArguments\n\nA::AbstractClock: state machine for which a transition is called\nq::ClockState:  state of the state machine\nσ::ClockEvent:  event, triggering the transition\n\n\n\n\n\nstep!(clk::Clock, ::Undefined, ::Init)\n\ninitialize a clock.\n\n\n\n\n\nstep!(clk::Clock, ::Undefined, σ::Union{Step,Run})\n\nif uninitialized, initialize and then Step or Run.\n\n\n\n\n\nstep!(c::Clock, ::Union{Idle,Busy,Halted}, ::Step)\n\nstep forward to next tick or scheduled event.\n\nAt a tick evaluate 1) all sampling functions or expressions, 2) all conditional events, then 3) if an event is encountered, trigger the event.\n\nThe internal clock times c.tev and c.tn are always at least c.time.\n\n\n\n\n\nstep!(clk::Clock, ::Idle, σ::Run)\n\nRun a simulation for a given duration.\n\nThe duration is given with Run(duration). Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\nstep!(clk::Clock, ::Busy, ::Stop)\n\nStop the clock.\n\n\n\n\n\nstep!(clk::Clock, ::Halted, ::Resume)\n\nResume a halted clock.\n\n\n\n\n\nstep!(clk::Clock, q::ClockState, σ::ClockEvent)\n\ncatch all step!-function.\n\n\n\n\n\nRun an active clock for a given duration.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Assigning-and-registering-events.-1","page":"Internals","title":"Assigning and registering events.","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"assign\nregister\nregister!","category":"page"},{"location":"manual/internals/#Simulate.assign","page":"Internals","title":"Simulate.assign","text":"assign(c::S, ev::T, id::Int=c.id) where {S<:AbstractClock, T<:AbstractEvent}\n\nAssign an event to a clock.\n\nThere are several ways to do it:\n\nassign it directly to a clock or an active clock or\nassign it via a clock via a clock to another one, if given a different id.  In this case the event is sent over the channel to the target clock.\nThe master clock (id=0) can directly send to an active clock.\nAn active clock can send directly to master.\nAn active clock can only send via master to another active clock.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.register","page":"Internals","title":"Simulate.register","text":"register(c::Clock, ev::T, id::Int) where {T<:AbstractEvent}\nregister(ac::ActiveClock, ev::T, id::Int) where {T<:AbstractEvent}\n\nRegister an event to another clock via a channel.\n\nArguments\n\nc::Clock: a master clock can forward events to active clocks,\nac::ActiveClock: active clocks can forward events only through master, he then   does the distribution for them,\nev::AbstractEvent: the event to register,\nid::Int: the id of the clock it should get registered to.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.register!","page":"Internals","title":"Simulate.register!","text":"register!(c::Clock, ev::DiscreteEvent)\nregister!(c::Clock, cond::DiscreteCond)\nregister!(c::Clock, sp::Sample)\nregister!(ac::ActiveClock, ev::T) where {T<:AbstractEvent}\n\nRegister a concrete event directly to a clock.\n\n\n\n\n\nregister!(clk::Clock, p::Prc)\n\nRegister a Prc to a clock. Check its id and change it apropriately.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Other-internal-types-and-functions-1","page":"Internals","title":"Other internal types and functions","text":"","category":"section"},{"location":"manual/internals/#","page":"Internals","title":"Internals","text":"evaluate\n_invoke\n_invokelt\nevExec\nnextevent\nnextevtime\nsetTimes\ntadjust\nbusy\ndo_event!\ndo_tick!\ndo_step!\ndo_run!\nstartup!\nwakeup\ninit!\nloop\nscale","category":"page"},{"location":"manual/internals/#Simulate.evaluate","page":"Internals","title":"Simulate.evaluate","text":"evaluate(y,  m::Module)\n\nFunction barrier for arguments and keywords of a fun. This allows Expr, Symbol and fun as arguments and keyword values.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate._invoke","page":"Internals","title":"Simulate._invoke","text":"Function barrier for executing funs.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate._invokelt","page":"Internals","title":"Simulate._invokelt","text":"Function barrier for executing funs with invokelatest.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.evExec","page":"Internals","title":"Simulate.evExec","text":"evExec(ex, m::Module=Main)\n\nFunction barrier for different ex: forward an event's functions or expressions to further execution or evaluation.\n\nReturn\n\nthe evaluated value or a tuple of evaluated values.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.nextevent","page":"Internals","title":"Simulate.nextevent","text":"nextevent(c::Clock)\n\nReturn the next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.nextevtime","page":"Internals","title":"Simulate.nextevtime","text":"nextevtime(c::Clock)\n\nReturn the internal time (unitless) of next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.setTimes","page":"Internals","title":"Simulate.setTimes","text":"setTimes(clk::Clock)\n\nset clock times for next event or sampling action. The internal clock times clk.tev and clk.tn must always be set to be at least clk.time.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.tadjust","page":"Internals","title":"Simulate.tadjust","text":"tadjust(clk::Clock, t::Unitful.Time) :: Float64\n\nAdjust/convert t given according to clock settings and return a Float64 value.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.busy","page":"Internals","title":"Simulate.busy","text":"Is a Clock busy?\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.do_event!","page":"Internals","title":"Simulate.do_event!","text":"do_event!(c::Clock)\n\nExecute or evaluate the next timed event on a clock c.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.do_tick!","page":"Internals","title":"Simulate.do_tick!","text":"do_tick!(s::Schedule)\n\nFirst execute all sampling expressions in a schedule, then evaluate all conditional events and if conditions are met, execute them.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.do_step!","page":"Internals","title":"Simulate.do_step!","text":"do_step!(c::Clock)\n\nstep forward to next tick or scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.do_run!","page":"Internals","title":"Simulate.do_run!","text":"do_run(c::Clock, Δt::Float64)\n\nRun a clock for a time Δt.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.startup!","page":"Internals","title":"Simulate.startup!","text":"startup!(p::Prc, cycles::Number, spawn::Bool)\n\nStart a Prc as a task in a loop.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.wakeup","page":"Internals","title":"Simulate.wakeup","text":"wakeup a process waiting for a Condition\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.init!","page":"Internals","title":"Simulate.init!","text":"init!(clk::Clock)\n\ninitialize a clock.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.loop","page":"Internals","title":"Simulate.loop","text":"loop(p::Prc, start::Channel, cycles::Number)\n\nPut a Prc in a loop which can be broken by a ClockException.\n\nArguments\n\np::Prc:\nstart::Channel: a channel to ensure that a process starts,\ncycles=Inf: determine, how often the loop should be run.\n\n\n\n\n\n","category":"function"},{"location":"manual/internals/#Simulate.scale","page":"Internals","title":"Simulate.scale","text":"scale(n::Number)::Float64\n\ncalculate the scale from a given number\n\n\n\n\n\n","category":"function"},{"location":"manual/parallel/#Parallel-simulations-1","page":"Parallel simulations","title":"Parallel simulations","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"Currently Simulate.jl enables two approaches to parallel simulations.","category":"page"},{"location":"manual/parallel/#Simulations-in-parallel-1","page":"Parallel simulations","title":"Simulations in parallel","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"Multiple simulations can be executed on parallel threads using the @threads- macro. Such simulations have different clocks with different times. One example of this is given in the dice game example. This approach is useful if you do multiple simulations to investigate their response to parameter variation. Basically you write a function, accepting parameters and doing a simulation on them. You then can invoke multiple simulations in a for loop:","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"","category":"page"},{"location":"manual/parallel/#Multithreading-of-events-and-processes-1","page":"Parallel simulations","title":"Multithreading of events and processes","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"compat: Julia 1.3\nMultithreading requires Julia ≥ 1.3.","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"warning: Not user-ready !!!\nMultithreading is still experimental and in active development.","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"Simulations consist of multiple events, sampling functions and asynchronous processes. The clock executes them sequentially on one thread. But modern computers have multiple cores, each being able to execute at least one distinct thread of operations. In order to speed things up, you may want to use the other cores (threads) as well:","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"PClock creates a clock with corresponding ActiveClocks [1] on each available thread. An existing single clock can be fork!ed to other threads. ActiveClocks can then schedule and execute parallel events,  processes and samples.  \nThe parallel clocks are accessible with pclock. By  registering events (event!), samples (periodic!) or processes (process!) to them you get parallel clock schedules.\nYou can also schedule events or processes randomly on parallel clocks by calling event!, process! or periodic! with spawn=true. This allows to balance the load between threads.\nIf you run! a parallelized clock, the clock on thread 1 becomes the \"master\", tells the clocks on the other threads to run for a time step Δt and synchronizes with them after each such step.","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"","category":"page"},{"location":"manual/parallel/#Uncertainty-of-event-sequence-1","page":"Parallel simulations","title":"Uncertainty of event sequence","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"Multithreading introduces an uncertainty into simulations: If an event e_x has a scheduling time before event e_y on another thread both lying inside the same time interval t_x + Δt, maybe – depending on differing thread loads – e_y gets executed before e_x. There are several techniques to reduce this uncertainty:","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"If there is a causal connection between two events such that e_y depends on e_x, the first one can be scheduled as event! with sync=true to force its execution before the second. But such dependencies are not always known beforehand in simulations.\nYou can choose to group causally connected events on one thread by scheduling them together on a specific parallel clock, such that they are executed in sequence. Consider a factory simulation: in real factories shops are often decoupled by buffers. You can allocate processes, events and samples of each shop  together on a thread. See grouping below.\nYou can generally reduce the synchronization cycle Δt such that clocks get synchronized more often.","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"There is a tradeoff between parallel efficiency and uncertainty: if threads must be synchronized more often, there is more cost of synchronization relative to execution. You have to choose the uncertainty you are willing to pay to gain parallel efficiency. Often in simulations as in life fluctuations in event sequence cancel out statistically and can be neglected.","category":"page"},{"location":"manual/parallel/#grouping-1","page":"Parallel simulations","title":"Grouping of events and processes","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"explicit grouping of events, processes and samples to parallel clocks,\ngrouping them with the @threads macro,","category":"page"},{"location":"manual/parallel/#Parallel-efficiency-1","page":"Parallel simulations","title":"Parallel efficiency","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"number of threads to use,","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"see the chapter in performance","category":"page"},{"location":"manual/parallel/#Thread-safety-1","page":"Parallel simulations","title":"Thread safety","text":"","category":"section"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"using random numbers on parallel threads,\nsynchronizing write access to shared variables,","category":"page"},{"location":"manual/parallel/#","page":"Parallel simulations","title":"Parallel simulations","text":"[1]: They are called \"active clocks\" because they follow the active object design pattern. They run in event loops, behave internally as state machines and communicate with the master clock across threads via channels following a simple communication protocol.","category":"page"},{"location":"performance/performance/#Performance-1","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"For larger models and simulations over longer timeframes performance matters and users can do a lot to get more of it. The generic process of getting more performant simulations is:","category":"page"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"Follow the performance tips in the Julia manual,\nfollow the hints in this chapter,\nparallelize simulations following.  ","category":"page"},{"location":"performance/performance/#Functions-vs-quoted-expressions-1","page":"Performance","title":"Functions vs quoted expressions","text":"","category":"section"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"for events use SimFunction instead of quoted expressions. It is much faster.\nbenchmarks","category":"page"},{"location":"performance/performance/#Use-of-variables-1","page":"Performance","title":"Use of variables","text":"","category":"section"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"if values don't change, declare them as const,\ndeclare composite global variables, achieve type stability\nbenchmarks","category":"page"},{"location":"performance/performance/#Event-based-simulations-are-faster-than-process-based-ones-1","page":"Performance","title":"Event based simulations are faster than process based ones","text":"","category":"section"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"If you work on a single thread, sequential execution of events is faster than events + task switching. The convenience of process based models comes at a performance cost.","category":"page"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"benchmark results","category":"page"},{"location":"performance/performance/#Reactive-programming-1","page":"Performance","title":"Reactive programming","text":"","category":"section"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"You can speedup process based simulations quite a bit if you design your processes as state machines running in run-to-completion (RTC) loops without blocking calls. Instead of delay! or wait! they schedule events for themselves with the clock.","category":"page"},{"location":"performance/performance/#","page":"Performance","title":"Performance","text":"example\nbenchmark results","category":"page"},{"location":"examples/examples/#Examples-overview-1","page":"Examples - overview","title":"Examples - overview","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples - overview","title":"Examples - overview","text":"The examples are intended to show how Simulate.jl can be used and how different approaches to modeling and simulation can be employed and combined with it.","category":"page"},{"location":"examples/examples/#","page":"Examples - overview","title":"Examples - overview","text":"Table tennis: a state-based simulation,\nSingle server: an activity-based simulation of a single server,\nPost office: a process-based simulation of a post-office,\nGoldratt's dice game: a simulation of assembly lines, illustrating what can be done with multiple simulations and parameter variation on parallel threads,\nHouse heating: a simulation of a hybrid system, combining all three schemes: events, continuous sampling and processes.","category":"page"},{"location":"examples/examples/#Working-with-the-examples-1","page":"Examples - overview","title":"Working with the examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples - overview","title":"Examples - overview","text":"If you would like to play with the examples:","category":"page"},{"location":"examples/examples/#","page":"Examples - overview","title":"Examples - overview","text":"Jupyter notebooks are here in the repo\nJulia programs/.jl-files are here in the repo.","category":"page"},{"location":"manual/troubleshooting/#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"manual/troubleshooting/#Problems-1","page":"Troubleshooting","title":"Problems","text":"","category":"section"},{"location":"manual/troubleshooting/#Process-startup-1","page":"Troubleshooting","title":"Process startup","text":"","category":"section"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Under some environments (e.g. Jupyter) it may happen, that the processes have not started completely before the clock runs. In such cases it may help to put a little sleep, e.g. sleep!(0.1) between process!(…) and run!(…) to ensure that all started processes have enqueued for clock events.","category":"page"},{"location":"manual/troubleshooting/#Clock-information-1","page":"Troubleshooting","title":"Clock information","text":"","category":"section"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Normally for clocks pretty printing is enabled. For diagnostic purposes you can switch pretty printing off and on:","category":"page"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> clk = Clock()\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> Simulate._show_default[1] = true;\n\njulia> clk\nClock(0, Simulate.Undefined(), 0.0, , 0.0, Simulate.AC[], Simulate.Schedule(DataStructures.PriorityQueue{Simulate.DiscreteEvent,Float64,Base.Order.ForwardOrdering}(), Simulate.DiscreteCond[], Simulate.Sample[]), Dict{Any,Prc}(), 0.0, 0.0, 0.0, 0, 0)\n\njulia> Simulate._show_default[1] = false;\n\njulia> clk\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0","category":"page"},{"location":"manual/troubleshooting/#A-process-fails-1","page":"Troubleshooting","title":"A process fails","text":"","category":"section"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"If c is your clock, you get the list of all running processes with c.processes. You  then look at the failed process with c.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> 𝐶.processes\nDict{Any,Prc} with 2 entries:\n  2 => Prc(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{…\n  1 => Prc(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel…\njulia> 𝐶.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\n[....]","category":"page"},{"location":"manual/troubleshooting/#Report-1","page":"Troubleshooting","title":"Report","text":"","category":"section"},{"location":"manual/troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Otherwise please report your problem and open an issue or commit your solution to the repo.  ","category":"page"},{"location":"manual/usage/#User-guide-1","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"manual/usage/#Installation-1","page":"User guide","title":"Installation","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"CurrentModule = Simulate","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Simulate.jl runs on Julia versions ≥ v\"1.0\". Multithreading requires Julia ≥ v\"1.3\".","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Simulate\nversion","category":"page"},{"location":"manual/usage/#Simulate.Simulate","page":"User guide","title":"Simulate.Simulate","text":"Simulate\n\nA Julia package for discrete event simulation.\n\nThe current stable, registered version is installed with\n\npkg> add Simulate\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/Simulate.jl\")\n\n\n\n\n\n","category":"module"},{"location":"manual/usage/#Simulate.version","page":"User guide","title":"Simulate.version","text":"version\n\nGives the package version:\n\njulia> using Simulate\n\njulia> Simulate.version\nv\"0.3.0\"\n\n\n\n\n\n","category":"constant"},{"location":"manual/usage/#Clocks-1","page":"User guide","title":"Clocks","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"A clock in Simulate.jl is an active object residing in a thread and registers function calls or expressions as events, schedules them at a given time or under a given condition and executes them at their time or if conditions are met.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Clock and ActiveClocks have virtual (simulation) time. A Clock can control and synchronizes with ActiveClocks on other threads. It can be started and run for a given time.\nRTClocks have real (system) time and operate independently from each other and other clocks. They run continuously at given clock ticks and execute scheduled events if their time becomes due.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Clock\nActiveClock\nRTClock","category":"page"},{"location":"manual/usage/#Simulate.Clock","page":"User guide","title":"Simulate.Clock","text":"Clock(Δt::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)\n\nCreate a new simulation clock.\n\nArguments\n\nΔt::Number=0: time increment. If no Δt is given, the simulation doesn't tick,   but jumps from event to event. Δt can be set later with sample_time!.\nt0::Number=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. t0=60s.\n\nFields\n\nid::Int: thread on which the clock is running,\nstate::ClockState: clock state,\ntime::Float64: clock time,\nunit::FreeUnits: time unit,\nend_time::Float64: end time for simulation,\nΔt::Float64: sampling time, timestep between ticks,\nac::Vector{ClockChannel}: active clocks running on parallel threads,\nsc::Schedule: the clock schedule (events, cond events and sampling),\nprocesses::Dict{Any, Prc}: registered Prces,\ntn::Float64: next timestep,\ntev::Float64: next event time,\nevcount::Int: event counter,\nscount::Int: sample counter\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()                 # create a unitless clock (standard)\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 minute, Δt=0.01667 minute, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s)               # create a clock with implicit unit setting\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(t0=60s)           # another example of implicit unit setting\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Δt=0.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s, t0=1hr)       # if given times with different units, Δt takes precedence\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=3600.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.ActiveClock","page":"User guide","title":"Simulate.ActiveClock","text":"ActiveClock(clock::Clock, master::Ref{Clock},\n            cmd::Channel{ClockEvent}, ans::Channel{ClockEvent})\n\nA thread specific clock which can be operated via a channel.\n\nFields\n\nclock::Clock: the thread specific clock,\nmaster::Ref{Clock}: a pointer to the master clock (on thread 1),\ncmd::Channel{ClockEvent}: the command channel from master,\nans::Channel{ClockEvent}: the response channel to master.\nid::Int: the id in master's ac array,\nthread::Int: the thread, the active clock runs on.\n\nnote: Note\n\n\nYou should not setup an ActiveClock explicitly. Rather this is done implicitly by fork!ing a Clock to other available threads or directly with PClock. It then can be accessed via pclock as in the following example.\n\nExample\n\njulia> using Simulate\n\njulia> clk = Clock()\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> fork!(clk)\n\njulia> clk    #  ⬇ you got 3 parallel active clocks\nClock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> clk = PClock()\nClock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> pclock(clk, 1)    # get access to the 1st active clock (on thread 2)\nActive clock 1 on thrd 2: state=Simulate.Idle(), t=0.0 , Δt=0.01 , prc:0\n   scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.RTClock","page":"User guide","title":"Simulate.RTClock","text":"RTClock{T <: ClockEvent} <: AbstractClock\n\nReal time clocks use system time for time keeping and are controlled over a channel. They are independent from each other and other clocks and run asynchronously as tasks on arbitrary threads. Multiple real time clocks can be setup with arbitrary frequencies to do different things.\n\nFields\n\nclock::Clock:\ncmd::Channel{T}:\nback::Channel{T}:\nid::Int:\nthread::Int:\nt0::Float64:\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Clocks have the following substructures:","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Schedule\nClockChannel","category":"page"},{"location":"manual/usage/#Simulate.Schedule","page":"User guide","title":"Simulate.Schedule","text":"Schedule()\n\nA Schedule contains events, conditional events and sampling functions to be executed or evaluated on the clock's time line.\n\nFields\n\nevents::PriorityQueue{DiscreteEvent,Float64}: scheduled events,\ncevents::Array{DiscreteCond,1}: conditional events to evaluate at each tick,\nsamples::Array{Sample,1}: sampling expressions to evaluate at each tick,\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.ClockChannel","page":"User guide","title":"Simulate.ClockChannel","text":"ClockChannel\n\nProvide a channel to an active clock or a real time clock.\n\nFields\n\nref::Ref{Task}: a pointer to an active clock,\nch::Channel: a communication channel to an active clock,\nid::Int: the thread id of the active clock.\ndone::Bool: flag indicating if the active clock has completed its cycle.\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"You can set time units and query the current clock time. There is a default clock 𝐶, which can be used for experimental work. RTC can be used to setup and control real time Clocks.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"setUnit!\ntau\n𝐶\nRTC","category":"page"},{"location":"manual/usage/#Simulate.setUnit!","page":"User guide","title":"Simulate.setUnit!","text":"setUnit!(clk::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nclk::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60)     # setup a new clock with t0=60\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tau(c) # current time is 60.0 NoUnits\n60.0\n\njulia> setUnit!(c, s)       # set clock unit to Unitful.s\n60.0 s\n\njulia> tau(c) # current time is now 60.0 s\n60.0 s\n\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\n\njulia> tau(c)               # current time is now 1.0 minute\n1.0 minute\n\njulia> isa(tau(c), Time)\ntrue\n\njulia> uconvert(s, tau(c))  # ... which can be converted to other time units\n60.0 s\n\njulia> tau(c).val           # it has a value of 1.0\n1.0\n\njulia> c.time               # internal clock time is set to 1.0 (a Float64)\n1.0\n\njulia> c.unit               # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.tau","page":"User guide","title":"Simulate.tau","text":"tau(clk::Clock=𝐶)\n\nReturn the current simulation time.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\njulia> tau() # gives the central time\n0.0\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.𝐶","page":"User guide","title":"Simulate.𝐶","text":"𝐶\n\n𝐶 (𝐶 = \\itC+tab) is the default simulation clock. If you do one simulation at a time, you can use it for time keeping.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\n\njulia> 𝐶  # default clock\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"constant"},{"location":"manual/usage/#Simulate.RTC","page":"User guide","title":"Simulate.RTC","text":"RTC::Vector{ClockChannel}\n\nReal time clocks are registered to RTC and can be accessed and operated through it.\n\n\n\n\n\n","category":"constant"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"You can create a clock with parallel active clocks on all available threads or fork existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel clocks and diagnose them.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"PClock\nfork!\npclock\ncollapse!\ndiag","category":"page"},{"location":"manual/usage/#Simulate.PClock","page":"User guide","title":"Simulate.PClock","text":"PClock(Δt::Number=0.01; t0::Number=0, unit::FreeUnits=NoUnits)\n\nSetup a clock with parallel clocks on all available threads.\n\nArguments\n\nΔt::Number=0.01: time increment. For parallel clocks Δt has to be > 0.   If given Δt ≤ 0 it is set to 0.01.\nt0::Number=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. t0=60s.\n\nnote: Note\nProcesses on multiple threads are possible in Julia ≥ 1.3 and with JULIA_NUM_THREADS > 1.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.fork!","page":"User guide","title":"Simulate.fork!","text":"fork!(master::Clock)\n\nEstablish copies of a clock on all parallel threads and operate them as active clocks under control of the master clock.\n\nArguments\n\nmaster::Clock: the master clock, must be on thread 1\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.pclock","page":"User guide","title":"Simulate.pclock","text":"pclock(clk::Clock, id::Int ) :: AbstractClock\npclock(ac::ActiveClock, id::Int ) :: AbstractClock\n\nGet a parallel clock to a given clock.\n\nArguments\n\nmaster::Clock: a master clock or\nac::ActiveClock: an active clock,\nid::Int=threadid(): thread id, defaults to the caller's current thread.\n\nReturns\n\nthe master Clock if id==0,\na parallel ActiveClock else\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.collapse!","page":"User guide","title":"Simulate.collapse!","text":"collapse!(master::Clock)\n\nTransfer the schedules of the parallel clocks to master and them stop them.\n\nnote: Note\nIf there are processes on other threads registered to parallel clocks, make sure that they aren't needed anymore before calling collapse. They are not transferred to and cannot be controlled by master.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.diag","page":"User guide","title":"Simulate.diag","text":"diag(clk::Clock, id::Int)\n\nReturn the stacktrace from a parallel clock.\n\nArguments\n\nclk::Clock: a master clock,\nid::Int: the id of a parallel clock.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"note: Note\n","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Directly accessing the clock substructure of parallel ActiveClocks is possible but not recommended since it breaks parallel operation. The right way is to pass event!s to the ActiveClock-variable. The communication then happens over the channel to the ActiveClock as it should be.","category":"page"},{"location":"manual/usage/#Events-1","page":"User guide","title":"Events","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Julia expressions and functions can be scheduled as events on the clock's timeline and are triggered at a given simulation time or under conditions which may become true during simulation.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Functions and expressions can be scheduled for execution","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"at given clock times and\nunder specified conditions.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"AbstractEvent\nDiscreteEvent\nDiscreteCond\nTiming\nfun\nAction\nevent!","category":"page"},{"location":"manual/usage/#Simulate.AbstractEvent","page":"User guide","title":"Simulate.AbstractEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.DiscreteEvent","page":"User guide","title":"Simulate.DiscreteEvent","text":"DiscreteEvent{T<:Action} <: AbstractEvent\n\nA discrete event is a function or an expression or a tuple of them to be executed at an event time.\n\nArguments, fields\n\nex::T: a function or an expression or a tuple of them,\nscope::Module: evaluation scope,\nt::Float64: event time,\nΔt::Float64: repeat rate with for repeating events.\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.DiscreteCond","page":"User guide","title":"Simulate.DiscreteCond","text":"DiscreteCond{S<:Action, T<:Action} <: AbstractEvent\n\nA condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments, fields\n\ncond::S: a conditional function or an expression or a tuple of them   (conditions must evaluate to Bool),\nex::T: a function or an expression or a tuple of them to be executed   if conditions are met,\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.Timing","page":"User guide","title":"Simulate.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.fun","page":"User guide","title":"Simulate.fun","text":"fun(f::Function, args..., kwargs...)\n\nReturn a closure of a function f and its arguments for later execution.\n\nArguments\n\nfun can take any arguments. Arguments of f may change their values between beeing captured in fun and fs later execution. If f must evaluate their current values at execution time there are two possibilities:\n\nfun can take symbols, expressions or other funs as arguments. They  are evaluated just before being passed to f. There is one exception:  if f is an event!, its arguments are passed on unevaluated.\nComposite variables (Arrays, structs ...) are always current.\n\nwarning: Evaluating symbols and expressions is slow\n… and should be avoided in time critical parts of applications. You will get a one time warning if you use that feature. See the Performance section in the documentation.\n\nReturns\n\nIt returns a function closure of f(args..., kwargs...) which has to be called with a Module argument (for evaluation scope of symbols and expressions).\n\nExamples\n\njulia> using Simulate\n\njulia> g(x; y=1) = x+y\ng (generic function with 1 method)\n\njulia> a = 1\n1\n\njulia> gg = fun(g, :a, y=2)   # we pass a as a symbol to fun\n#12 (generic function with 1 method)\n\njulia> a += 1                 # a gets 2\n2\n\njulia> gg(Main)               # at execution g gets the current value of a\n┌ Warning: Evaluating expressions is slow, use functions instead\n└ @ Simulate ~/.julia/dev/Simulate/src/fclosure.jl:32\n4\n\njulia> hh = fun(g, fun(()->a), y=3)   # reference a with an anonymous function\n#12 (generic function with 1 method)\n\njulia> a += 1                 # a gets 3\n3\n\njulia> hh(Main)               # at execution g gets again a current a\n6\n\njulia> ii = fun(g, (m)->a, y=4)  # reference a with a mock fun, taking a module m\n#12 (generic function with 1 method)\n\njulia> a += 1                 # a gets 4\n4\n\njulia> ii(Main)\n8\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.Action","page":"User guide","title":"Simulate.Action","text":"Action\n\nAn action is either an Expr or a Function or a Tuple of them.\n\n\n\n\n\n","category":"constant"},{"location":"manual/usage/#Simulate.event!","page":"User guide","title":"Simulate.event!","text":"event!\n\nAn event! is a Julia function or expression or a tuple of them to execute at a given event time or under given conditions.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Functions and expressions can be given to events on their own or in tuples, even mixed:","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"function events()\n    event!(:(i += 1), after, 10)  # one expression\n    event!(fun(f, 1, 2, 3, diff=pi), every, 1)  # one fun\n    event!((:(i += 1), fun(g, j)), [:(tau() ≥ 50), fun(isready, input), :(a ≤ 10)]) # two funs under three conditions\nend","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"All given functions or expressions are then called or evaluated at a given simulation time or when during simulation the given conditions become true.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"warning: Warning\nEvaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. See Performance. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"note: Note\nSince conditions often are not met exactly you should prefer inequalities like <, ≤, ≥, > to equality == in order to get sure that a fulfilled condition can be detected, e.g. :(tau() ≥ 100) is preferable to :(tau() == 100).","category":"page"},{"location":"manual/usage/#Continuous-sampling-1","page":"User guide","title":"Continuous sampling","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Functions or expressions can register for sampling and are then executed \"continuously\" at each clock increment Δt.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Sample\nsample_time!\nperiodic!","category":"page"},{"location":"manual/usage/#Simulate.Sample","page":"User guide","title":"Simulate.Sample","text":"Sample{T<:Action} <: AbstractEvent\n\nSampling functions or expressions are called at sampling time.\n\nArguments, fields\n\nex<:Action: expression or function or a tuple of them to be called   at sample time,\nscope::Module: evaluation scope.\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.sample_time!","page":"User guide","title":"Simulate.sample_time!","text":"sample_time!([clk::Clock], Δt::Number)\n\nset the clock's sample rate starting from now (tau(clk)).\n\nArguments\n\nclk::Clock: if not supplied, set the sample rate on 𝐶,\nΔt::Number: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.periodic!","page":"User guide","title":"Simulate.periodic!","text":"periodic!([clk::Clock], ex::T, Δt::Number=clk.Δt;\n        scope::Module=Main, spawn=false) where {T<:Action}\nperiodic!(ac::ActiveClock, ex::T, Δt::Number=ac.clock.Δt; kw...) where {T<:Action}\n\nRegister a function or expression for periodic execution at the clock`s sample rate.\n\nArguments\n\nclk::Clock, ac::ActiveClock: if not supplied, it samples on 𝐶,\nex<:Action: an expression or function or a tuple of them,\nΔt::Number=clk.Δt: set the clock's sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,\nscope::Module=Main: optional, an evaluation scope for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Processes-1","page":"User guide","title":"Processes","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Julia functions can be registered and run as processes. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Prc\nClockException\nprocess!\ninterrupt!\nstop!(::Prc, ::ClockEvent)","category":"page"},{"location":"manual/usage/#Simulate.Prc","page":"User guide","title":"Simulate.Prc","text":"Prc( id, f::Function, arg...; kw...)\n\nPrepare a function to run as a process in a simulation.\n\nArguments, fields\n\nid: some unique identification for registration,\ntask::Union{Task,Nothing}: a task structure,\nclk::Union{AbstractClock,Nothing}: clock where the process is registered,\nstate::ClockState: process state,\nf::Function: a function f(clk, arg...; kw...), must take clk as its   first argument,\narg...: further arguments to f\nkw...: keyword arguments to f\n\nnote: Note\nA function started as a Prc most often runs in a loop. It has to give back control by e.g. doing a take!(input) or by calling delay! etc., which will yield it. Otherwise it will starve everything else!\n\nwarn: Warn\nThat f nust take clk as first argument is a breaking change in v0.3!\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.ClockException","page":"User guide","title":"Simulate.ClockException","text":"ClockException(ev::ClockEvent, value=nothing)\n\nDefine a ClockException, which can be thrown to processes.\n\nArguments, fields\n\nev::ClockEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"manual/usage/#Simulate.process!","page":"User guide","title":"Simulate.process!","text":"process!([clk::Clock], p::Prc, cycles=Inf; spawn::Bool=false)\n\nRegister a Prc to a clock, start it as an asynchronous process and return the id it was registered with. It can then be found under clk.processes[id].\n\nArguments\n\nc::AbstractClock: Clock or ActiveClock, if not provided, the process runs   under 𝐶,\np::Prc: it contains a function and its arguments,\ncycles::Number=Inf: number of cycles the process should run,\nspawn::Bool=false: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.\n\nnote: Note\nspawning a process is possible only with parallel clocks setup with PClock or fork!.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.interrupt!","page":"User guide","title":"Simulate.interrupt!","text":"interrupt!(p::Prc, ev::ClockEvent, value=nothing)\n\nInterrupt a Prc by throwing a ClockException to it.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}","page":"User guide","title":"Simulate.stop!","text":"Stop a Prc\n\n\n\n\n\n","category":"method"},{"location":"manual/usage/#Delay-and-wait-…-1","page":"User guide","title":"Delay and wait …","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Processes do not need to handle their events explicitly, but can call delay! or wait! or take! and put! … on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"delay!\nwait!","category":"page"},{"location":"manual/usage/#Simulate.delay!","page":"User guide","title":"Simulate.delay!","text":"delay!(clk::Clock, t::Number)\n\nDelay a process for a time interval t on the clock clk. Suspend the calling process until being reactivated by the clock at the appropriate time.\n\nArguments\n\nclk::Clock: if not provided, the delay goes to 𝐶.\nt::Number: the time interval for the delay.\n\n\n\n\n\ndelay!(clk::Clock, T::Timing, t::Number)\n\nUsed for delaying a process until a given time t.\n\nArguments\n\nclk::Clock: if no clock is given, the delay goes to 𝐶,\nT::Timing: only until is accepted,\nt::Number: delay until time t if t > clk.time, else give a warning.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.wait!","page":"User guide","title":"Simulate.wait!","text":"wait!(clk::Clock, cond::Action; scope::Module=Main)\n\nWait on a clock for a condition to become true. Suspend the calling process until the given condition is true.\n\nArguments\n\nclk::Clock: if no clock is supplied, the delay goes to 𝐶,\ncond::Action: a condition is an expression or function   or an array or tuple of them. It is true only if all expressions or functions   therein return true,\nscope::Module=Main: evaluation scope for given expressions.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Now-1","page":"User guide","title":"Now","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"Processes in a simulation want their IO-operations to finish before the clock proceeds. Therefore they must enclose those operations in a now! call.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"now!","category":"page"},{"location":"manual/usage/#Simulate.now!","page":"User guide","title":"Simulate.now!","text":"now!(clk::Clock, op::Action)\n\nTell the clock to execute an operation. Thus it cannot proceed before the op is finished.\n\nnote: Note\nThis is needed for IO-operations of tasks. IO-operations yield the task to the scheduler and the scheduler may invoke the clock before giving control back to the task. In that case the clock will proceed and the task has gone out of sync with the clock. Use now! to avoid this situation!\n\nArguments\n\nclk::Clock,\nop::Action: operation to execute.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Running-simulations-1","page":"User guide","title":"Running simulations","text":"","category":"section"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed … We can also step through a simulation, stop, resume or reset it.","category":"page"},{"location":"manual/usage/#","page":"User guide","title":"User guide","text":"reset!\nincr!\nrun!\nstop!(::Clock)\nresume!\nsync!","category":"page"},{"location":"manual/usage/#Simulate.reset!","page":"User guide","title":"Simulate.reset!","text":"reset!(clk::Clock, Δt::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)\n\nreset a clock\n\nArguments\n\nclk::Clock\nΔt::Number=0: time increment\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Δt::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> reset!(c)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\n\njulia> c\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.incr!","page":"User guide","title":"Simulate.incr!","text":"incr!(clk::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.run!","page":"User guide","title":"Simulate.run!","text":"run!(clk::Clock, duration::Number)\n\nRun a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.stop!-Tuple{Clock}","page":"User guide","title":"Simulate.stop!","text":"stop!(clk::Clock)\n\nStop a running simulation.\n\n\n\n\n\n","category":"method"},{"location":"manual/usage/#Simulate.resume!","page":"User guide","title":"Simulate.resume!","text":"resume!(clk::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Simulate.sync!","page":"User guide","title":"Simulate.sync!","text":"sync!(clk::Clock, to::Clock=𝐶)\n\nForce a synchronization of two clocks. Change all registered times of clk accordingly. Convert or force clk.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"performance/benchmarks/#Benchmarks-1","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"manual/approach/#Approaches-to-modeling-and-simulation-1","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Simulate.jl supports different approaches to modeling and simulation of discrete event systems (DES). It provides three major schemes: 1) an event-scheduling scheme, 2) a process-oriented scheme and 3) continuous sampling. With them different modeling strategies can be applied.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"A problem can be expressed differently through various modeling approaches. A simple problem can illustrate this :","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"A server takes something from an input, processes it for some time and puts it out to an output. There are 8 servers in the system, 4 foos and 4 bars interacting with each other via two channels.","category":"page"},{"location":"manual/approach/#Event-based-modeling-1","page":"Approaches to modeling and simulation","title":"Event based modeling","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"In this view events occur in time and trigger further events. Here the three server actions are seen as events and can be described in an event graph:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"(Image: event graph)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"You define a data structure for the server, provide functions for the three actions, create channels and servers and start:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\nfunction take(S::Server)\n    if isready(S.input)\n        S.token = take!(S.input)\n        @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n        event!(fun(put, S), after, rand())         # call put after some time\n    else\n        event!(fun(take, S), fun(isready, S.input)) # call again if input is ready\n    end\nend\n\nfunction put(S::Server)\n    put!(S.output, S.op(S.id, S.token))\n    S.token = nothing\n    take(S)\nend\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    take(Server(s[i], \"foo\", ch1, ch2, +))\n    take(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"julia> include(\"docs/examples/channels1.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"see: tau, event!, fun, reset!, 𝐶, run!","category":"page"},{"location":"manual/approach/#State-based-modeling-1","page":"Approaches to modeling and simulation","title":"State based modeling","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Here the server has three states: Idle, Busy and End (where End does nothing). On an arrival event it resets its internal clock x=0 and determines the service time t_s, moves to Busy, works on its input and puts it out when t_s is over. Then it goes back to Idle. A state transition diagram (Mealy model) of the timed automaton would look like:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"(Image: timed automaton)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Again you need a data structure for the server (state …). You define states and events and implement a δ transition function with two methods. Thereby you dispatch on states and events. Since you don't need to implement all combinations of states and events, you may implement a fallback transition.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"using Simulate, Printf, Random\n\nabstract type Q end  # states\nstruct Idle <: Q end\nstruct Busy <: Q end\nabstract type Σ end  # events\nstruct Arrive <: Σ end\nstruct Leave <: Σ end\n\nmutable struct Server\n    id::Int64\n    name::AbstractString\n    input::Channel\n    output::Channel\n    op     # operation to take\n    state::Q\n    token  # current token\n\n    Server(id, name, input, output, op) = new(id, name, input, output, op, Idle(), nothing)\nend\n\narrive(A) = event!(fun(δ, A, A.state, Arrive()), fun(isready, A.input))\n\nfunction δ(A::Server, ::Idle, ::Arrive)\n    A.token = take!(A.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), A.name, A.id, A.token)\n    A.state=Busy()\n    event!(fun(δ, A, A.state, Leave()), after, rand())\nend\n\nfunction δ(A::Server, ::Busy, ::Leave)\n    put!(A.output, A.op(A.id,A.token))\n    A.state=Idle()\n    arrive(A)\nend\n\nδ(A::Server, q::Q, σ::Σ) =               # fallback transition\n        println(stderr, \"$(A.name) $(A.id) undefined transition $q, $σ\")\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"julia> include(\"docs/examples/channels2.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n ...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"see: tau, event!, fun, reset!, 𝐶, run!","category":"page"},{"location":"manual/approach/#Activity-based-modeling-1","page":"Approaches to modeling and simulation","title":"Activity based modeling","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"The server's activity is the processing of the token. A timed Petri net would look like:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"(Image: timed petri net)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"The arrive \"transition\" puts a \"token\" in the Queue. If both \"places\" Idle and Queue have tokens, the server takes them, shifts one to Busy and puts out two after a timed transition with delay v_put. Then it is Idle again and the cycle restarts.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"The server's activity is described by the blue box. Following the Petri net, you should implement a state variable with states Idle and Busy, but you don't need to if you separate the activities in time. You need a data structure for the server and define a function for the activity:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\narrive(S::Server) = event!(fun(serve, S), fun(isready, S.input))\n\nfunction serve(S::Server)\n    S.token = take!(S.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n    event!((fun(put!, S.output, S.op(S.id, S.token)), fun(arrive, S)), after, rand())\nend\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"julia> include(\"docs/examples/channels3.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n ...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"see: tau, event!, fun, reset!, 𝐶, run!","category":"page"},{"location":"manual/approach/#Process-based-modeling-1","page":"Approaches to modeling and simulation","title":"Process based modeling","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Here you combine it all in a simple function of take!-delay!-put! like in the activity based example, but running in the loop of a process. Processes can wait or delay and are suspended and reactivated by Julia's scheduler according to background events. There is no need to handle events explicitly and no need for a server data type since a process keeps its own data. Processes must look careful to their timing and therefore you must enclose the IO-operation in a now! call:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"function simple(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something, eventually wait for it\n    now!(fun(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(), name, id, token)))\n    d = delay!(rand())           # wait for a given time\n    put!(output, op(token, id))  # put something else out, eventually wait\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 Prces\n    process!(Prc(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(Prc(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nreset!(𝐶)\nput!(ch1, 1) # put first token into channel 1\nrun!(𝐶, 10)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"julia> include(\"docs/examples/channels4.jl\")\n 0.00: foo 7 took token 1\n 0.77: bar 4 took token 8\n 1.71: foo 3 took token 32\n 2.38: bar 2 took token 35\n 2.78: foo 5 took token 70\n 3.09: bar 8 took token 75\n ...\n 7.64: foo 7 took token 1387926\n 7.91: bar 4 took token 1387933\n 8.36: foo 3 took token 5551732\n 8.94: bar 2 took token 5551735\n 9.20: foo 5 took token 11103470\n 9.91: bar 8 took token 11103475\n\"run! finished with 21 clock events, simulation time: 10.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"see: now!, fun, tau, delay!, process!, Prc, reset!, run!, 𝐶","category":"page"},{"location":"manual/approach/#Comparison-1","page":"Approaches to modeling and simulation","title":"Comparison","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"The output of the last example is different from the first three approaches because we did not shuffle (the shuffling of the processes is done by the scheduler). So if the output depends very much on the sequence of events and you need to have reproducible results, explicitly controlling for the events like in the first three examples is preferable. If you are more interested in statistical evaluation - which is often the case -, the 4th approach is appropriate.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"All four approaches can be expressed in Simulate.jl. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured and controllable , which comes in handy for more complicated examples. After all, parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.","category":"page"},{"location":"manual/approach/#Combined-approach-1","page":"Approaches to modeling and simulation","title":"Combined approach","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Physical systems can be modeled as continuous systems (nature does not jump), discrete systems (nature jumps here!) or hybrid systems (nature jumps sometimes).","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"While continuous systems are the domain of differential equations, discrete and hybrid systems may be modeled easier with Simulate.jl by combining the event-scheduling, the process-based and the continuous-sampling schemes.","category":"page"},{"location":"manual/approach/#A-hybrid-system-1","page":"Approaches to modeling and simulation","title":"A hybrid system","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat or a house heating system is a basic example of this:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Heating changes between two states: On and Off. The thermostat switches heating on if romm temperature Tr is greater or equal 23°C, it switches off if temperature falls below 20°C.\nA room cools at a rate proportional to the difference between room temperature Tr and environment temperature Te.\nIt heats at a rate proportional to the temperature difference between temperature of the heating fluid Th and room temperature Tr.\nThe room temperature Tr changes proportional to the difference between heating and cooling.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"First we setup the physical model with some assumptions:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"using Simulate, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst α = 2e6     # represents thermal conductivity and capacity of the air\nconst β = 3e-7    # represents mass of the air and heat capacity\nη = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false   # initially the heating is off\n\nΔte(t, t1, t2) = cos((t-10)*π/12) * (t2-t1)/2  # change rate of a sinusoidal Te\n\nfunction Δtr(Tr, Te, heating)\n    Δqc = (Tr - Te)/(R * η)             # cooling rate\n    Δqh = heating ? α * (Th - Tr) : 0   # heating rate\n    return β * (Δqh - Δqc)              # change of room temperature\nend","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Δtr (generic function with 1 method)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"We setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"reset!(𝐶)                               # reset the clock\nrng = MersenneTwister(122)              # set random number generator\nΔt = 1//60                              # evaluate every minute\nTe = 11                                 # starting values\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)   # define a sampling function\n    global Te += Δte(tau(), t1, t2) * 2π/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Δtr(Tr, Te, heating) * Δt\n    push!(df, (tau(), Tr, Te, Int(heating)) )\nend\n\nfunction switch(t1=20, t2=23)           # a function simulating the thermostat\n    if Tr ≥ t2\n        global heating = false\n        event!(fun(switch, t1, t2), @val :Tr :≤ t1)  # setup a conditional event\n    elseif Tr ≤ t1\n        global heating = true\n        event!(fun(switch, t1, t2), @val :Tr :≥ t2)  # setup a conditional event\n    end\nend\n\nperiodic!(fun(setTemperatures), Δt)        # setup the sampling function\nswitch()                                   # start the thermostat\n\n@time run!(𝐶, 24)                          # run the simulation","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"(Image: svg)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"Now we have people entering the room or opening windows and thus reducing thermal resistance:","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am\n    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time\n    while tau() < sleeptime\n        global η = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global η = 1.0                       # close it again\n        delay!(rand())                       # do something else\n    end\nend\n\nreset!(𝐶)\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(Prc(i, people), 1)               # run process only once\nend\nperiodic!(fun(setTemperatures), Δt)    # setup sampling\nswitch()                                     # start the thermostat\n\n@time run!(𝐶, 24)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"(Image: svg)","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"see: tau, fun, event!, delay!, periodic!, run!, process!, Prc, reset!, 𝐶\nsee also: the full house heating example for further explanations.","category":"page"},{"location":"manual/approach/#Theories-1","page":"Approaches to modeling and simulation","title":"Theories","text":"","category":"section"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"There are some theories about the different approaches (1) event based, (2) state based, (3) activity based and (4) process based. Choi and Kang [1] have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune [2] call those \"the event scheduling scheme\" and the 4th approach \"the process-oriented simulation scheme\" [3]. There are communities behind the various views and Simulate.jl wants to be useful for them all.","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"[1]: Choi and Kang: Modeling and Simulation of Discrete-Event Systems, Wiley, 2013","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"[2]: Cassandras and Lafortune: Introduction to Discrete Event Systems, Springer, 2008, Ch. 10","category":"page"},{"location":"manual/approach/#","page":"Approaches to modeling and simulation","title":"Approaches to modeling and simulation","text":"[3]: to be fair, the 4th approach is called by Choi and Kang \"parallel simulation\".","category":"page"},{"location":"manual/timer/#Real-time-clocks-1","page":"Real time clocks","title":"Real time clocks","text":"","category":"section"},{"location":"manual/timer/#","page":"Real time clocks","title":"Real time clocks","text":"warning: Not user ready!!!\nReal time clocks are not yet for use and have still to be developed.","category":"page"},{"location":"examples/postoffice/postoffice/#Post-Office-1","page":"Post Office","title":"Post Office","text":"","category":"section"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"There is a small post office with one clerk serving the arriving customers. Customers have differing wishes leading to different serving times, from 1 - 5 minutes. We have a little variation in serving times due to variation in customer habits and clerk performance. The arrival rate of customers is about 18 per hour, every 3.33 minutes or 3 minutes, 20 seconds on average. Our post office is small and customer patience is limited, so queue length is limited to 5 customers.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"We have provided 10% extra capacity, so our expectation is that there should not be too many customers discouraged for long waiting times or for full queues.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"(Image: post office)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Let's do a process-based simulation using Simulate. We need","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"a source: all the people, providing an unlimited supply for customers,\ncustomers with their demands and their limited patience,\na queue and\nour good old clerk.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"First we must load the needed modules, describe a customer and define some helper functions:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"using Simulate, Random, Distributions, DataFrames\n\nmutable struct Customer\n    id::Int64\n    arrival::Float64\n    request::Int64\n\n    Customer(n::Int64, arrival::Float64) = new(n, arrival, rand(DiscreteUniform(1, 5)))\nend\n\nfull(q::Channel) = length(q.data) >= q.sz_max\nlogevent(nr, queue::Channel, info::AbstractString, wt::Number) =\n    push!(df, (round(τ(), digits=2), nr, length(queue.data), info, wt))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"logevent (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Then we define functions for our processes: people and clerk.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"function people(output::Channel, β::Float64)\n    i = 1\n    while true\n        Δt = rand(Exponential(β))\n        delay!(Δt)\n        if !full(output)\n            put!(output, Customer(i, τ()))\n            logevent(i, output, \"enqueues\", 0)\n         else\n            logevent(i, output, \"leaves - queue is full!\", -1)\n        end\n        i += 1\n    end\nend\n\nfunction clerk(input::Channel)\n    cust = take!(input)\n    Δt = cust.request + randn()*0.2\n    logevent(cust.id, input, \"now being served\", τ() - cust.arrival)\n    delay!(Δt)\n    logevent(cust.id, input, \"leaves\", τ() - cust.arrival)\nend","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"clerk (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Then we have to create a logging table, register and startup the processes:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"reset!(𝐶)  # for repeated runs it is easier if we reset our central clock here\nRandom.seed!(2019)  # seed random number generator for reproducibility\nqueue = Channel(5)  # thus we determine the max size of the queue\n\ndf = DataFrame(time=Float64[], cust=Int[], qlen=Int64[], status=String[], wtime=Float64[])\n\nprocess!(𝐶, SimProcess(1, people, queue, 3.333)) # register the functions as processes\nprocess!(𝐶, SimProcess(2, clerk, queue))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"2","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Then we can simply run the simulation. We assume our time unit being minutes, so we run for 600 units:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"println(run!(𝐶, 600))\nprintln(\"``(length(queue.data)) customers yet in queue\")","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"run! finished with 338 clock events, 0 sample steps, simulation time: 600.0\n0 customers yet in queue","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Our table has registered it all:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"df","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 1.2 1 1 enqueues 0.0\n2 1.2 1 0 now being served 0.0\n3 5.46 2 1 enqueues 0.0\n4 5.5 3 2 enqueues 0.0\n5 6.19 1 2 leaves 4.99532\n6 6.19 2 1 now being served 0.737497\n7 7.99 4 2 enqueues 0.0\n8 8.81 2 2 leaves 3.35581\n9 8.81 3 1 now being served 3.30971\n10 12.33 5 2 enqueues 0.0\n11 12.98 3 2 leaves 7.4733\n12 12.98 4 1 now being served 4.98585\n13 13.73 4 1 leaves 5.74268\n14 13.73 5 0 now being served 1.39837\n15 15.72 6 1 enqueues 0.0\n16 17.12 7 2 enqueues 0.0\n17 17.73 5 2 leaves 5.3967\n18 17.73 6 1 now being served 2.00988\n19 20.0 8 2 enqueues 0.0\n20 20.76 9 3 enqueues 0.0\n21 23.26 6 3 leaves 7.53774\n22 23.26 7 2 now being served 6.13554\n23 25.43 10 3 enqueues 0.0\n24 26.0 11 4 enqueues 0.0\n25 26.35 7 4 leaves 9.22525\n26 26.35 8 3 now being served 6.34474\n27 27.49 12 4 enqueues 0.0\n28 27.64 8 4 leaves 7.63665\n29 27.64 9 3 now being served 6.88549\n30 29.06 13 4 enqueues 0.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"last(df, 5)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 589.1 171 1 enqueues 0.0\n2 589.1 171 0 now being served 0.0\n3 593.77 171 0 leaves 4.67801\n4 598.01 172 1 enqueues 0.0\n5 598.01 172 0 now being served 0.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"describe(df[df[!, :wtime] .> 0, :wtime])","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Summary Stats:\nLength:         302\nMissing Count:  0\nMean:           7.486712\nMinimum:        0.009196\n1st Quartile:   3.866847\nMedian:         6.409644\n3rd Quartile:   10.541481\nMaximum:        23.268310\nType:           Float64","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"In 600 minutes simulation time, we registered 172 customers and 505 status changes. The mean and median waiting times were around 7 minutes.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"by(df, :status, df -> size(df, 1))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"no status x1\n1 enqueues 167\n2 now being served 167\n3 leaves 166\n4 leaves - queue is full! 5","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Of the 172 customers, 167 of them participated in the whole process and were served, but 5 left beforehand because the queue was full:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"df[df.wtime .< 0,:]","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"no time cust qlen status wtime\n1 45.32 19 5 leaves - queue is full! -1.0\n2 249.11 66 5 leaves - queue is full! -1.0\n3 270.04 74 5 leaves - queue is full! -1.0\n4 380.39 106 5 leaves - queue is full! -1.0\n5 382.02 107 5 leaves - queue is full! -1.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"using PyPlot\nstep(df.time, df.wtime)\nstep(df.time, df.qlen)\naxhline(y=0, color=\"k\")\ngrid()\nxlabel(\"time [min]\")\nylabel(\"wait time [min], queue length\")\ntitle(\"Waiting Time in the Post Office\")\nlegend([\"wait_time\", \"queue_len\"]);","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"(Image: png)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Many customers had waiting times of more than 10, 15 up to even more than 20 minutes. The negative waiting times were the 5 customers, which left because the queue was full.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"So many customers will remain angry. If this is the situation all days, our post office will have an evil reputation. What should we do?","category":"page"},{"location":"examples/postoffice/postoffice/#Conclusion-1","page":"Post Office","title":"Conclusion","text":"","category":"section"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Even if our process runs within predetermined bounds (queue length, customer wishes …), it seems to fluctuate wildly and to produce unpredicted effects. This is due to variation in arrivals, in demands and in serving time on system performance. In this case 10% extra capacity is not enough to provide enough buffer for variation and for customer service – even if our post clerk is the most willing person.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"Even for such a simple everyday system, we cannot say beforehand – without reality check – which throughput, waiting times, mean queue length, capacity utilization or customer satisfaction will emerge. Even more so for more complicated systems in production, service, projects and supply chains with multiple dependencies.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"Post Office","title":"Post Office","text":"If we had known the situation beforehand, we could have provided standby for our clerk or install an automatic stamp dispenser for cutting shorter tasks … We should have done a simulation before …","category":"page"},{"location":"news/#News-in-v0.3.0-1","page":"News","title":"News in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"CurrentModule = Simulate","category":"page"},{"location":"news/#","page":"News","title":"News","text":"v0.3.0 is a significant improvement over 0.2.0 with a name change, multithreading, resource handling and a streamlined documentation.","category":"page"},{"location":"news/#breaking-name-changes-1","page":"News","title":"breaking name changes","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"following the advice on discourse and in issue #13 Simulate.jl   gets renamed to DiscreteEvents.jl. Github maintains and forwards the links.\nthere are further renamings to make the API more consistent:\nSimfunction → fun, SF is no longer defined,\nSimProcess → Prc, SP is no longer defined,\nSimEvent → DiscreteEvent,\nSimCond → DiscreteCond,\nsample! → periodic!, was a name collision with Distributions.jl.","category":"page"},{"location":"news/#New-functionality-in-v0.3.0-1","page":"News","title":"New functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Action is introduced as synonym for Union{Expr,Function,Tuple},\nperiodic! takes now an Action as argument,\nArguments to fun can now be given also as symbols, expressions or as other funs. They get evaluated at event time before being passed to the event function,\nSimulate.version gives now the package version,\nSimulate.jl is now much faster due to optimizations,","category":"page"},{"location":"news/#Multithreading-(still-in-the-making)-1","page":"News","title":"Multithreading (still in the making)","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"The data structure of Clock has been changed, it now has a field ac providing channels to parallel clocks,  \nPClock sets up a clock with parallel active clocks on each available thread,\nwith pclock all parallel clocks can be accessed and referenced,\nprocess! can now start tasks on parallel threads,\nevent! can now schedule events for execution on parallel threads,\nperiodic! can now register sampling functions or expressions to parallel clocks,\nif setup with parallel clocks, Clock becomes the master to drive them and synchronize with them at each Δt timestep,","category":"page"},{"location":"news/#Other-breaking-changes-in-v0.3.0-1","page":"News","title":"Other breaking changes in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"τ as an alias for tau is no longer defined.\nThe macros @tau, @val, @SF, @SP are no longer defined.\nLogging functions have been removed (they were not useful enough).\nA function f given to Prc must now take a Clock-variable as its first argument.\nThe first ::Clock-argument to delay! and wait! and now! can no  longer be omitted. Since the task function has now a Clock-variable available (see above), it must provide it to delay!, wait! and now.\nevent! no longer accepts a Vector as argument.\nClk as alias of 𝐶 is no longer provided.\nevent! now returns nothing.","category":"page"},{"location":"news/#Deprecated-functionality-in-v0.3.0-1","page":"News","title":"Deprecated functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Evaluating expressions or symbols at global scope is much slower than using functions and gives now a one time warning. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"news/#Earlier-releases-1","page":"News","title":"Earlier releases","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Release notes: A look at earlier releases.","category":"page"},{"location":"examples/house_heating/house_heating/#House-heating-1","page":"House heating","title":"House heating","text":"","category":"section"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat is a basic example of this:","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"Heating changes between two states: On and Off.\nA room cools dotQ_c Jh at a certain rate proportional to the difference between room temperature T_r and environment temperature T_e K.\nIt heats dotQ_h Jh at a rate proportional to the temperature difference between temperature of the heating fluid T_h K and room temperature T_r K.\nThe room temperature T_r changes proportional to the difference between heating dotQ_h and cooling dotQ_c.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"begineqnarray\ndotQ_c  =  fracleft(T_r - T_eright)eta R   lefttfracJhright  mathrmwhere R = thermal resistance lefttfracK hJright eta = efficiency  factor le 10\ndotQ_h  =  alpha left(T_h - T_rright)   lefttfracJhright  mathrmwhere alpha = proportionality factor lefttfracJK hright \ndotT_h  =  beta left(dotQ_h - dotQ_cright)  lefttfracKhright  mathrmwhere beta = proportionality factor lefttfracKJright\ndotT_c  =  - beta dotQ_c  lefttfracKhright  mathrmwhen heating is switched off\nendeqnarray","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We assume that","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"the thermostat is set to switch heating on if T_r falls under 20°C and to switch heating off if T_r rises above 23°C,\ntime units are hours,\nthe temperature T_h of the heating fluid is 40°C,\nthe temperature T_e of the environment follows a stochastic process based on a sine function between 8 and 20°C with T_emin at 4am and T_emax at 4pm,\nthe constants have values R = 1times10^-6 leftfracK hJright alpha = 2times 10^6 leftfracJK hright beta = 3times 10^-7 leftfracKJright,\npeople entering the room may reduce insulation efficiency by a factor etale10 to R,\nthe room temperature is initially T_r0 = 20 C and\nthe heater is off.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"First we setup the physical model:","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"using Simulate, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst α = 2e6     # represents thermal conductivity and capacity of the air\nconst β = 3e-7    # represents mass of the air and heat capacity\nη = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false\n\nΔte(t, t1, t2) = cos((t-10)*π/12) * (t2-t1)/2  # change of a sinusoidal Te\n\nfunction Δtr(Tr, Te, heating)                  \n    Δqc = (Tr - Te)/(R * η)                    # cooling rate\n    Δqh = heating ? α * (Th - Tr) : 0          # heating rate\n    return β * (Δqh - Δqc)                     # change in room temperature\nend","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"Δtr (generic function with 1 method)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We now setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"reset!(𝐶)                                      # reset the clock\nrng = MersenneTwister(122)                     # seed the random number generator\nΔt = 1//60                                     # update every minute\nTe = 11                                        # start value for environment temperature\nTr = 20                                        # start value for room temperature\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)               # change the temperatures\n    global Te += Δte(tau(), t1, t2) * 2π/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Δtr(Tr, Te, heating) * Δt\n    push!(df, (tau(), Tr, Te, Int(heating)) )       # append stats to the table\nend\n\nfunction switch(t1=20, t2=23)                       # simulate the thermostat\n    if Tr ≥ t2\n        global heating = false\n        event!(SF(switch, t1, t2), @val :Tr :≤ t1)  # setup a conditional event\n    elseif Tr ≤ t1\n        global heating = true\n        event!(SF(switch, t1, t2), @val :Tr :≥ t2)  # setup a conditional event\n    end\nend\n\nSimulate.sample!(SF(setTemperatures), Δt)           # setup sampling\nswitch()                                            # start the thermostat\n\n@time run!(𝐶, 24)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"In a living room the thermal resistance is repeatedly diminished if people enter the room or open windows.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am\n    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time\n    while tau() < sleeptime\n        global η = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global η = 1.0                       # close it again\n        delay!(rand())\n    end\nend\n\nreset!(𝐶)                                    # reset the clock\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(SP(i, people), 1)               # run process only once\nend\nSimulate.sample!(SF(setTemperatures), Δt)    # set sampling function\nswitch()                                     # start the thermostat\n\n@time run!(𝐶, 24)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"examples/dicegame/dicegame/#Goldratt's-Dice-Game-1","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Goldratt's Dice Game from his business novel \"The Goal\" is a classical illustration that dependencies and statistical fluctuations diminish the throughput through a system.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Alex Rogo, the hero of the novel plays a game with five boys:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"While they go get the others, I figure out the details. The system I've set up is intended to \"process\" matches. It does this by moving a quantity of match sticks out of their box, and through each of the bowls in succession. The dice determine how many matches can be moved from one bowl to the next. The dice represent the capacity of each resource, each bowl; the set of bowls are my dependent events, my stages of production. Each has exactly the same capacity as the others, but its actual yield will fluctuate somewhat.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"In order to keep those fluctuations minimal, however, I decide to use only one of the dice. This allows the fluctuations to range from one to six. So from the first bowl, I can move to the next bowls in line any quantity of matches ranging from a minimum of one to a maximum of six.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Throughput in this system is the speed at which matches come out of the last bowl, Inventory consists of the total number of matches in all of the bowls at any time. And I'm going to assume that market demand is exactly equal to the average number of matches that the system can process. Production capacity of each resource and market demand are perfectly in balance. So that means I now have a model of a perfectly balanced manufacturing plant.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Five of the boys decide to play. Besides Dave, there are Andy, Ben, Chuck, and Evan. Each of them sits behind one of the bowls. I find some paper and a pencil to record what happens. Then I explain what they're supposed to do.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"\"The idea is to move as many matches as you can from your bowl to the bowl on your right. When it's your turn, you roll the die, and the number that comes up is the number of matches you can move. Got it?\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"They all nod. \"But you can only move as many matches as you've got in your bowl. So if you roll a five and you only have two matches in your bowl, then you can only move two matches. And if it comes to your turn and you don't have any matches, then naturally you can't move any.\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Eliyahu M Goldratt: The Goal.– 3rd ed, p. 105","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then Rogo explains to the boys that with the die on average they should pass 3.5 matches through the system, so after twenty cycles they should have got an output of seventy.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: The Dice Game)","category":"page"},{"location":"examples/dicegame/dicegame/#An-assembly-line-1","page":"Goldratt's Dice Game","title":"An assembly line","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As Goldratt described it, the game is done in a fixed cycle – no asynchronism here and no need for a discrete-event-simulation. But more realistically it could be seen as an assembly line with buffers between the five workers:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: assembly line)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The workers take on average 3.5 time units for processing an item and they are admonished to work as fast as possible. To implement it, we need some data structure for workers …","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Simulate, Distributions, DataFrames, Random\n\nmutable struct Worker\n    nr::Int64              # worker number\n    clk::Clock\n    input::Channel  \n    output::Channel\n    dist::Distribution     # distribution of processing time\n    retard::Float64        # worker retard factor, 1: no retardation, >1: retardation\n    done::Int64            # number of finished items\n\n    Worker(nr, clk, input, output, dist, perform) = new(nr, clk, input, output, dist, 1/perform, 0)\nend","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"… and a function representing their operation. The buffers are represented by channels. Then we build the system by creating workers and connecting them by channels. We start the work processes with their respective data and run the simulation.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"stats(t::Float64, nr::Int64, len::Int64) = push!(df, (t, nr, len))  ## write buffersize to dataframe\n\nfunction work(w::Worker, stat::Bool)\n    job = take!(w.input)\n    stat ? stats(tau(w.clk), w.nr, length(w.input.data)) : nothing\n    delay!(w.clk, rand(w.dist) * w.retard)\n    put!(w.output, job)\n    stat ? stats(tau(w.clk), w.nr+1, length(w.output.data)) : nothing\n    w.done += 1\nend\n\nreset!(𝐶)\nRandom.seed!(1234)                 # seed random number generator\ndf = DataFrame(time=Float64[], channel=Int[], length=Int[])\n\nC = [Channel{Int64}(Inf) for i in 1:6]    # create 6 channels\nj = reverse(Array(1:8))\nfor i in 5:-1:2                    # seed channels 2:5 each with 2 inventory items\n    put!(C[i], j[(i-1)*2])\n    put!(C[i], j[(i-1)*2-1])\nend\nfor i in 9:1000                    # put other 992 jobs into channel 1\n    put!(C[1], i)\nend\n\nW = [Worker(i, 𝐶, C[i], C[i+1], Uniform(0.5, 6.5), 1.0) for i in 1:5]\nfor i in 1:5\n    process!(SP(i, work, W[i], true))\nend\n@time run!(𝐶, 1000)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"0.261483 seconds (115.06 k allocations: 4.404 MiB)\n\"run! finished with 1390 clock events, 0 sample steps, simulation time: 1000.0\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"length(C[6].data)                    # how much got produced?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"272","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000/272","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"3.676470588235294","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"After running for 1000 time units, we got 272 finished items in channel 6, meaning an average cycle time of 3.68, not 3.5 as expected. The expected throughput would have been 286 units, so the line produced only 95% of that, even under \"perfect\" conditions like unlimited supply, an in-process inventory to start with, infinite buffer sizes, a perfectly balanced line and equally performing workers without breaks … What happened?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Plots\n\nfunction inventory_plot(n::Int64, title)\n    for i ∈ 2:n\n        d = df[df.channel .== i, :]\n        doplot = i == 2 ? plot : plot!\n        doplot(d.time, d.length, label=\"channel$i\")\n    end\n    title!(title)\n    xlabel!(\"time\")\n    ylabel!(\"Inventory\")\nend\ninventory_plot(5, \"In-Process-Inventory of Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We see that statistical fluctuations in processing times (the dice!) lead to wildly fluctuating buffers, overproduction of worker 1 (look at channel 2) and also to starvation of other workers down the line when their input buffers are empty. Let's calculate the inventory of unfinished goods in the line at the end of the simulation run:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000-length(C[1].data)-length(C[6].data)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"26","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This gives an average of 6.5 inventory items in channels 2-5. But as we see in the plot, some channels are often empty, leading to some starvation.","category":"page"},{"location":"examples/dicegame/dicegame/#Parametrizing-the-model-1","page":"Goldratt's Dice Game","title":"Parametrizing the model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For further investigations we parametrize our model. This is not easily done in graphically oriented simulators, but we can do it with Simulate.jl.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As parameters we take:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: the length of the line (number of workers)\nmw: max WIP-buffer sizes (WIP is work in progress),\nvp: variation in processing times from item to item and,\nvw: variation between worker performance,\nd: the duration of the simulation run","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We give each simulation its own clock and channels variables so that it can be run in parallel on different threads.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"function dice_line( n::Int64, mw::Int64,\n                    vp::Distribution, vw::Distribution;\n                    d=1000, seed=1234, jobs=1000, stat::Bool=true )\n    clk = Clock()\n    Random.seed!(seed)                  # seed random number generator\n    stat ? ( global df = DataFrame(time=Float64[], channel=Int[], length=Int[]) ) : nothing\n    C = [Channel{Int64}(mw) for i in 1:n+1] # create n+1 channels with given buffer sizes\n    C[1] = Channel{Int64}(Inf)                 # unlimited sizes for channels 1 and n+1\n    C[n+1] = Channel{Int64}(Inf)\n    j = reverse(Array(1:(n-1)*2))\n    for i in n:-1:2                     # seed channels 2:(n-1) each with 2 inventory items\n        C[i].sz_max > 0 ? put!(C[i], j[(i-1)*2]) : nothing\n        C[i].sz_max > 1 ? put!(C[i], j[(i-1)*2-1]) : nothing\n    end\n    for i in ((n-1)*2+1):jobs           # put other jobs into channel 1\n        put!(C[1], i)\n    end\n\n    wp = rand(vw, n)                    # calculate worker performance\n    W = [Worker(i, clk, C[i], C[i+1], vp, wp[i]) for i in 1:n]\n    for i in 1:n\n        process!(clk, SP(i, work, W[i], stat))\n    end\n    info = run!(clk, d)\n    return (info, clk.evcount, length(C[end].data))\nend","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"dice_line (generic function with 1 method)","category":"page"},{"location":"examples/dicegame/dicegame/#Kanban-…-1","page":"Goldratt's Dice Game","title":"Kanban …","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Against too much inventory we have Kanban. So let's introduce maximum buffer sizes of 5 items. We have yet our five perfect workers without varying performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Printf\ninfo, ev, res = dice_line(5, 5, Uniform(0.5, 6.5), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"%5.2f%s capacity utilization\", 3.5*res/10, \"%\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"run! finished with 1341 clock events, 0 sample steps, simulation time: 1000.0\n266 items produced!\n93.10% capacity utilization","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Uups! We throttled our system further, to an output of 266.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"But we got much less inventory in the system. The throttling occurs because with Kanban in-process-inventories get more often to zero. Seemingly Kanban is no solution for our throughput problem but constrains the system further. With Kanban we have reduced unpredictability and instability in inventory.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Let's pause a moment to look at what we have here: we got a small model with which we can simulate and analyze the impact of dependencies (line length and buffer sizes) and statistical fluctuations (in processing time and worker performance) on simple assembly lines like there are thousands in industry. This is no minor achievement.","category":"page"},{"location":"examples/dicegame/dicegame/#Investigating-assembly-lines-1","page":"Goldratt's Dice Game","title":"Investigating assembly lines","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"With the parametrized model we can do some investigations into the behaviour of assembly lines.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For that we take first some further simplification steps:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We normalize the model by assuming a mean processing time of 1.\nWe choose a gamma distribution as more realistic for processing times than the uniform distribution, we used until now following Goldratt's example:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsPlots, LaTeXStrings\n\nfor i in [2,3,5,10,15,20]\n    doplot = i == 2 ? plot : plot!\n    doplot(Gamma(i, 1/i), label=latexstring(\"a=$i, \\\\theta=$(round(1/i, digits=2))\"))\nend\nxlabel!(L\"\\mathsf{processing\\, time}\")\nylabel!(L\"\\mathsf{probability\\, density}\")\ntitle!(latexstring(\"\\\\mathsf{Gamma\\\\, distribution,\\\\,} \\\\mu=1\"))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@time info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"y = %5.3f [1/t]\", res/1000)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1.060803 seconds (1.03 M allocations: 46.115 MiB, 1.03% gc time)\nrun! finished with 4847 clock events, 0 sample steps, simulation time: 1000.0\n966 items produced!\ny = 0.966 [1/t]","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Before we go deeper into parameters, we have to check how much path dependence and statistical fluctuations vary the outcome. Therefore we repeat the simulation 30 times with different random number seeds and analyze the distribution of the outcome. As outcome we choose the throughput rate y [1/t] which is also an indicator for line performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Random.seed!(1234)\ns = abs.(rand(Int, 30))\ntc = ones(30)\nThreads.@threads for i = 1:30\n    info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0), seed=s[i], jobs=1200, stat=false)\n    tc[i] = res*0.001\nend\nys = (μ=mean(tc), σ=std(tc))\n@printf(\"μ: %5.3f, σ: %5.3f, LCL: %5.3f, UCL: %5.3f\\n\", ys.μ, ys.σ, ys.μ-3ys.σ, ys.μ+3ys.σ)\nplot(1:30, tc, title=\"throughput rate of various runs of dice line\", xlabel=\"runs\",\n    ylabel=\"y [1/t]\", legend=:none, lw=2)\nhline!([ys.μ, ys.μ-3ys.σ, ys.μ+3ys.σ], lc=:red)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"μ: 0.967, σ: 0.006, LCL: 0.950, UCL: 0.984","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#Experimental-design-1","page":"Goldratt's Dice Game","title":"Experimental design","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Our response variable y seems to be under statistical control and its fluctuation is of the same order as the effects we are after. But with an experimental design those fluctuations should cancel out. We setup it up with:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: number of workers, line length,\nb: buffersize between workers,\na: shape parameter of gamma distribution of processing times (bigger a means less variation),\nσ: standard deviation of performance variation between workers.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsModels, ExperimentalDesign\n\nn = vcat(5:10,12:2:20)\nb = 1:10\na = vcat(2,3,5:5:20)\nσ = LinRange(0,0.1,5)\n\nD = FullFactorial((n=n, b=b, a=a, σ=σ), @formula(y ~ n + b + a + σ), explicit = true)\nsize(D.matrix)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(3300, 4)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We got a design matrix with 3300 rows for 3300 simulations! Let's do something else while the computer works:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"y = zeros(3300)\nevents = 0\nt = @elapsed begin\n    Threads.@threads for i = 1:3300\n        p = Tuple(D.matrix[i, :])\n        info, ev, res = dice_line(p[1], p[2], Gamma(p[3], 1/p[3]), Normal(1, p[4]), jobs=1200, stat=false )\n        y[i] = res*0.001\n        global events += ev\n    end\nend\n@printf(\"Time elapsed: %5.2f minutes, %d events on %d threads\", t/60, events, Threads.nthreads())","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Time elapsed:  4.02 minutes, 33513556 events on 4 threads","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"It takes 4 minutes on 4 threads of a 2013 MacBook Pro and over 33times 10^6 events.","category":"page"},{"location":"examples/dicegame/dicegame/#Data-analysis-1","page":"Goldratt's Dice Game","title":"Data analysis","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We put together a results table and do some exploratory data analysis:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"res = D.matrix\nres.y = y\ndescribe(y)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Summary Stats:\nLength:         3300\nMissing Count:  0\nMean:           0.892569\nMinimum:        0.633000\n1st Quartile:   0.863750\nMedian:         0.904000\n3rd Quartile:   0.937000\nMaximum:        0.986000\nType:           Float64","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The performance of our simulated assembly lines varies between 0.637 and 0.986, which is a huge difference: The worst result is 35.8% below the best one!","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"vcat(res[y .== maximum(y), :], res[y .== minimum(y), :])","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"no n b a σ y\n1 6 7 20 0.0 0.986\n2 5 10 20 0.0 0.986\n3 18 1 2 0.05 0.633","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The best performance is with the shortest lines, big buffer sizes, small variation in processing times and no variation in performance between workers. But this is just common sense. The worst performance is with a long line, minimum buffers and maximum variation in processing times and in performance between workers. But how big are the effects?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:n, :y, title=\"line performance vs line length\", xlabel=\"n\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:n, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:b, :y, title=\"line performance vs buffer size\", xlabel=\"b\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:b, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:a, :y, title=\"line performance vs processing time variation\", xlabel=\"a (bigger a: less variation)\",\n    ylabel=\"y [1/t]\", marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:a, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = Int.(round.(res.σ*40))\n@df res dotplot(x, :y, title=\"line performance vs worker performance variation\", xlabel=L\"\\sigma\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(x, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))\nxticks!(collect(0:4), string.(round.(σ, digits=3)))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer sizes and variation in processing time clearly have nonlinear effects while line length and performance variation between workers seem to have more linear ones. Small buffers and variation in processing time constrain the line the most and also are responsible for the worst performances. There seems to be also an interaction between those major two factors.","category":"page"},{"location":"examples/dicegame/dicegame/#Statistical-model-1","page":"Goldratt's Dice Game","title":"Statistical model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We fit a linear model to the results and account for the nonlinearities with logarithmic terms:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using GLM\n\nols = lm(@formula(y ~ 1 + n + log(1+b) + log(a) + σ), res)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + σ\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────────────────\n                Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n───────────────────────────────────────────────────────────────────────────────────\n(Intercept)   0.738014    0.00235126   313.881     <1e-99   0.733404     0.742624  \nn            -0.00154928  9.81169e-5   -15.7902    <1e-53  -0.00174166  -0.00135691\nlog(1 + b)    0.0576481   0.000897264   64.2488    <1e-99   0.0558889    0.0594074\nlog(a)        0.050857    0.000564214   90.1378    <1e-99   0.0497508    0.0519633\nσ            -0.508588    0.0133498    -38.097     <1e-99  -0.534763    -0.482413  \n───────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"All parameters are highly significant. We find then - as expected - that the b&a-interaction between buffer size and variation in processing times is highly significant too:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"ols2 = lm(@formula(y ~ 1 + n + log(1+b)*log(a) + σ), res)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + σ + :(log(1 + b)) & :(log(a))\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────────────────────────\n                        Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)           0.5992      0.00314399   190.586     <1e-99   0.593035     0.605364  \nn                    -0.00154928  7.21745e-5   -21.4658    <1e-95  -0.00169079  -0.00140777\nlog(1 + b)            0.13696     0.00163887    83.5699    <1e-99   0.133747     0.140173  \nlog(a)                0.123869    0.00144194    85.9039    <1e-99   0.121041     0.126696  \nσ                    -0.508588    0.00982009   -51.7906    <1e-99  -0.527842    -0.489334  \nlog(1 + b) & log(a)  -0.0417155   0.000788995  -52.8716    <1e-99  -0.0432624   -0.0401685\n───────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then we can analyze the effects of the four parameters on line performance:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(1,10,50)\nfor i in reverse(a)\n    _n = fill(mean(n), length(x))\n    _a = fill(i, length(x))\n    _σ = fill(mean(σ), length(x))\n    tmp = DataFrame(n=_n, b=x, a=_a, σ=_σ)\n    _y = predict(ols2, tmp)\n    doplot = i == 20 ? plot : plot!\n    doplot(x, _y, label=\"a=$i\")\nend\ntitle!(\"Effects of buffer size and processing time variation\", legend=:bottomright)\nxlabel!(\"b (buffer size)\")\nylabel!(\"y [1/t]\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer size and processing time variation have nonlinear effects and may account together for 26% line performance losses. This shows how important it is to increase buffer sizes with larger variation in processing times (smaller a). Only with small variation one can reduce buffers without loosing much performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(5, 20, 50)\ntmp = DataFrame(n=x, b=fill(mean(b), length(x)), a=fill(mean(a), length(x)),\n    σ=fill(mean(σ), length(x)))\nplot(x, predict(ols2, tmp), title=\"Effect of line length\", xlabel=\"n (line length)\",\n    ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This may account for 3% performance losses.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(0,0.1,50)\ntmp = DataFrame(n=fill(mean(n), length(x)), b=fill(mean(b), length(x)),\n    a=fill(mean(a), length(x)), σ=x)\nplot(x, predict(ols2, tmp), title=\"Effect of performance variation between workers\",\n    xlabel=L\"\\sigma\", ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Variation in performance between workers may diminish line throughput by other 5%.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The four effects combined can account for 34% performance losses from best to worst. This is most of the 35.8% we found above. The rest is mostly statistical fluctuations.","category":"page"},{"location":"examples/dicegame/dicegame/#Final-remark-1","page":"Goldratt's Dice Game","title":"Final remark","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Starting from a simple game and with only a quite small simulation model we could come to conclusions with a wide applicability for assembly lines. The performance differences in assembly lines are realistic – I have seen them over and over in industry. And we didn't yet account for failures or supply shortfalls. The unawareness of those simple factors costs manufacturing industry billions.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The most interesting thing to note here is, that from seemingly quite unpredictable behaviour – look at the inventory chart of the beginning – emerge some quite predictable characteristics out of multiple discrete event simulations with parameter variation combined with some not too sophisticated statistics.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We could not have done those experiments and analyses with real lines as it is possible with simulations on a modern computer with Julia and Simulate.jl.","category":"page"},{"location":"performance/par_perf/#Parallel-performance-1","page":"Parallel performance","title":"Parallel performance","text":"","category":"section"},{"location":"manual/intro/#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Get an overview and learn the basics.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides 1) a clock with a virtual simulation time and 2) the ability to schedule Julia functions and expressions as events on the clock's timeline or 3) run them as processes synchronizing with the clock. The clock can 4) invoke sampling functions or expressions continuously at a given rate.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nSimulate.jl doesn't have a special concept for shared resources since this can be expressed in native Julia via tokens in a Channel.","category":"page"},{"location":"manual/intro/#A-first-example-1","page":"Getting started","title":"A first example","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"A simple server takes something (a resource) from its input and puts it out modified after some time. We implement the server's activity in a function, create input and output channels and some \"foo\" and \"bar\" processes interacting on them:  ","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"using Simulate, Printf, Random\n\nfunction simple(c::Clock, input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something from the input\n    now!(c, fun(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(c), name, id, token)))\n    d = delay!(c, rand())        # after a delay\n    put!(output, op(token, id))  # put it out with some op applied\nend\n\nclk = Clock()      # create a clock\nRandom.seed!(123)  # seed the random number generator\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 processes\n    process!(clk, Prc(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(clk, Prc(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nput!(ch1, 1)    # put first token into channel 1\nyield()         # let the first task take it\nrun!(clk, 10)   # and run for 10 time units","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"We then run it:","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> include(\"docs/examples/channels.jl\")\n 0.00: foo 1 took token 1\n 0.77: bar 2 took token 2\n 1.71: foo 3 took token 4\n 2.38: bar 4 took token 7\n 2.78: foo 5 took token 28\n ...\n ...\n 7.91: bar 2 took token 631017\n 8.36: foo 3 took token 1262034\n 8.94: bar 4 took token 1262037\n 9.20: foo 5 took token 5048148\n 9.91: bar 6 took token 5048153\n\"run! finished with 43 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#Types-and-functions-1","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"𝐶, reset!, now!, delay!, process!, Prc, run!","category":"page"},{"location":"manual/intro/#Four-building-blocks-1","page":"Getting started","title":"Four building blocks","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides 4 major building blocks for modeling and simulation of discrete event systems:","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"the logical clock gives the simulation time,\nevents are Julia expressions or functions executing at given simulation times or under given conditions,\nprocesses are functions running as tasks and synchronizing with the clock by delaying for a time or waiting for conditions,\ncontinuous sampling is done by invoking given expressions or functions at a given rate on the time line.","category":"page"},{"location":"manual/intro/#the_clock-1","page":"Getting started","title":"The clock","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"The clock is central to any model and simulation, since it establishes the timeline. It does not only provide the time, but contains also the time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Δt. Each simulation can have its own clock.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> c = Clock()                           # create a new clock\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tick() = println(tau(c), \": tick!\")   # define a function printing the clock's time\ntick (generic function with 1 method)\n\njulia> event!(c, fun(tick), every, 1)         # schedule a repeat event on the clock\n0.0\n\njulia> run!(c, 10)                           # run the clock for 10 time units\n0.0: tick!\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 11 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"If you work with only one simulation at a time, you normally use the central clock 𝐶 (\\\\it𝐶+tab):","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nYou definitely need different clock variables if you run multiple simulations on parallel threads. In such cases each simulation should have its own clock. Please look at the dicegame example for that.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> tick() = println(tau(), \": tick!\")         # the tick function now uses central time tau()\ntick (generic function with 1 method)\n\njulia> sample_time!(1)                            # set the sampling rate on the central clock to 1\n1.0\n\njulia> periodic!( fun(tick) );                       # set tick as a sampling function\n\njulia> 𝐶                                          # 𝐶 now has one sampling entry and the sample rate set\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Δt=1.0 , prc:0\n  scheduled ev:0, cev:0, sampl:1\n\njulia> run!(𝐶, 5)                                 # run 𝐶 for 5 time units\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 5.0\"\n\njulia> run!(𝐶, 5)                                 # run it again\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 10.0\"\n\njulia> reset!(𝐶)                                  # reset the clock\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"If Δt = 0, the clock doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nClocks work with a Float64 time and with Unitful.NoUnits but you can set them to work with Unitful.Time units like ms, s, minute, hr. In this case tau returns a time, e.g. 1 s. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.setUnit!(sim::Clock, unit::FreeUnits): set a clock unit.\ntau(sim::Clock).val: return a unitless number for current time.At the moment I don't find it practical to work with units if for example I collect simulation events or variables with their time in a table or do plots. It seems easier not to use them as long you don't need automatic time conversion in your simulation projects.","category":"page"},{"location":"manual/intro/#Types-and-functions-2","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Clock, 𝐶, tau, sample_time!, periodic!, run!, reset!, incr!, sync!, stop!, resume!,  ","category":"page"},{"location":"manual/intro/#event_scheme-1","page":"Getting started","title":"Events","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Julia functions or expressions are scheduled as events on the clock's time line. In order to not be invoked immediately,","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"event functions must be stored in a fun and\nevent expressions must be quoted with :().","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Event functions in a fun can get 1) values, variables or 2) symbols, expressions or even other funs as arguments. The 2nd case arguments are evaluated not till event time before they are passed to the event funtion.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Several functions and expressions can be scheduled as events combined in a tuple.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nEvaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. See Performance. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"manual/intro/#Timed-events-1","page":"Getting started","title":"Timed events","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Timed events with event! schedule functions and expressions to execute at a given time:","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"ev1 = :(println(tau(), \": I'm a quoted expression\"))\nev2 = fun(() -> println(tau(), \": I'm a fun\"))\nev3 = fun(println, fun(tau), \": now a is \", :a)  # various arguments to a fun\n\na = 1\nevent!(ev1, at, 2)                             # schedule events at 2, 3, 4, 6, 8\nevent!(ev3, at, 3)\nevent!(:(a += 5), at, 4)\nevent!(ev3, at, 6)\nevent!(ev1, after, 8)                          # schedule an event after 8\nevent!(ev2, every, 5)                          # schedule an event every 5","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                             # run\n0.0: I'm a fun\n2.0: I'm a quoted expression\n3.0: now a is 1\n5.0: I'm a fun\n6.0: now a is 6\n8.0: I'm a quoted expression\n10.0: I'm a fun\n\"run! finished with 8 clock events, 0 sample steps, simulation time: 10.0\"\n\njulia> event!((ev1, ev2), after, 2)            # schedule both ev1 and ev2 as one event\n12.0\n\njulia> run!(𝐶, 5)                              # run\n12.0: I'm a quoted expression\n12.0: I'm a fun\n15.0: I'm a fun\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 15.0\"","category":"page"},{"location":"manual/intro/#Conditional-events-1","page":"Getting started","title":"Conditional events","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Conditional events  with (event! execute under given conditions. Conditions can be formulated as logical expression or function or combinations of them.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"reset!(𝐶)                                       # reset the clock\ny = 0                                           # create a variable y\nperiodic!( fun(() -> global y = tau()/2) );        # a sampling function\nevent!( fun(()->println(tau(),\": now y ≥ π\") ), (@val :y :≥ π) ) # a conditional event","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                              # run\n6.28999999999991: now y ≥ π\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> 2π                                       # exact value\n6.283185307179586","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"reset!(𝐶)\nperiodic!( fun(()-> global y=sin(@tau)) );         # sample a sine function on y\nevent!(fun(()->println(tau(),\": now y ≥ 1/2\")), ((@val :y :≥ 1/2),(@tau :≥ 5))) # two conditions","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)\n6.809999999999899: now y ≥ 1/2\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> asin(0.5) + 2π                           # exact value\n6.806784082777885","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"It can be seen: (1) the sample rate has some uncertainty in detecting events and (2) conditional events are triggered only once. If there is no sample rate set, a conditional event sets one up and deletes it again after it becomes true.","category":"page"},{"location":"manual/intro/#Types-and-functions-3","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"tau, fun, event!, run!, reset!, periodic!","category":"page"},{"location":"manual/intro/#process_scheme-1","page":"Getting started","title":"Processes","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Functions can be started as asynchronous tasks or coroutines, which can coordinate with the clock and events by delaying for some time or waiting for conditions, taking inputs from events or other tasks, triggering events or starting other tasks …","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"From a modeling or simulation standpoint we call such tasks processes, because they can represent some ongoing activity in nature. Tasks seen as processes are a powerful modeling device, but you need to take care that","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"they give back control to the clock and other such processes by calling delays or conditional waits or requesting resources (and thus implicitly waiting for them to become available) and\nthey transfer critical operations to the clock in order to not get out of sync with simulation time.","category":"page"},{"location":"manual/intro/#Create-and-start-a-process-1","page":"Getting started","title":"Create and start a process","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Prc prepares a function for running as a process and assignes it an id.  Then process! registers it to the clock and starts it as a process in a loop. You can define how many loops the function should persist, but the default is Inf. You can create as many instances of a function as processes as you like.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"function doit(n)                                # create a function doit\n    i = 1\n    while i ≤ n\n        delay!(rand()*2)                        # delay for some time\n        now!(fun(println, @sprintf(\"%5.2f: finished %d\", tau(), i)))  # print\n        i += 1\n    end\nend\n\nRandom.seed!(1234);        \nreset!(𝐶)                                       # reset the central clock\nprocess!(Prc(1, doit, 5), 1)                     # create, register and start doit(5) as a process, id=1, runs only once","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 5)                               # run for 5 time units\n 1.18: finished 1\n 2.72: finished 2\n 3.85: finished 3\n 4.77: finished 4\n\"run! finished with 8 clock events, 0 sample steps, simulation time: 5.0\"\n\njulia> run!(𝐶, 2)                               # it is not yet finished, run 2 more\n 6.36: finished 5\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 7.0\"\n\n\njulia> run!(𝐶, 3)                               # doit(5) is done with 5, nothing happens anymore\n\"run! finished with 0 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#Delay,-wait,-take-and-put-1","page":"Getting started","title":"Delay, wait, take and put","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"In order to synchronize with the clock, a process can","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"get the simulation time tau(),\ndelay!, which suspends it until after the given time t or\nwait! for a condition. This creates a conditional event! which reactivates the process when the conditions become true.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Processes can also interact directly e.g. via channels with take! and put!. This also may suspend them until there is something to take from a channel or until they are allowed to put something into it.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"function watchdog(name)\n    delay!(until, 6 + rand())                    # delay until\n    now!(fun(println, @sprintf(\"%5.2f %s: yawn!, bark!, yawn!\", tau(), name)))\n    wait!(((@val :hunger :≥ 7),(@tau :≥ 6.5)))   # conditional wait\n    while 5 ≤ hunger ≤ 10\n        now!(fun(println, @sprintf(\"%5.2f %s: %s\", tau(), name, repeat(\"wow \", Int(trunc(hunger))))))\n        delay!(rand()/2)                         # simple delay\n        if scuff\n            now!(fun(println, @sprintf(\"%5.2f %s: smack smack smack\", tau(), name)))\n            global hunger = 2\n            global scuff = false\n        end\n    end\n    delay!(rand())                               # simple delay\n    now!(fun(println, @sprintf(\"%5.2f %s: snore ... snore ... snore\", tau(), name)))\nend\n\nhunger = 0\nscuff = false\nreset!(𝐶)\nRandom.seed!(1122)\n\nperiodic!(fun(()-> global hunger += rand()), 0.5)   # a sampling function: increasing hunger\nevent!(fun(()-> global scuff = true ), 7+rand())  # an event: scuff after 7 am\nprocess!(Prc(1, watchdog, \"Snoopy\"), 1)           # create, register and run Snoopy","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)\n 6.24 Snoopy: yawn!, bark!, yawn!\n 6.50 Snoopy: wow wow wow wow wow wow wow wow\n 6.98 Snoopy: wow wow wow wow wow wow wow wow wow\n 7.37 Snoopy: smack smack smack\n 7.38 Snoopy: snore ... snore ... snore\n\"run! finished with 10 clock events, 20 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nyou must not use or invoke operations like delay!, wait!, take! or put! outside of tasks and inside the Main process, because they will suspend it.","category":"page"},{"location":"manual/intro/#IO-operations-1","page":"Getting started","title":"IO-operations","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Tasks must transfer critical IO operations to the clock with a now! call. When tasks invoke IO-operations like printing, reading or writing from or to files, directly, they give control back to the Julia scheduler. While the IO-operation continues the clock may advance with time and the task has got out of sync with simulation time. Processes therefore should enclose their IO-operations in a now! call. This will transfer them for execution to the clock, which must finish them before proceeding any further.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"function bad()                                   # bad: IO-operation DIY\n    delay!(rand()*2)\n    @printf(\"%5.2f: hi, here I am\\n\", tau())\nend\nRandom.seed!(1234);\nreset!(𝐶)                                        # reset the clock\nprocess!(Prc(1, bad), 5)                          # setup a process with 5 cycles","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                               # it runs only once !!!\n 1.18: hi, here I am\n\"run! finished with 1 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"function better()                                # better: let the clock doit for you\n    delay!(rand()*2)\n    now!(fun(println, @sprintf(\"%5.2f: hi, I am fine\", tau())))\nend\nRandom.seed!(1234);\nreset!(𝐶)                                        # reset the clock\nprocess!(Prc(1, better), 5)                       # setup a process with 5 cycles","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                               # it runs all 5 cycles\n 1.18: hi, I am fine\n 2.72: hi, I am fine\n 3.85: hi, I am fine\n 4.77: hi, I am fine\n 6.36: hi, I am fine\n\"run! finished with 10 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"manual/intro/#Types-and-functions-4","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Prc, process!, delay!, wait!, now!, fun, run!, 𝐶, reset!, periodic!, event!","category":"page"},{"location":"manual/intro/#continuous_sampling-1","page":"Getting started","title":"Continuous sampling","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Continuous sampling allows to bring continuous processes or real world data into a simulation or can be used for visualization or logging and collecting statistics.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"If you provide the clock with a time interval Δt, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"sample_time!(Δt): set the clock's sample rate starting from now.\nperiodic!(expr): register a function or expression for sampling. If no sample rate is set, set it implicitly.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nConditions set by conditional event! or by wait! are also evaluated with the sampling rate. But the conditional event disappears after the conditions are met and the sample rate is then canceled if no sampling functions are registered.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"If no sample rate is set, the clock jumps from event to event.","category":"page"},{"location":"manual/intro/#Running-a-simulation-1","page":"Getting started","title":"Running a simulation","text":"","category":"section"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"After you have setup the clock, scheduled events, setup sampling or started processes – as you have seen – you can step or run through a simulation, stop or resume it.","category":"page"},{"location":"manual/intro/#","page":"Getting started","title":"Getting started","text":"run!(clk::Clock, duration::Number): run a simulation for a given duration. Call all scheduled events and sampling actions in that timeframe.\nincr!(clk::Clock): take one simulation step, call the next tick or event.\nstop!(clk::Clock): stop a simulation\nresume!(clk::Clock): resume a halted simulation.","category":"page"},{"location":"examples/singleserver/#Single-server-1","page":"Single server","title":"Single server","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: single server)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Initially there are no jobs in the queue Q and the machine M is idle.\nJobs arrive with an inter-arrival-time t_aand are added to Q.\nIf M is idle, it loads a job, changes to busy and executes the job with service time t_s.\nAfter that it changes to idle and, if Q is not empty, it loads the next job.","category":"page"},{"location":"examples/singleserver/#Implementing-it-1","page":"Single server","title":"Implementing it","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use this simple example for illustration of how it can be modeled, simulated and analyzed using Simulate.jl. First we have to import the necessary modules:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"using Simulate, Random, Distributions, DataFrames, Plots, LaTeXStrings\npyplot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We have to define some data structures, variables and a function for collecting stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"abstract type MState end\n\nstruct Idle <: MState end\nstruct Busy <: MState end\n\nmutable struct Job\n    no::Int64\n    ts::Float64\n    t1::Float64\n    t2::Float64\n    t3::Float64\nend\n\nmutable struct Machine\n    state::MState\n    job\nend\n\nQ = Job[]   # input queue\nS = Job[]   # stock\nM = Machine(Idle(), 0)\ndf = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\ncount = 1\nprinting = true\n\nstats() = push!(df, (tau(), length(Q), M.state == Busy() ? 1 : 0, length(S)))","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can model our system activity-based und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use the arrival-function for modeling arrival rate t_a with an Erlang and service time t_s with a Normal distribution. We determine the capacity of the server with a c variable such that c  1 gives us overcapacity and c = 1 means that mean service time equals mean arrival rate bart_s = bart_a.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function arrive(μ, σ, c)\n    @assert μ ≥ 1 \"μ must be ≥ 1\"\n    ts = rand(Normal(μ, σ))/c\n    job = Job(count, ts, tau(), 0, 0)\n    global count += 1\n    push!(Q, job)\n    ta = rand(Erlang())*μ\n    event!(𝐶, fun(arrive, μ, σ, c), after, ta)  # we schedule the next arrival\n    printing ? println(tau(), \": job $(job.no) has arrived\") : nothing # tau() is the current time\n    if M.state == Idle()\n        load()\n    else\n        stats()\n    end\nend\n\nfunction load()\n    M.state = Busy()\n    M.job = popfirst!(Q)\n    M.job.t2 = tau()\n    event!(𝐶, fun(unload), after, M.job.ts)  # we schedule the unload\n    printing ? println(tau(), \": job $(M.job.no) has been loaded\") : nothing\n    stats()\nend\n\nfunction unload()\n    M.state = Idle()\n    M.job.t3 = tau()\n    push!(S, M.job)\n    printing ? println(tau(), \": job $(M.job.no) has been finished\") : nothing\n    stats()\n    M.job = 0\n    if !isempty(Q)\n        load()\n    end\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We want to collect stats() at a sample rate of 0.1:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"sample_time!(𝐶, 0.1)  # we determine the sample rate\nperiodic!(𝐶, fun(stats));  # we register stats() as sampling function","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and mu = 5, sigma = 15 and c = 1 and let our system run for 30 minutes (let's assume our time unit be minutes):","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Random.seed!(2019)\narrive(5, 1/5, 1)  # we schedule the first event\nrun!(𝐶, 30)        # and run the simulation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This will give us as output:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"0: job 1 has arrived\n0: job 1 has been loaded\n4.947453062901819: job 1 has been finished\n8.515206032139384: job 2 has arrived\n8.515206032139384: job 2 has been loaded\n8.56975795472613: job 3 has arrived\n8.666481204359087: job 4 has arrived\n10.338522593089287: job 5 has arrived\n11.021099411385869: job 6 has arrived\n13.267881315092211: job 7 has arrived\n13.703372376147774: job 2 has been finished\n13.703372376147774: job 3 has been loaded\n18.726550601155594: job 3 has been finished\n18.726550601155594: job 4 has been loaded\n19.55941423914075: job 8 has arrived\n19.58302738045451: job 9 has arrived\n20.543366077813385: job 10 has arrived\n22.752994020639125: job 11 has arrived\n23.563550850400553: job 4 has been finished\n23.563550850400553: job 5 has been loaded\n23.960464112286694: job 12 has arrived\n26.84742108339802: job 13 has arrived\n28.18186102251928: job 5 has been finished\n28.18186102251928: job 6 has been loaded\n\"run! finished with 17 events, simulation time: 30.0\"","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Using our collected data, we can plot the simulation model trajectory:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function trajectory_plot()\n    p1 = plot(df.time, df.buffer, ylabel=\"buffer\", fill=(0,0.1,:blue))\n    p2 = plot(df.time, df.machine, ylabel=\"machine\", fill=(0,0.1,:blue))\n    p3 = plot(df.time, df.finished, xlabel=\"time [min]\", ylabel=\"stock\", fill=(0,0.1,:blue))\n    plot(p1,p2,p3, layout=(3,1), legend=false)\nend\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 1)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 \"minutes\".","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"printing = false\nrun!(𝐶, 970)        # we continue the simulation\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren't very instructive, so let's compare lead time W and number of jobs in the system L = textbuffer_size + textmachine_load:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function WvsL() # get more instructive info from simulation run\n    t = [j.t1 for j ∈ S]\n    W = [j.t3 - j.t1 for j ∈ S]\n    ts = [j.t3 - j.t2 for j ∈ S]\n    subs = [i ∈ t for i ∈ df.time]\n    L = (df.buffer + df.machine)[subs]\n    l = df.machine[subs]\n    DataFrame(time=t, load=l, W=W, L=L, ts=ts)\nend\nd = WvsL()\nplot(d.time, d.W, label=\"W [min]\", xlabel=\"time [min]\", lw=2, legend=:topleft, title=\"L and W over time\")\nplot!(d.time, d.L, label=\"L [jobs]\", lw=2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: L and W over time)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Lead time W and unfinished jobs L are clearly increasing, the system is not stationary and gets jammed over time. Let's collect some stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"collect_stats() =\n    (Lm = mean(d.L), Wm = mean(d.W), η = mean(df.machine), tsm = mean(d.ts))\ncollect_stats()\n(Lm = 16.21105527638191, Wm = 78.8196419189297, η = 0.9778719397363466, tsm = 5.003771234356064)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Server load of overlineη  98 is great, but the mean queue length overlineL of 16 and mean lead time overlineW  79 min are way too long for a service time of t_s  5 min. So let's analyze the dependency of mean queue length overlineL on server capacity c. For that we can manipulate the server capacity in the arrival function and collect the results in a table:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], η=Float64[], tsm=Float64[])\nfor c ∈ collect(0.97:0.01:1.7)\n    global Q = Job[]   # input queue\n    global S = Job[]   # stock\n    global M = Machine(Idle(), 0)\n    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\n    global count = 1\n\n    reset!(𝐶)                            # reset 𝐶\n    sample_time!(𝐶, 1)                   # set sample rate to 1\n    periodic!(𝐶, fun(stats))   # register the stats() function for sampling\n\n    Random.seed!(2019)\n    arrive(5, 1/5, c)\n    run!(𝐶, 1000)                        # run another simulation for 1000 \"min\"\n    global d = WvsL()\n    s = collect_stats()\n    push!(df1, (c, s.Lm, s.Wm, s.η, s.tsm))\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can look at it in a scatter plot:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.c, df1.Wm, title=L\"\\overline{W}\"*\" and \"*L\"\\overline{L}\"*\" over server capacity\",\n    xlabel=\"server capacity\", marker = (:o, 3, 0.4, :blue), label=L\"\\overline{W}\"*\" [min]\")\nscatter!(df1.c, df1.Lm, marker = (:x, 4), label=L\"\\overline{L}\"*\" [jobs]\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: W and L over server capacity)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We need to increase server capacity much in order to avoid long queues and waiting times.","category":"page"},{"location":"examples/singleserver/#How-about-Little's-law?-1","page":"Single server","title":"How about Little's law?","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"overlineW and overlineL seem to be proportional. This is stated by Little's law:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"beginequation\nL = lambdatimes W\nendequation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"for stationary systems with lambda = arrival rate. In our case lambda = t_a = 5. Let's look at it:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.Lm, df1.Wm, xlabel=L\"\\overline{L}\"*\" [jobs]\", ylabel=L\"\\overline{W}\"*\" [min]\",\n    marker = (:o, 4, 0.4, :blue), label=\"data\", title=\"Little's law\", legend=:topleft)\nplot!(df1.Lm, df1.Lm*5, label=\"theory \"*L\"(\\overline{L}\\times 5)\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: Little's law)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little's law seems not to be a bad one. In order to analyze stability and stationarity and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with Simulate.jl ...","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"See also: tau, 𝐶, fun, event!, run!, reset!","category":"page"},{"location":"examples/tabletennis/#Table-tennis-1","page":"Table tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"using Simulate, Printf\nimport Simulate.init!","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Some functions describe the setup of players, serve and return.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ≤ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if (rand() ≤ p.accuracy) && (p.state == Wait())\n        event!(𝐶, fun(step!, p.opp, Serve()), after, ts)\n        @printf(\"%5.2f: %s serves %s\\n\", tau()+ts, p.name, p.opp.name)\n    else\n        event!(𝐶, fun(step!, p.opp, Miss()), after, ts)\n        @printf(\"%5.2f: %s serves and misses %s\\n\", tau()+ts, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ≤ p.accuracy\n        event!(𝐶, fun(step!, p.opp, Return()), after, tr)\n        @printf(\"%5.2f: %s returns %s\\n\", tau()+tr, p.name, p.opp.name)\n    else\n        event!(𝐶, fun(step!, p.opp, Miss()), after, tr)\n        @printf(\"%5.2f: %s returns and misses %s\\n\", tau()+tr, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We can model the players as state machines. Their behaviour is described by the following step!-transition functions, leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, σ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $σ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Union{Wait, Unalert}, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%5.2f: %s looses ball\\n\", τ(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, σ::PEvent) = step!(p, p.state, σ)","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Random.seed!(123)\n\nprintln(run!(𝐶, 30))\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nrun! finished with 47 clock events, 0 sample steps, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we reset the clock for further simulations:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> reset!(𝐶)\nclock reset to t₀=0, sampling rate Δt=0.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"See also: event!, fun, tau, 𝐶,  run!, reset!","category":"page"},{"location":"manual/history/#Version-history-1","page":"Release notes","title":"Version history","text":"","category":"section"},{"location":"manual/history/#v0.2.0-1","page":"Release notes","title":"v0.2.0","text":"","category":"section"},{"location":"manual/history/#","page":"Release notes","title":"Release notes","text":"This is the first version fully supporting three modeling schemes: events, processes and sampling.","category":"page"},{"location":"manual/history/#","page":"Release notes","title":"Release notes","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!,\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to 𝐶,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"manual/history/#v0.1.0-1","page":"Release notes","title":"v0.1.0","text":"","category":"section"},{"location":"manual/history/#","page":"Release notes","title":"Release notes","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions,\nintroduced a central clock variable 𝐶,\nClock state machine with init!, run!, incr!, stop!, resume!,\nLogger and logging functions,\nfirst documentation,\nfirst examples,\nCI and development setup.","category":"page"},{"location":"#Simulate.jl-1","page":"Home","title":"Simulate.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl provides three schemes for modeling and simulating discrete event systems (DES): 1) event scheduling, 2) interacting processes and 3) continuous sampling. It introduces a clock and allows to schedule arbitrary Julia functions or expressions as events, processes or sampling operations on the clock's timeline. It provides simplicity and flexibility in building models and performance in simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Development documentation\nThe development documentation is not yet updated. Many examples do not reflect the latest changes in the API and run only on v0.2.0! See the news for a list of changes in the API.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Getting started: Get an overview and learn the basics.\nBuilding models: Use and combine different approaches to modeling and simulation.\nParallel simulation: If you want to parallelize your simulations.\nReal time events: setup real time clocks and schedule events to them.\nUsage: Get detailed informations about types, functions and macros in Simulate.jl.\nPerformance: How to get good performance for your simulations.\nExamples: Look at and learn from examples.\nInternals: Get informations about internal functions.\nTroubleshooting: If something doesn't work as expected.","category":"page"},{"location":"#Development-1","page":"Home","title":"Development","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl is a new package and still in active development. Please use, test and help  evolve it. Its GitHub repository is at https://github.com/pbayer/Simulate.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"}]
}
