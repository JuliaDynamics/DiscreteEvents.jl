var documenterSearchIndex = {"docs":
[{"location":"intro/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"DiscreteEvents.jl allows you to","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"setup virtual or realtime clocks,\nschedule events (Julia functions or expressions) to them,\nrun clocks to trigger events.","category":"page"},{"location":"intro/#Preparations-1","page":"Introduction","title":"Preparations","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"DiscreteEvents.jl is a registered package. You install it to your Julia environment with","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"] add DiscreteEvents","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"You can install the development version with","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"] add https://github.com/pbayer/DiscreteEvents.jl","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"You can then load it with","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"using DiscreteEvents","category":"page"},{"location":"intro/#Setup-a-clock-1","page":"Introduction","title":"Setup a clock","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Setting up a virtual clock is as easy as","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"clk = Clock()","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"You created a Clock variable clk with a master clock 0 at thread 1 with 0 active clocks (ac) and pretty much everything set to 0, without yet any scheduled events (ev), conditional events (cev) or sampling events (sampl).","category":"page"},{"location":"intro/#Schedule-events-1","page":"Introduction","title":"Schedule events","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"You can now schedule events to your clock. In order to demonstrate how it works we setup a small simulation. We want to simulate the easy life of a pet in the morning. First we define some data structures for pets:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"abstract type PetState end\nstruct Sleeping  <: PetState end\nstruct Scuffing  <: PetState end\nstruct Running   <: PetState end\n\nabstract type PetEvent end\nstruct GetWeary  <: PetEvent end\nstruct GetHungry <: PetEvent end\nstruct Scuff     <: PetEvent end\nstruct LeapUp    <: PetEvent end\nstruct Sleep     <: PetEvent end\n\nmutable struct Pet\n    clk::Clock\n    name::String\n    state::PetState\n    speak::String\nend","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Then we need an API for Pet since we do not want to access its state directly.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"using Printf\nstate(p) = p.state\nspeak(p, n) = @printf(\"%5.2f %s: %s\\n\", tau(p.clk), p.name, p.speak^n)\n\nfunction setstate!(p::Pet, q::PetState)\n    p.state = q\n    @printf(\"%5.2f %s: %s\\n\", tau(p.clk), p.name, repr(p.state))\nend","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We describe the behaviour of the pet in time with some state-transition functions:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"function doit!(p::Pet, ::Sleeping, ::LeapUp)   # leap up after sleeping\n    setstate!(p, Running())\n    event!(p.clk, fun(doit!, p, fun(state, p), GetHungry()), after, 5*rand())\nend\n\nfunction doit!(p::Pet, ::Scuffing, ::LeapUp)   # leap up while scuffing\n    setstate!(p, Running())\n    event!(p.clk, fun(doit!, p, fun(state, p), GetWeary()), after, 2*rand())\nend\n\nfunction doit!(p::Pet, ::Running, ::GetHungry) # get hungry while running\n    speak(p, 5)\n    event!(p.clk, fun(doit!, p, fun(state, p), Scuff()), after, rand())\nend\n\nfunction doit!(p::Pet, ::Running, ::GetWeary)  # get weary while running\n    speak(p, 2)\n    event!(p.clk, fun(doit!, p, fun(state, p), Sleep()), after, 2*rand())\nend\n\nfunction doit!(p::Pet, ::Running, ::Scuff)     # scuff after running\n    setstate!(p, Scuffing())\n    event!(p.clk, fun(doit!, p, fun(state, p), LeapUp()), after, 2*rand())\nend\n\nfunction doit!(p::Pet, ::Running, ::Sleep)     # sleep after running\n    setstate!(p, Sleeping())\n    event!(p.clk, fun(doit!, p, fun(state, p), LeapUp()), after, 10*rand())\nend","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We use here two features of DiscreteEvents:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"with event! we schedule functions to the clock,\nfun encapsulates those functions and their arguments in a function closure, so that they can be executed at event time. In this case – in order to have a current state at event time – we encapsulate state(p) into another fun closure.","category":"page"},{"location":"intro/#Run-the-clock-1","page":"Introduction","title":"Run the clock","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Then we setup a pet, schedule the first event on it and run the clock:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"using Random; Random.seed!(123)     # we seed the random number generator for reprodicibility\nsnoopy = Pet(clk, \"Snoopy\", Sleeping(), \"huff\")\nevent!(clk, fun(doit!, snoopy, snoopy.state, LeapUp()), after, 5)","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> run!(clk, 25)\n 5.00 Snoopy: Running()\n 8.84 Snoopy: huffhuffhuffhuffhuff\n 9.78 Snoopy: Scuffing()\n11.13 Snoopy: Running()\n11.92 Snoopy: huffhuff\n12.55 Snoopy: Sleeping()\n19.17 Snoopy: Running()\n22.10 Snoopy: huffhuffhuffhuffhuff\n22.16 Snoopy: Scuffing()\n22.69 Snoopy: Running()\n22.91 Snoopy: huffhuff\n23.24 Snoopy: Sleeping()\n\"run! finished with 12 clock events, 0 sample steps, simulation time: 25.0\"","category":"page"},{"location":"intro/#Processes-and-implicit-events-1","page":"Introduction","title":"Processes and implicit events","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"DiscreteEvents provides also another approach: process-based simulation. In this case we implement the pet behaviour in a single function. For such a simple example this comes out simpler and more convenient:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"function pet(clk::Clock, p::Pet)\n    setstate!(p, Running());  delay!(clk,  5*rand())\n    speak(p, 5);              delay!(clk,    rand())  # get hungry\n    setstate!(p, Scuffing()); delay!(clk,  2*rand())\n    setstate!(p, Running());  delay!(clk,  2*rand())\n    speak(p, 2);              delay!(clk,  2*rand())  # get weary\n    setstate!(p, Sleeping()); delay!(clk, 10*rand())\nend","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"This describes one pet cycle. After each status change the pet function calls delay! for a given timeout on the clock. Note that the pet function takes the clock as its first argument. This is required for calling delay!.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We have to reimplement our speak and setstate! functions since now we print from an asynchronous process. With now! we let the clock do the printing:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"speak(p, n) = now!(p.clk, fun(println, @sprintf(\"%5.2f %s: %s\", tau(p.clk), p.name, p.speak^n)))\n\nfunction setstate!(p::Pet, q::PetState)\n    p.state = q\n    now!(p.clk, fun(println, @sprintf(\"%5.2f %s: %s\", tau(p.clk), p.name, repr(p.state))))\nend","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"In order to make this work we have to register the pet function to the clock.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"resetClock!(clk, t0=5)              # reset the clock, we start at 5\nRandom.seed!(123)                   # reseed the random generator\nsetstate!(snoopy, Sleeping())       # set snoopy sleeping\nprocess!(clk, Prc(1, pet, snoopy));","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We use process! and Prc to register pet to the clock and to start it as an asynchronous process (as a task). Then we can run the clock as before:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> run!(clk, 20)\n 5.00 Snoopy: Running()\n 8.84 Snoopy: huffhuffhuffhuffhuff\n 9.78 Snoopy: Scuffing()\n11.13 Snoopy: Running()\n11.92 Snoopy: huffhuff\n12.55 Snoopy: Sleeping()\n19.17 Snoopy: Running()\n22.10 Snoopy: huffhuffhuffhuffhuff\n22.16 Snoopy: Scuffing()\n22.69 Snoopy: Running()\n22.91 Snoopy: huffhuff\n23.24 Snoopy: Sleeping()\n\"run! finished with 24 clock events, 0 sample steps, simulation time: 25.0\"","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"We got the same output – with more implicit events for the delay! and now! calls).","category":"page"},{"location":"intro/#Evaluation-1","page":"Introduction","title":"Evaluation","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"There is no point in doing simulations with such simple sequential examples, but if we do the same with more pets operating in parallel, things get messy very quickly and there is no way to do sequential programming for it. For such simulations we need parallel state machines, processes, actors etc. and their coordination on a time line. Our first approaches above scale well for such requirements.","category":"page"},{"location":"usage/#User-guide-1","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"usage/#Installation-1","page":"User guide","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"DiscreteEvents\nversion","category":"page"},{"location":"usage/#DiscreteEvents.DiscreteEvents","page":"User guide","title":"DiscreteEvents.DiscreteEvents","text":"DiscreteEvents\n\nA Julia package for generating and simulating discrete events. It runs on Julia VERSION ≥ v\"1.0\". Multithreading requires VERSION ≥ v\"1.3\".\n\nThe current stable, registered version is installed with\n\npkg> add DiscreteEvents\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/DiscreteEvents.jl\")\n\n\n\n\n\n","category":"module"},{"location":"usage/#DiscreteEvents.version","page":"User guide","title":"DiscreteEvents.version","text":"version\n\nGives the package version:\n\njulia> using DiscreteEvents\n\njulia> DiscreteEvents.version\nv\"0.3.0\"\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Clocks-1","page":"User guide","title":"Clocks","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clock schedule and execute Julia functions or expressions as events at given times or under given conditions.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clocks have virtual time and precede as fast as possible when they simulate chains of events. For parallel simulations they can control ActiveClocks on parallel threads.\nRTClocks schedule and execute events on a real (system) time line.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clocks have an identification number:","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"a master Clock on thread has id = 0,\nworker ActiveClocks on parallel threads have id ≥ 1,\nreal time RTClocks have id ≤ -1.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clock\nRTClock","category":"page"},{"location":"usage/#DiscreteEvents.Clock","page":"User guide","title":"DiscreteEvents.Clock","text":"Clock(Δt::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T<:Number,U<:Number}\n\nCreate a new simulation clock.\n\nArguments\n\nΔt::T=0.01: time increment for sampling. Δt can be set later with sample_time!.\nt0::U=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. t0=60s.\n\nFields\n\nid::Int: clock ident number, 0: master clock, ≥ 1: parallel clock,\nstate::ClockState: clock state,\ntime::Float64: clock time,\nunit::FreeUnits: time unit,\nend_time::Float64: end time for simulation,\nΔt::Float64: sampling time, timestep between ticks,\nac::Vector{ClockChannel}: channels to active clocks on parallel threads,\nsc::Schedule: the clock Schedule (events, cond events and sampling),\nprocesses::Dict{Any, Prc}: registered Prces,\nchannels::Vector{ClockChannel}: registered channels,\ntn::Float64: next timestep,\ntev::Float64: next event time,\nevcount::Int: event counter,\nscount::Int: sample counter\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()                 # create a unitless clock (standard)\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c1 = Clock(1s, unit=minute)  # create a clock with unit [minute]\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 minute, Δt=0.01667 minute, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c2 = Clock(1s)               # create a clock with implicit unit [s]\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c3 = Clock(t0=60s)           # another clock with implicit unit [s]\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 s, Δt=0.01 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c4 = Clock(1s, t0=1hr)       # here Δt's unit [s] takes precedence\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=3600.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"usage/#DiscreteEvents.RTClock","page":"User guide","title":"DiscreteEvents.RTClock","text":"RTClock{E <: ClockEvent} <: AbstractClock\n\nA real time clock checks every given period for scheduled events and executes them. It has a time in seconds since its start or last reset and uses system time for updating.\n\nReal time clocks are controlled over channels. Multiple real time clocks can be setup with arbitrary periods (≥ 1 ms). Real time clocks should not be created directly but rather with CreateRTClock.\n\nFields\n\nTimer::Timer:     clock period in seconds, minimum is 0.001 (1 ms)\nclock::Clock:     clock work\ncmd::Channel{T}:  command channel to asynchronous clock\nback::Channel{T}: back channel from async clock\nid::Int:          arbitrary id number\nthread::Int:      thread the async clock is living in\ntime::Float64:    clock time since start in seconds\nt0::Float64:      system time at clock start in seconds\nT::Float64:       clock period in seconds\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"User guide","title":"User guide","text":"You can set time units and query the current clock time.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"setUnit!\ntau","category":"page"},{"location":"usage/#DiscreteEvents.setUnit!","page":"User guide","title":"DiscreteEvents.setUnit!","text":"setUnit!(clk::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nclk::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60)     # setup a new clock with t0=60\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tau(c) # current time is 60.0 NoUnits\n60.0\n\njulia> setUnit!(c, s)       # set clock unit to Unitful.s\n60.0 s\n\njulia> tau(c) # current time is now 60.0 s\n60.0 s\n\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\n\njulia> tau(c)               # current time is now 1.0 minute\n1.0 minute\n\njulia> isa(tau(c), Time)\ntrue\n\njulia> uconvert(s, tau(c))  # ... which can be converted to other time units\n60.0 s\n\njulia> tau(c).val           # it has a value of 1.0\n1.0\n\njulia> c.time               # internal clock time is set to 1.0 (a Float64)\n1.0\n\njulia> c.unit               # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.tau","page":"User guide","title":"DiscreteEvents.tau","text":"tau(clk::Clock=𝐶)\n\nReturn the current simulation time.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> resetClock!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.01.\"\njulia> tau() # gives the central time\n0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"User guide","title":"User guide","text":"There is a default clock 𝐶, which can be used for experimental work.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"𝐶","category":"page"},{"location":"usage/#DiscreteEvents.𝐶","page":"User guide","title":"DiscreteEvents.𝐶","text":"𝐶\n\n𝐶 (𝐶 = \\itC+tab) is the default simulation clock. If you do one simulation at a time, you can use it for time keeping.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> resetClock!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.01.\"\n\njulia> 𝐶  # default clock\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Idle(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"constant"},{"location":"usage/#","page":"User guide","title":"User guide","text":"You can create a clock with parallel active clocks on all available threads or fork existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel ActiveClocks and diagnose them.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"PClock\nfork!\npclock\ncollapse!\ndiagnose\ncreateRTClock\nstopRTClock","category":"page"},{"location":"usage/#DiscreteEvents.PClock","page":"User guide","title":"DiscreteEvents.PClock","text":"PClock(Δt::T=0.01; t0::U=0.0, unit::FreeUnits=NoUnits) where {T<:Number,U<:Number}\n\nSetup a clock with parallel clocks on all available threads.\n\nArguments\n\nΔt::T=0.01: time increment > 0. If given Δt ≤ 0, it gets set to 0.01.\nt0::U=0.0: start time for simulation,\nunit::FreeUnits=NoUnits: clock time unit for explicitl unit setting.\n\nnote: Note\nProcesses on multiple threads are possible in Julia ≥ 1.3 and with JULIA_NUM_THREADS > 1.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.fork!","page":"User guide","title":"DiscreteEvents.fork!","text":"fork!(master::Clock)\n\nEstablish copies of a master clock (thread 1) on all parallel threads.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.pclock","page":"User guide","title":"DiscreteEvents.pclock","text":"pclock(clk::Clock, id::Int ) :: C where {C<:AbstractClock}\npclock(ac::ActiveClock, id::Int ) :: C where {C<:AbstractClock}\n\nGet a parallel clock to a given clock.\n\nArguments\n\nmaster::Clock: a master clock or\nac::ActiveClock: an active clock,\nid::Int=threadid(): thread id, defaults to the caller's current thread.\n\nReturns\n\nthe master Clock if id==0,\na parallel ActiveClock else\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.collapse!","page":"User guide","title":"DiscreteEvents.collapse!","text":"collapse!(master::Clock)\n\nTransfer the schedules of the parallel clocks to master and them stop them.\n\nnote: Note\nIf there are processes on other threads registered to parallel clocks, make sure that they aren't needed anymore before calling collapse. They are not transferred to and cannot be controlled by master.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.diagnose","page":"User guide","title":"DiscreteEvents.diagnose","text":"diagnose(master::Clock, id::Int)\n\nReturn the stacktrace from parallel clock id.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.createRTClock","page":"User guide","title":"DiscreteEvents.createRTClock","text":"createRTClock(T::Float64, id::Int, thrd::Int=nthreads(); ch_size::Int=256)\n\nCreate, start and return a real time Clock.\n\nThe clock takes the current system time and starts to count in seconds with the given period T. Events or sampling functions can then be scheduled to it.\n\nArguments\n\nT::Float64:           period (clock resolution) in seconds, T ≥ 0.001\nid::Int:              clock identification number other than 0:(nthreads()-1)\nthrd::Int=nthreads(): thread, the clock task should run in\nch_size::Int=256:     clock communication channel size\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.stopRTClock","page":"User guide","title":"DiscreteEvents.stopRTClock","text":"stopRTClock(rtc::RTClock)\n\nStop a real time clock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Events-1","page":"User guide","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Julia functions and expressions can be scheduled for execution","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"at given clock times and\nunder specified conditions.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Action\nTiming\nfun\nevent!","category":"page"},{"location":"usage/#DiscreteEvents.Action","page":"User guide","title":"DiscreteEvents.Action","text":"Action\n\nAn action is either  a Function or an Expr or a Tuple of them. It can be scheduled in an event for later execution.\n\nwarning: Evaluating expressions is slow\nExpr should be avoided in time critical parts of applications. You will get a one time warning if you use them. They can be replaced easily by funs or function closures. They are evaluated at global scope in Module Main only. Other modules using DiscreteEvents.jl cannot use Expr in events and have to use functions.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#DiscreteEvents.Timing","page":"User guide","title":"DiscreteEvents.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"usage/#DiscreteEvents.fun","page":"User guide","title":"DiscreteEvents.fun","text":"fun(f::Function, args...; kwargs...)\n\nSave a function f and its arguments in a closure for later execution.\n\nArguments\n\nThe arguments args... and keyword arguments kwargs... to fun are passed to f at execution but may change their values between beeing captured in fun and fs later execution. If f needs their current values at execution time there are two possibilities:\n\nfun can take funs, function closures, symbols or expressions at the place of values  or variable arguments. They are evaluated at event time just before being passed to f.  There is one exception: if f is an event!, its arguments are passed on unevaluated.\nA mutable type argument (Array, struct ...) is always current. You can  also change its content from within a function.\n\nwarning: Evaluating symbols and expressions is slow\nSymbols and Expr should be avoided in time critical parts of applications. You will get a one time warning if you use that feature. They can be replaced easily by funs or function closures. They are evaluated at global scope in Module Main only. Other modules using DiscreteEvents.jl cannot use this feature and have to use functions.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> g(x; y=1) = x+y\ng (generic function with 1 method)\n\njulia> x = 1\n1\n\njulia> gg = fun(g, :x, y=2);   # we pass x as a symbol to fun\n\njulia> x += 1   # a becomes 2\n2\n\njulia> gg()     # at execution g gets a current x and gives a warning\n┌ Warning: Evaluating expressions is slow, use functions instead\n└ @ DiscreteEvents ~/.julia/dev/DiscreteEvents/src/fclosure.jl:37\n4\n\njulia> hh = fun(g, fun(()->x), y=3);   # reference x with an anonymous fun\n\njulia> x += 1   # x becomes 3\n3\n\njulia> hh()     # at execution g gets again a current x\n6\n\njulia> ii = fun(g, ()->x, y=4);  # reference x with an anonymous function\n\njulia> x += 1   # x becomes 4\n4\n\njulia> ii()     # ok, g gets an updated x\n8\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.event!","page":"User guide","title":"DiscreteEvents.event!","text":"event!([clk], ex, t; <keyword arguments>)\nevent!([clk], ex, T, t; <keyword arguments>)\n\nSchedule an event for a given simulation time.\n\nArguments\n\nclk<:AbstractClock: clock, it not supplied, the event is scheduled to 𝐶,\nex<:Action: an expression or function or a tuple of them,\nT::Timing: a timing, one of at, after or every,\nt<:Number: simulation time, if t < clk.time set t = clk.time,\n\nKeyword arguments\n\ncycle<:Number=0.0: repeat cycle time for an event,\ncid::Int=clk.id: if cid ≠ clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads,\nsync::Bool=false: if true, force a synchronization of all parallel clocks   before executing the event.\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\n\njulia> event!(𝐶, fun(myfunc, 1, 2), 1) # a 1st event to 1\n\njulia> event!(𝐶, fun(myfunc, 2, 3), 1) #  a 2nd event to the same time\n\njulia> event!(𝐶, fun(myfunc, 3, 4), 1s)\nWarning: clock has no time unit, ignoring units\n\njulia> setUnit!(𝐶, s)\n0.0 s\n\njulia> event!(𝐶, fun(myfunc, 4, 5), 1minute)\n\njulia> event!(fun(myfunc, 5, 6), after, 1hr)\n\n\n\n\n\n\nevent!([clk], ex, cond; <keyword arguments>)\n\nSchedule ex as a conditional event, conditions cond get evaluated at each clock tick.\n\nArguments\n\nclk<:AbstractClock: if no clock is supplied, the event is scheduled to 𝐶,\nex<:Action: an expression or function or a tuple of them,\ncond<:Action: a condition is true if all functions or expressions therein return true,\ncid::Int=clk.id: assign the event to the parallel clock cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> c = Clock()   # create a new clock\nClock 0, thrd 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> event!(c, fun((x)->println(tau(x), \": now I'm triggered\"), c), fun(>=, fun(tau, c), 5))\n\njulia> run!(c, 10)   # sampling is not exact, so it takes 502 sample steps to fire the event\n5.009999999999938: now I'm triggered\n\"run! finished with 0 clock events, 502 sample steps, simulation time: 10.0\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Functions and expressions can be given to events on their own or in tuples, even mixed:","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"function events()\n    event!(:(i += 1), after, 10)  # one expression\n    event!(fun(f, 1, 2, 3, diff=pi), every, 1)  # one fun\n    event!((:(i += 1), fun(g, j)), (()->tau() ≥ 50, fun(isready, input), :(a ≤ 10))) # two funs under three conditions\nend","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Events are called or evaluated at a their scheduled times or by sampling when their preconditions become true.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"note: Note\nFor conditions you should prefer inequalities like <, ≤, ≥, > to equality == in order to make sure that a condition can be detected, e.g. tau() ≥ 100 is preferable to tau() == 100.","category":"page"},{"location":"usage/#Continuous-sampling-1","page":"User guide","title":"Continuous sampling","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Functions or expressions can register for sampling and are then executed \"continuously\" at each clock increment Δt. The default clock sample rate Δt is 0.01 time units.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"sample_time!\nperiodic!","category":"page"},{"location":"usage/#DiscreteEvents.sample_time!","page":"User guide","title":"DiscreteEvents.sample_time!","text":"sample_time!([clk::Clock], Δt::N) where {N<:Number}\n\nSet the clock's sample rate starting from now (tau(clk)).\n\nArguments\n\nclk::Clock: if not supplied, set the sample rate on 𝐶,\nΔt::N: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.periodic!","page":"User guide","title":"DiscreteEvents.periodic!","text":"periodic!([clk], ex, Δt; spawn)\n\nRegister a function or expression for periodic execution at the clock`s sample rate.\n\nArguments\n\nclk<:AbstractClock: if not supplied, it registers on 𝐶,\nex<:Action: an expression or function or a tuple of them,\nΔt<:Number=clk.Δt: set the clock's sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,\nspawn::Bool=false: if true, spawn the periodic event to other available threads.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Processes-1","page":"User guide","title":"Processes","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Julia functions can run as processes (asynchronous tasks) registered to a clock.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Prc\nprocess!\ninterrupt!","category":"page"},{"location":"usage/#DiscreteEvents.Prc","page":"User guide","title":"DiscreteEvents.Prc","text":"Prc(id, f, arg...; kw...)\n\nPrepare a function to run as a process (asynchronous task) in a simulation.\n\nArguments, fields\n\nid: some unique identification for registration,\nf::Function: a function f(clk, arg...; kw...), must take clk (a Clock)   as its first argument,\narg...: further arguments to f\nkw...: keyword arguments to f\n\nFields\n\ntask::Union{Task,Nothing}: a task structure,\nclk::Union{AbstractClock,Nothing}: clock where the process is registered,\nstate::ClockState: process state,\n\nnote: Note\nA function started as a Prc runs in a loop. It has to give back control by e.g. doing a take!(input) or by calling delay! or wait!, which will yield it. Otherwise it will starve everything else!\n\n\n\n\n\n","category":"type"},{"location":"usage/#DiscreteEvents.process!","page":"User guide","title":"DiscreteEvents.process!","text":"process!([clk], prc, cycles; spawn)\n\nRegister a Prc to a clock, start it as an asynchronous process and return the id it was registered with. It can then be found under clk.processes[id].\n\nArguments\n\nc<:AbstractClock: if not provided, the process runs under 𝐶,\nprc::Prc: it contains a function and its arguments,\ncycles<:Number=Inf: number of cycles the process should run,\nspawn::Bool=false: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.\n\nnote: Note\nspawning a process is possible only with parallel clocks setup with PClock or fork!.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.interrupt!","page":"User guide","title":"DiscreteEvents.interrupt!","text":"interrupt!(p::Prc, ev::ClockEvent, value=nothing)\n\nInterrupt a Prc by throwing a ClockException to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Delay-and-wait-…-1","page":"User guide","title":"Delay and wait …","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Processes then can call delay! or wait! or take! and put! … on their channels. They are then suspended until a given time or until certain conditions are met or requested resources are available.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"delay!\nwait!","category":"page"},{"location":"usage/#DiscreteEvents.delay!","page":"User guide","title":"DiscreteEvents.delay!","text":"delay!(clk, Δt)\ndelay!(clk, T, t)\n\nDelay (suspend) a process for a time interval Δt on the clock clk.\n\nArguments\n\nΔt<:Number: time interval,\nT::Timing: only until is accepted,\nt<:Number: delay until time t if t > clk.time, else give a warning.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.wait!","page":"User guide","title":"DiscreteEvents.wait!","text":"wait!(clk, cond)\n\nDelay (suspend) a process on a clock clk until a condition has become true.\n\nArguments\n\ncond<:Action: a condition is is true if all expressions or functions therein return true.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Now-1","page":"User guide","title":"Now","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Processes in a simulation enclose IO-operations in a now! call to make sure they finish before the clock proceeds.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"now!","category":"page"},{"location":"usage/#DiscreteEvents.now!","page":"User guide","title":"DiscreteEvents.now!","text":"now!(clk::Clock, ex::A) where {A<:Action}\n\nTell the clock to execute an IO-operation ex and not to proceed before ex is finished.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Actors-1","page":"User guide","title":"Actors","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Actors are not bound to typical sequences of events like processes, but can operate as finite state machines. They run as Julia tasks listening on a channel.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"In order to integrate into the event scheduling framework, they can register their channel to the clock. Then the clock will only proceed to the next event if the channel is empty and the actor has completed the current step.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"register!","category":"page"},{"location":"usage/#DiscreteEvents.register!","page":"User guide","title":"DiscreteEvents.register!","text":"register!(clk::Clock, ch::Channel)\n\nRegister a channel to a clock. The clock proceeds only to the next  event if this channel is empty. This allows tasks/actors getting messages from that channel to complete their cycle before the  clock proceeds. \n\n\n\n\n\n","category":"function"},{"location":"usage/#Running-simulations-1","page":"User guide","title":"Running simulations","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Virtual clocks can be run, stopped or stepped through and thereby used to simulate chains of events.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"run!\nincr!\nresetClock!\nstop!\nresume!\nsync!","category":"page"},{"location":"usage/#DiscreteEvents.run!","page":"User guide","title":"DiscreteEvents.run!","text":"run!(clk::Clock, duration::N) where {N<:Number}\n\nRun a simulation for a given duration.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.incr!","page":"User guide","title":"DiscreteEvents.incr!","text":"incr!(clk::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.resetClock!","page":"User guide","title":"DiscreteEvents.resetClock!","text":"resetClock!(clk::Clock, Δt::T=0.01; t0::U=0; <keyword arguments>) where {T<:Number, U<:Number}\n\nReset a clock.\n\nArguments\n\nclk::Clock\nΔt::T=0.01: sample rate\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Δt::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=60.0 s, Δt=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> resetClock!(c)\n\"clock reset to t₀=0.0, sampling rate Δt=0.01.\"\n\njulia> c\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Idle(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\nresetClock!(rtc::RTClock)\n\nReset a real time clock. Set its time to zero and delete all scheduled and sampling events.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.stop!","page":"User guide","title":"DiscreteEvents.stop!","text":"stop!(clk::Clock)\n\nStop a running simulation.\n\n\n\n\n\nStop a Prc\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.resume!","page":"User guide","title":"DiscreteEvents.resume!","text":"resume!(clk::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DiscreteEvents.sync!","page":"User guide","title":"DiscreteEvents.sync!","text":"sync!(clk::Clock, to::Clock=𝐶)\n\nForce a synchronization of two clocks. Change all registered times of clk accordingly. Convert or force clk.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Resources-1","page":"User guide","title":"Resources","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Shared resources with limited capacity are often needed in simulations.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"One approach to model them is to use Julia Channels with its API. This is thread-safe and thus should be preferred for multithreading applications.\nUsing Resource is a second possibility to model shared resources. Its interface gives more flexibility and is faster in single threaded applications, but in multithreading the user must avoid race conditions by explicitly wrapping access with lock -… access …- unlock.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Resource\ncapacity\nisfull\nisready\nisempty\nempty!\nlength\npush!\npop!\npushfirst!\npopfirst!\nfirst\nlast","category":"page"},{"location":"usage/#DiscreteEvents.Resource","page":"User guide","title":"DiscreteEvents.Resource","text":"Resource{T}(capacity)\n\nA Resource implements a Deque with a limited capacity. If used in multithreading applications, the user must avoid race conditions by explicitly wrapping modifying calls with lock-unlock.\n\nFields\n\nitems::Deque{T}: resource buffer\ncapacity::Number=Inf: the capacity is limited to the given integer,\nlock::ReentrantLock: a lock for coordinating resource access by tasks.\n\nExample\n\njulia> \n\nnote: Note\nIn order to use the full interface to Resource you have to load DataStructures.\n\n\n\n\n\n","category":"type"},{"location":"usage/#DataStructures.capacity","page":"User guide","title":"DataStructures.capacity","text":"capacity(r::Resource)\n\nGet the capacity of a resource\n\n\n\n\n\ncapacity(ch::Channel)\n\nGet the capacity of a channel.\n\n\n\n\n\n","category":"function"},{"location":"usage/#DataStructures.isfull","page":"User guide","title":"DataStructures.isfull","text":"isfull(r::Resource)\n\nTest whether the resource is full\n\n\n\n\n\nisfull(ch::Channel)\n\nTest whether a channel is full.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.isready","page":"User guide","title":"Base.isready","text":"isready(r::Resource)\n\nTest whether an item is available.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.isempty","page":"User guide","title":"Base.isempty","text":"isempty(r::Resource)\n\nTest whether the resource is empty.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.empty!","page":"User guide","title":"Base.empty!","text":"empty!(r::Resource)\n\nReset the resource buffer (deque).\n\n\n\n\n\nempty!(ch::Channel)\n\nReset a channel, throw away the elements stored to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.length","page":"User guide","title":"Base.length","text":"length(r::Resource)\n\nGet the number of elements available.\n\n\n\n\n\nlength(ch::Channel)\n\nGet the number of items in a channel.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.push!","page":"User guide","title":"Base.push!","text":"push!(r::Resource, x)\n\nAdd an element to the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.pop!","page":"User guide","title":"Base.pop!","text":"pop!(r::Resource)\n\nRemove an element from the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.pushfirst!","page":"User guide","title":"Base.pushfirst!","text":"pushfirst!(r::Resource, x)\n\nAdd an element to the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.popfirst!","page":"User guide","title":"Base.popfirst!","text":"popfirst!(r::Resource)\n\nRemove an element from the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.first","page":"User guide","title":"Base.first","text":"first(r::Resource)\n\nGet the element at the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.last","page":"User guide","title":"Base.last","text":"last(r::Resource)\n\nGet the element at the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Resource provides a lock-unlock API for multithreading applications.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"lock\nunlock\nislocked\ntrylock","category":"page"},{"location":"usage/#Base.lock","page":"User guide","title":"Base.lock","text":"lock(r::Resource)\n\nAcquire the resource lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.unlock","page":"User guide","title":"Base.unlock","text":"unlock(r::Resource)\n\nReleases ownership of the resource lock.\n\nIf this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.islocked","page":"User guide","title":"Base.islocked","text":"islocked(r::Resource)\n\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.trylock","page":"User guide","title":"Base.trylock","text":"trylock(r::Resource)\n\nAcquire the resource lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.\n\nEach successful trylock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Utilities-1","page":"User guide","title":"Utilities","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"onthread","category":"page"},{"location":"usage/#DiscreteEvents.onthread","page":"User guide","title":"DiscreteEvents.onthread","text":"onthread(f::F, tid::Int; wait::Bool=true) where {F<:Function}\n\nExecute a function f on thread tid (to speed it up).\n\nArguments\n\nf::Function:     function to execute\ntid::Int:        thread id\nwait::Bool=true: if true, it waits for function to finish\n\nExample\n\njulia> using DiscreteEvents, .Threads\n\njulia> onthread(2) do; threadid(); end\n2\n\n\n\n\n\n","category":"function"},{"location":"history/#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history/#v0.2.0-1","page":"Version history","title":"v0.2.0","text":"","category":"section"},{"location":"history/#","page":"Version history","title":"Version history","text":"This is the first version fully supporting three modeling schemes: events, processes and sampling.","category":"page"},{"location":"history/#","page":"Version history","title":"Version history","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!,\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to 𝐶,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"history/#v0.1.0-1","page":"Version history","title":"v0.1.0","text":"","category":"section"},{"location":"history/#","page":"Version history","title":"Version history","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions,\nintroduced a central clock variable 𝐶,\nClock state machine with init!, run!, incr!, stop!, resume!,\nLogger and logging functions,\nfirst documentation,\nfirst examples,\nCI and development setup.","category":"page"},{"location":"troubleshooting/#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Problems-1","page":"Troubleshooting","title":"Problems","text":"","category":"section"},{"location":"troubleshooting/#Process-startup-1","page":"Troubleshooting","title":"Process startup","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Under some environments (e.g. Jupyter) it may happen, that the processes have not started completely before the clock runs. In such cases it may help to put a little sleep, e.g. sleep!(0.1) between process!(…) and run!(…) to ensure that all started processes have enqueued for clock events.","category":"page"},{"location":"troubleshooting/#Clock-information-1","page":"Troubleshooting","title":"Clock information","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Normally for clocks pretty printing is enabled. For diagnostic purposes you can switch pretty printing off and on:","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> clk = Clock()\nClock thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> DiscreteEvents._show_default[1] = true;\n\njulia> clk\nClock(0, DiscreteEvents.Undefined(), 0.0, , 0.0, DiscreteEvents.AC[], DiscreteEvents.Schedule(DataStructures.PriorityQueue{DiscreteEvents.DiscreteEvent,Float64,Base.Order.ForwardOrdering}(), DiscreteEvents.DiscreteCond[], DiscreteEvents.Sample[]), Dict{Any,Prc}(), 0.0, 0.0, 0.0, 0, 0)\n\njulia> DiscreteEvents._show_default[1] = false;\n\njulia> clk\nClock thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0","category":"page"},{"location":"troubleshooting/#A-process-fails-1","page":"Troubleshooting","title":"A process fails","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"If c is your clock, you get the list of all running processes with c.processes. You  then look at the failed process with c.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> 𝐶.processes\nDict{Any,Prc} with 2 entries:\n  2 => Prc(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{…\n  1 => Prc(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel…\njulia> 𝐶.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\n[....]","category":"page"},{"location":"troubleshooting/#Report-1","page":"Troubleshooting","title":"Report","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Otherwise please report your problem and open an issue or commit your solution to the repo.  ","category":"page"},{"location":"news/#News-in-v0.3.0-1","page":"News","title":"News in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"news/#","page":"News","title":"News","text":"v0.3.0 is a significant improvement over 0.2.0 with a name change, multithreading, resource handling and a streamlined documentation.","category":"page"},{"location":"news/#Breaking-name-changes-1","page":"News","title":"Breaking name changes","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"following the advice on discourse and in issue #13 Simulate.jl was renamed to DiscreteEvents.jl. Github maintains and forwards the links.\nthere are further renamings to make the API more consistent:\nSimfunction → fun, SF is no longer defined,\nSimProcess → Prc, SP is no longer defined,\nSimEvent → DiscreteEvent,\nSimCond → DiscreteCond,\nsample! → periodic!, was a name collision with Distributions.jl.\nreset! → resetClock!, was a name collision with DataStructures.jl","category":"page"},{"location":"news/#Streamlined-documentation-1","page":"News","title":"Streamlined documentation","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"the documentation has been reduced to minimal introductory examples and API documentation,\neverything else (further examples, notebooks, explanations, benchmarks) has been moved to a companion site: DiscreteEventsCompanion](https://github.com/pbayer/DiscreteEventsCompanion.jl).","category":"page"},{"location":"news/#New-functionality-in-v0.3.0-1","page":"News","title":"New functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Action is introduced as synonym for Union{Function,Expr,Tuple},\nthereby in addition to funs, you can now schedule arbitrary function closures as events,  \nperiodic! takes now an Action as argument,\nArguments to fun can now be symbols, expressions or other funs or function closures. They get evaluated at event time before being passed to the event function,\nDiscreteEvents.version gives now the package version,\nDiscreteEvents.jl is now much faster due to optimizations,\nonthread allows simulations with processes to run much faster on threads other than 1,\nResource provides an API for modeling limited resources,\nYou can now create a real time clock RTClock and schedule events to it,\nActors can register their channels with register! to the clock and the clock will not proceed before they run.","category":"page"},{"location":"news/#Multithreading-(still-in-the-making)-1","page":"News","title":"Multithreading (still in the making)","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"The data structure of Clock has been changed, it now has a field ac providing channels to parallel clocks,  \nPClock sets up a clock with parallel active clocks on each available thread,\nwith pclock all parallel clocks can be accessed and referenced,\nprocess! can now start tasks on parallel threads,\nevent! can now schedule events for execution on parallel threads,\nperiodic! can now register sampling functions or expressions to parallel clocks,\nif setup with parallel clocks, Clock becomes the master to drive them and synchronize with them at each Δt timestep,","category":"page"},{"location":"news/#Other-breaking-changes-in-v0.3.0-1","page":"News","title":"Other breaking changes in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"τ as an alias for tau is no longer defined.\nThe macros @tau, @val, @SF, @SP are no longer defined.\nLogging functions have been removed (they were not useful enough).\nA function f given to Prc must now take a Clock-variable as its first argument.\nThe first ::Clock-argument to delay! and wait! and now! can no  longer be omitted. Since the task function has now a Clock-variable available (see above), it must provide it to delay!, wait! and now.\nevent! no longer accepts a Vector as argument.\nClk as alias of 𝐶 is no longer provided.\nevent! now returns nothing.\nevent! and periodic! now doesn't take anymore the scope as an argument. Symbols or expressions given to them or included in funs are only evaluated in Main scope: this feature therefore can be used only by end users but not by any packages using DiscreteEvents.jl.","category":"page"},{"location":"news/#Deprecated-functionality-in-v0.3.0-1","page":"News","title":"Deprecated functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Evaluating expressions or symbols at global scope is much slower than using functions and gives now a one time warning. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"news/#Earlier-releases-1","page":"News","title":"Earlier releases","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Release notes: A look at earlier releases.","category":"page"},{"location":"#DiscreteEvents.jl-1","page":"Home","title":"DiscreteEvents.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note: This package has been renamed and its code and examples have been updated to upcoming v0.3. The registered package is Simulate.jl","category":"page"},{"location":"#","page":"Home","title":"Home","text":"DiscreteEvents.jl provides three schemes for modeling and simulating discrete event systems (DES): 1) event scheduling, 2) interacting processes and 3) continuous sampling]. It introduces a clock and allows to schedule arbitrary  functions or expressions as events, processes or sampling operations on the clock's timeline. It provides simplicity and flexibility in building models and performance in simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Development documentation\nThe development documentation is not yet updated. Many examples do not reflect the latest changes in the API and run only on v0.2.0! See the news for a list of changes in the API.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"NEWS: What is new about this version?\nGetting started: Get an overview and learn the basics.\nUsage: Get detailed informations about types, functions and macros.\nInternals: some internal types and functions.\nTroubleshooting: If something doesn't work as expected.\nVersion history: A list of features and changes.","category":"page"},{"location":"#Companion-1","page":"Home","title":"Companion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There is a companion site DiscreteEventsCompanion with notebooks, further docs, examples and benchmarks.","category":"page"},{"location":"#Development-1","page":"Home","title":"Development","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DiscreteEvents.jl is in active development. Please use, test and help  evolve it. Its GitHub repository is at https://github.com/pbayer/DiscreteEvents.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The following types are handled internally by DiscreteEvents.jl. But they maybe interesting for analyzing and debugging clocks and event schedules.","category":"page"},{"location":"internals/#Events-1","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"AbstractEvent\nDiscreteEvent\nDiscreteCond\nSample\nClockException","category":"page"},{"location":"internals/#DiscreteEvents.AbstractEvent","page":"Internals","title":"DiscreteEvents.AbstractEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.DiscreteEvent","page":"Internals","title":"DiscreteEvents.DiscreteEvent","text":"DiscreteEvent{T<:Action} <: AbstractEvent\n\nA discrete event is an Action to be executed at an event time.\n\nArguments, fields\n\nex::T: a function or an expression or a tuple of them,\nt::Float64: event time,\nΔt::Float64: repeat rate with for repeating events.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.DiscreteCond","page":"Internals","title":"DiscreteEvents.DiscreteCond","text":"DiscreteCond{S<:Action, T<:Action} <: AbstractEvent\n\nA condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments, fields\n\ncond::S: a conditional function or an expression or a tuple of them   (conditions must evaluate to Bool),\nex::T: a function or an expression or a tuple of them to be executed   if conditions are met,\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.Sample","page":"Internals","title":"DiscreteEvents.Sample","text":"Sample{T<:Action} <: AbstractEvent\n\nSampling actions are executed at sampling time.\n\nArguments, fields\n\nex<:Action: an Action to be executed at sample time.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.ClockException","page":"Internals","title":"DiscreteEvents.ClockException","text":"ClockException(ev::ClockEvent, value=nothing)\n\nDefine a ClockException, which can be thrown to processes.\n\nArguments, fields\n\nev::ClockEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"internals/#Clock-1","page":"Internals","title":"Clock","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"prettyClock\nAbstractClock\nActiveClock\nSchedule\nClockChannel","category":"page"},{"location":"internals/#DiscreteEvents.prettyClock","page":"Internals","title":"DiscreteEvents.prettyClock","text":"prettyClock(on::Bool)\n\nSwitch pritty printing for clocks on and off.\n\n\n\n\n\n","category":"function"},{"location":"internals/#DiscreteEvents.AbstractClock","page":"Internals","title":"DiscreteEvents.AbstractClock","text":"supertype for clocks in DiscreteEvents.jl\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.ActiveClock","page":"Internals","title":"DiscreteEvents.ActiveClock","text":"ActiveClock{E <: ClockEvent} <: AbstractClock\n\nA thread specific clock which can be operated via a channel.\n\nFields\n\nclock::Clock: the thread specific clock,\nmaster::Ref{Clock}: a pointer to the master clock (on thread 1),\ncmd::Channel{E}: the command channel from master,\nans::Channel{E}: the response channel to master.\nid::Int: the id in master's ac array,\nthread::Int: the thread, the active clock runs on.\n\nnote: Note\n\n\nYou should not setup an ActiveClock explicitly. Rather this is done implicitly by fork!ing a Clock to other available threads or directly with PClock. It then can be accessed via pclock as in the following example.\n\nnote: Note\n\n\nDirectly accessing the clock-field of parallel ActiveClocks in simulations is possible but not recommended since it breaks parallel operation. The right way is to pass event!s to the ActiveClock-variable. The communication then happens over the channel to the ActiveClock as it should be.\n\nExample\n\njulia> using DiscreteEvents\n\njulia> clk = Clock()\nClock 0, thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> fork!(clk)\n\njulia> clk    #  ⬇ here you got 3 parallel active clocks\nClock 0, thread 1 (+ 3 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> clk = PClock()\nClock 0, thread 1 (+ 3 ac): state=DiscreteEvents.Undefined(), t=0.0 , Δt=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> ac1 = pclock(clk, 1)    # get access to the 1st active clock (on thread 2)\nActive clock 1 on thread 2: state=DiscreteEvents.Idle(), t=0.0 , Δt=0.01 , prc:0\n   scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.Schedule","page":"Internals","title":"DiscreteEvents.Schedule","text":"Schedule()\n\nA Schedule contains events, conditional events and sampling functions to be executed or evaluated on the clock's time line.\n\nFields\n\nevents::PriorityQueue{DiscreteEvent,Float64}: scheduled events,\ncevents::Array{DiscreteCond,1}: conditional events to evaluate at each tick,\nsamples::Array{Sample,1}: sampling expressions to evaluate at each tick,\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.ClockChannel","page":"Internals","title":"DiscreteEvents.ClockChannel","text":"ClockChannel\n\nProvide a channel to an active clock or a real time clock.\n\nFields\n\nref::Ref{Task}: a pointer to an active clock,\nch::Channel: a communication channel to an active clock,\nid::Int: the thread id of the active clock.\ndone::Bool: flag indicating if the active clock has completed its cycle.\n\n\n\n\n\n","category":"type"},{"location":"internals/#","page":"Internals","title":"Internals","text":"ActiveClocks are internal since the should not be setup explicitly.","category":"page"}]
}
