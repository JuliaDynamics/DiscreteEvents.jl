var documenterSearchIndex = {"docs":
[{"location":"old/clocks-parallel/#Parallel-Clocks-(Experimental)","page":"-","title":"Parallel Clocks (Experimental)","text":"","category":"section"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"Parallel clocks are a new feature in v0.3 and cannot yet considered to be stable. Please develop your applications first single-threaded before going parallel. Please report any failures.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"Parallel clocks are virtual clocks with local clocks on parallel threads to support multi-threaded simulations.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"A parallel clock structure consists of a master (global) clock on thread 1 and ActiveClocks on all available threads > 1. An active clock is a task running a thread local clock. The thread local clock can schedule and execute events locally.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"The master clock communicates with its parallel active clocks via message channels. It synchronizes time with the local clocks. Tasks (processes and actors) have access to their thread local clock from it and then work only with the local clock.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"PClock\npclock","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"Parallel clocks can be identified by their thread number: the master clock works on thread 1, local clocks on parallel threads ‚â• 2. They can be setup and accessed easily:","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"@show x=nthreads()-1;\nclk = PClock()       # now the clock has (+x) active parallel clocks\nac2 = pclock(clk, 2) # access the active clock on thread 2\nac2.clock            # the thread local clock\nac2.clock.ac[]       # local clocks can access their active clock","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"Tasks on parallel threads have access to the thread local clock by pclock(clk). Then they can schedule events, delay! or wait! on it as usual. The thread local clock is passed to a process! automatically if you set it up on a parallel thread.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"You can fork explicitly existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel active clocks and diagnose them.","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"fork!\ncollapse!","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"clk = Clock()      # create a clock\nfork!(clk)         # fork it\nclk                # it now has parallel clocks\ncollapse!(clk)     # collapse it\nclk                # it now has no parallel clocks","category":"page"},{"location":"old/clocks-parallel/","page":"-","title":"-","text":"diagnose","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Even if not considered in classical literature about DES, Actors are natural candidates to represent entities in discrete event systems. They are not bound to typical event sequences, can operate as finite state machines, can assemble into systems and represent hierarchies. They can be spawned to and interoperate over threads.","category":"page"},{"location":"actors/#Requirements","page":"Actors","title":"Requirements","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors run as Julia tasks listening to a (message) channel. They block only if they have no message in their channel. Therefore they run in a simple loop, reacting to a message when it arrives according to their current state. They don't share their state with other Actors or their environment.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"warning: Don't use `delay!` or `wait!` with Actors\nThose are blocking operations and will make an actor non-responsive, just as a process.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"In order to integrate into the DiscreteEvents framework, Actors  register their channels to the clock.channels vector. Then the clock will only proceed to the next event if all registered channels are empty and thus the associated Actors have finished to process the current event.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Even if Actors have registered their message channel to the clock, they should use now! for IO-operations or print via the clock. This also makes them responsive and does not yield them to the scheduler during their loop.","category":"page"},{"location":"actors/#Outlook","page":"Actors","title":"Outlook","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"See DiscreteEventsCompanion for more explanations and examples with Actors. Despite of minimal actor support, a lot can be done yet with Actors. Actors push the boundaries of discrete event simulation.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL provides register! for integration into the DiscreteEvents framework.","category":"page"},{"location":"history/#Version-history","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"history/#v0.3.1","page":"Version history","title":"v0.3.1","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"A few days after the release of v0.3.0 Hector Perez contributed some macros to make the DiscreteEvents API more Julian for common cases:","category":"page"},{"location":"history/","page":"Version history","title":"Version history","text":"@event: wraps fun and event! into one call,\n@periodic: wraps fun and periodic! into one call,\n@process: wraps Prc and process! into one call,\n@wait: simplified call of wait!,","category":"page"},{"location":"history/","page":"Version history","title":"Version history","text":"The following macros provide syntactic sugar to existing functions:","category":"page"},{"location":"history/","page":"Version history","title":"Version history","text":"@delay: calls delay!,\n@run!: calls run!.","category":"page"},{"location":"history/#v0.3.0","page":"Version history","title":"v0.3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"(2020-09-11) v0.3.0 was a significant improvement over 0.2.0 with a name change, multi-threading, resource handling and a streamlined documentation (announcement on Julia discourse).","category":"page"},{"location":"history/#Breaking-Name-Changes","page":"Version history","title":"Breaking Name Changes","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"following the advice on discourse and in issue #13 Simulate.jl was renamed to DiscreteEvents.jl. Github maintains and forwards the links.\nthere are further renamings to make the API more consistent:\nSimfunction ‚Üí fun, SF is no longer defined,\nSimProcess ‚Üí Prc, SP is no longer defined,\nSimEvent ‚Üí DiscreteEvent,\nSimCond ‚Üí DiscreteCond,\nsample! ‚Üí periodic!, was a name collision with Distributions.jl.\nreset! ‚Üí resetClock!, was a name collision with DataStructures.jl","category":"page"},{"location":"history/#Streamlined-Documentation","page":"Version history","title":"Streamlined Documentation","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"the documentation has been reduced to minimal introductory examples and API documentation,\neverything else (explanations, further examples, notebooks, benchmarks) has been moved to a companion site: DiscreteEventsCompanion.","category":"page"},{"location":"history/#New-Functionality-in-v0.3.0","page":"Version history","title":"New Functionality in v0.3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Action is introduced as synonym for Union{Function,Expr,Tuple},\nthereby in addition to fun, you can now schedule arbitrary function closures as events,  \nperiodic! takes an Action as argument,\nyou can pass also symbols, expressions or other funs or function closures as arguments to fun. They get evaluated at event time before being passed to the event function,\nDiscreteEvents.version gives now the package version,\nDiscreteEvents.jl is now much faster due to optimizations,\nonthread allows simulations with asynchronous tasks (processes and actors) to run much faster on threads other than 1,\nResource provides an API for modeling limited resources,\nyou can now create a real time clock RTClock and schedule events to it (experimental),\nactors can register their message channels to the clock.channels vector and the clock will not proceed before they are empty,\nprocesses and actors (asynchronous tasks) can transfer IO-operations to the clock with now! or print directly via the clock,\nevent! and delay! now also accept stochastic time variables (a Distribution),\nthere is a n keyword parameter for the number of repeat event!s,\nyou can seed the thread-specific RNGs with pseed!.","category":"page"},{"location":"history/#Multi-Threading-(Experimental)","page":"Version history","title":"Multi-Threading (Experimental)","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"The data structure of Clock has been changed, it now has a field ac providing channels to parallel clocks,  \nPClock sets up a clock with parallel active clocks on each available thread,\nwith pclock all parallel clocks can be accessed and referenced,\nprocess! can now start tasks on parallel threads,\nevent! can now schedule events for execution on parallel threads,\nperiodic! can now register sampling functions or expressions to parallel clocks,\nif setup with parallel clocks, Clock becomes the master to drive them and synchronize with them at each Œît time step,","category":"page"},{"location":"history/#Other-Breaking-Changes-in-v0.3.0","page":"Version history","title":"Other Breaking Changes in v0.3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"œÑ as an alias for tau is no longer defined.\nThe macros @tau, @val, @SF, @SP are no longer defined.\nLogging functions have been removed (they were not useful enough).\nA function f given to Prc must now take a Clock-variable as its first argument.\nThe first ::Clock-argument to delay! and wait! and now! can no  longer be omitted. Since the task function has now a Clock-variable available (see above), it must provide it to delay!, wait! and now.\nevent! no longer accepts a Vector as argument.\nClk as alias of ùê∂ is no longer provided.\nevent! now returns nothing.\nevent! and periodic! now doesn't take anymore the scope as an argument. Symbols or expressions given to them or included in funs are only evaluated in Main scope: this feature therefore can be used only by end users but not by any packages using DiscreteEvents.jl.","category":"page"},{"location":"history/#Deprecated-functionality-in-v0.3.0","page":"Version history","title":"Deprecated functionality in v0.3.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"Evaluating expressions or symbols at global scope is much slower than using functions and gives now a one time warning. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"history/#v0.2.0","page":"Version history","title":"v0.2.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"(2019-12-03) This is the first version fully supporting three modeling schemes: events, processes and sampling.","category":"page"},{"location":"history/","page":"Version history","title":"Version history","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!,\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to ùê∂,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"history/#v0.1.0","page":"Version history","title":"v0.1.0","text":"","category":"section"},{"location":"history/","page":"Version history","title":"Version history","text":"First registration 2019-11-04:","category":"page"},{"location":"history/","page":"Version history","title":"Version history","text":"event-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions,\nintroduced a central clock variable ùê∂,\nClock state machine with init!, run!, incr!, stop!, resume!,\nLogger and logging functions,\nfirst documentation,\nfirst examples,\nCI and development setup.","category":"page"},{"location":"old/parallel/#Parallel-Simulation","page":"Parallel Simulation","title":"Parallel Simulation","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"You can parallelize simulations in two ways:","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"You can do independent parallel simulations with the @threads-macro [1] or with the Distributed standard library.\nYou can execute a single simulation on multiple threads to speed it up.","category":"page"},{"location":"old/parallel/#Multi-Threading-(Experimental)","page":"Parallel Simulation","title":"Multi-Threading (Experimental)","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"Multithreading of simulations is introduced with DiscreteEvents v0.3 and will take some time to become stable. Please try it out and report your problems!","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"If we compute events of a DES on parallel cores of a computer, we may reverse a sequence e_i e_j to  e_j e_i. If there is causality between those events, we have a problem. Therefore we cannot spawn arbitrary events to parallel cores without altering causality and the simulated outcome.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"Fortunately not all events in larger DES are strongly coupled. For most practical purposes we can divide systems into subsystems where events depend on each other but not or only statistically on events in other subsystems. Subsystems have local time and their clocks get synchronized periodically.","category":"page"},{"location":"old/parallel/#Thread-local-Clocks","page":"Parallel Simulation","title":"Thread-local Clocks","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"With PClock we introduce parallel local clocks on each thread. The master clock on thread 1 synchronizes with its parallel clocks each chosen time interval Œît. Synchronization takes some time and the slowest thread with the biggest workload (usually thread 1) sets the pace for the whole computation.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"When using the keywords cid or spawn with event!, periodic! and process! we can work with parallel clocks. Then","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"events and processes get registered to parallel clocks,\nprocesses get started on parallel threads and\ntheir functions get the thread local clock to delay! or wait! on it.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"A user should avoid to share global variables between threads in order not to get race conditions. If thread-local subsystems get inputs from each other, they should communicate over Julia channels, which are thread safe.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"When working on parallel threads, we have thread-local random number generators. Random number sequences therefore are not identical between single-threaded and multithreaded applications (see below). This usually causes also simulation results to be different.","category":"page"},{"location":"old/parallel/#Speedup-and-Balance","page":"Parallel Simulation","title":"Speedup and Balance","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"First results show a considerable speedup of multithreaded simulations vs single-threaded ones:","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"The Multithreaded Assembly Line on DiscreteEventsCompanion took 1.58 s to run 63452 events on 8 parallel cores vs. 70287 events in 10.77 s on thread 1 of the same machine [2].\nIf we put the simulated assembly operations only on threads 2-8, it took only 0.67 s.\nWith all assembly operations together on thread 2, it took 4.96 s.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"The 2nd and 3rd results show that considerable speedups can yet be realized by relieving thread 1 and distributing the workload between the other ones.","category":"page"},{"location":"old/parallel/#Random-Numbers","page":"Parallel Simulation","title":"Random Numbers","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"To get reproducible but different random number sequences on each thread, you can seed the thread-specific global default random number generators with pseed!. It will seed! the thread-specific default RNGs with the given number multiplied by the thread id ntimes t_i. Calls to rand() are thread-specific and will then use the seeded default RNGs.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"At this time of writing all implicit calls to rand() in timed event!s or in delay! use the default RNGs.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"Alternatively you can seed a thread-specific default RNG with:","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"using DiscreteEvents, Random\n\nonthread(2) do  # seed the default RNG on thread 2\n    Random.seed!(123)\nend","category":"page"},{"location":"old/parallel/#Documentation-and-Examples","page":"Parallel Simulation","title":"Documentation and Examples","text":"","category":"section"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"You can find more documentation and examples on DiscreteEventsCompanion.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"[1]: Goldratt's Dice Game on DiscreteEventsCompanion illustrates how to do this.","category":"page"},{"location":"old/parallel/","page":"Parallel Simulation","title":"Parallel Simulation","text":"[2]: Event count and line throughput are different between multi- and single-threaded because the random number sequence changes between these examples.","category":"page"},{"location":"setup/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"setup/","page":"Installation","title":"Installation","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"setup/","page":"Installation","title":"Installation","text":"DiscreteEvents\nversion","category":"page"},{"location":"setup/#DiscreteEvents.DiscreteEvents","page":"Installation","title":"DiscreteEvents.DiscreteEvents","text":"DiscreteEvents\n\nA Julia package for generating and simulating discrete events. It runs on Julia VERSION ‚â• v\"1.0\". Multithreading requires VERSION ‚â• v\"1.3\".\n\nIts Github repo is [https://github.com/JuliaDynamics/DiscreteEvents.jl].\n\nThe current stable, registered version is installed with\n\npkg> add DiscreteEvents\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/JuliaDynamics/DiscreteEvents.jl\")\n\n\n\n\n\n","category":"module"},{"location":"setup/#DiscreteEvents.version","page":"Installation","title":"DiscreteEvents.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"setup/","page":"Installation","title":"Installation","text":"using DiscreteEvents\nDiscreteEvents.version","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"DiscreteEvents.jl allows you to","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"setup virtual or realtime clocks,\nschedule events (Julia functions or expressions) to them,\nrun clocks to trigger events.","category":"page"},{"location":"intro/#Preparations","page":"Introduction","title":"Preparations","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"DiscreteEvents.jl is a registered package. You install it to your Julia environment with","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"] add DiscreteEvents","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"You can install the development version with","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"] add https://github.com/JuliaDynamics/DiscreteEvents.jl","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"You can then load it with","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using DiscreteEvents","category":"page"},{"location":"intro/#Setup-a-clock","page":"Introduction","title":"Setup a clock","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Setting up a virtual clock is as easy as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"clock = Clock()","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This creates a Clock variable clk with a clock at thread 1 with pretty much everything set to 0, without yet any scheduled events (ev), conditional events (cev) or sampling events (sampl).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can now schedule events to the clock. We demonstrate how it works with a couple of small simulations.","category":"page"},{"location":"intro/#Inventory-Control-Problem","page":"Introduction","title":"Inventory Control Problem","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"An inflammable is stored in a special tank at a filling station. Customers arrive according to a Poisson process with rate Œª and ask for an amount X sim mathcalN(Œº œÉ^2) aX of the product. Any demand that cannot be met is lost. Opportunities to replenish the stock in the tank occur according to a Poisson process with rate œÅ. The two Poisson processes are assumed to be independent of each other. For security reasons replenishment is only allowed when the tank is empty. At those opportunities it is replenished with a fixed amount Q. [1]","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We are interested to study the stock in the tank and the fraction of demand that is lost.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"First we setup a data structure for a simulation:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using DiscreteEvents, Distributions, Random\n\nmutable struct Station\n    q::Float64           # fuel amount\n    t::Vector{Float64}   # time vector\n    qt::Vector{Float64}  # fuel/time vector\n    cs::Int              # customers served\n    cl::Int              # customers lost\n    qs::Float64          # fuel sold\n    ql::Float64          # lost sales\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We have two events: customer and replenishment happening in two interacting Poisson processes:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"function customer(c::Clock, s::Station, X::Distribution)\n    function fuel(s::Station, x::Float64)\n        s.q -= x             # take x from tank\n        push!(s.t, c.time)   # record time, amount, customer, sale\n        push!(s.qt, s.q)\n        s.cs += 1\n        s.qs += x\n    end\n\n    x = rand(X)              # calculate demand\n    if s.q ‚â• x               # demand can be met\n        fuel(s, x)\n    elseif s.q ‚â• a           # only partially in stock\n        s.ql += x - s.q      # count the loss\n        fuel(s, s.q)         # give em all we have\n    else\n        s.cl += 1            # count the lost customer\n        s.ql += x            # count the lost demand\n    end\nend\n\nfunction replenish(c::Clock, s::Station, Q::Float64)\n    if s.q < a\n        push!(s.t, c.time)\n        push!(s.qt, s.q)\n        s.q += Q\n        push!(s.t, c.time)\n        push!(s.qt, s.q)\n    end\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We pass our event functions a Clock variable in order to access the clock's c.time.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now we setup our constants and variables, schedul the event functions with @events and @run! the clock for 5000 virtual minutes:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Random.seed(123)\nconst Œª = 0.5      # ~ every two minutes a customer\nconst œÅ = 1/180    # ~ every 3 hours a replenishment truck\nconst Œº = 30       # ~ mean demand per customer\nconst œÉ = 10       #   standard deviation\nconst a = 5        #   minimum amount\nconst Q = 6000.0   # replenishment amount\nconst M‚ÇÅ = Exponential(1/Œª)  # customer arrival time distribution\nconst M‚ÇÇ = Exponential(1/œÅ)  # replenishment time distribution\nconst X = truncated(Normal(Œº, œÉ), a, Inf)  # demand distribution\n\nclock = Clock()    # create a clock, a fuel station and events\ns = Station(Q, Float64[0.0], Float64[Q], 0, 0, 0.0, 0.0)\n@event replenish(clock, s, Q) every M‚ÇÇ\n@event customer(clock, s, X) every M‚ÇÅ\nprintln(@run! clock 5000)\n\n@show fuel_sold = s.qs;\n@show loss_rate = s.ql/s.qs;\n@show served_customers = s.cs;\n@show lost_customers = s.cl;","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"run! finished with 2525 clock events, 0 sample steps, simulation time: 5000.0\nfuel_sold = s.qs = 53999.999999999956\nloss_rate = s.ql / s.qs = 0.3962195131252451\nserved_customers = s.cs = 1789\nlost_customers = s.cl = 708","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We sold 9 tanks of fuel to 1789 customers. But we could have served 708 more customers and sell nearly 40% more fuel. Clearly we have some improvement potential:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using Plots\nplot(s.t, s.qt, title=\"Filling Station\", xlabel=\"time [min]\", ylabel=\"inventory [L]\", legend=false)\nsavefig(\"invctrl.png\")","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: inventory)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If we could manage to replenish immediately after the tank is empty, we would be much better off.","category":"page"},{"location":"intro/#a-b_call_center","page":"Introduction","title":"A-B Call Center Problem","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"DiscreteEvents also provides process-based simulation. A process is a typical sequence of events. This is particularly useful if we can describe our system in such terms.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"One example is a call center with two servers, Able and Baker and a line for incoming calls. Able is more experienced and can provide service faster than Baker. We have some assumptions about arrival and service time distributions. We want to know if the system works and how long customers have to wait [2].","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"First we describe some data structures for our system:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using DiscreteEvents, Distributions, Random\n\nmutable struct Caller\n    id::Int\n    t‚ÇÅ::Float64  # arrival time\n    t‚ÇÇ::Float64  # beginning of service time\n    t‚ÇÉ::Float64  # end of servive time\nend\n\nmutable struct Server\n    id::Int\n    S::Distribution  # service time distribution\n    tbusy::Float64   # cumulative service time\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We describe the processes in our system as two functions serve and arrive:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"function serve(c::Clock, s::Server, input::Channel, output::Vector{Caller}, limit::Int)\n    call = take!(input)           # take a call\n    call.t‚ÇÇ = c.time              # record the beginning of service time\n    @delay c s.S                  # delay for service time\n    call.t‚ÇÉ = c.time              # record the end of service time\n    s.tbusy += call.t‚ÇÉ - call.t‚ÇÇ  # log service time\n    push!(output, call)           # hang up\n    call.id ‚â• limit && stop!(c)\nend\n\nfunction arrive(c::Clock, input::Channel, count::Vector{Int})\n    count[1] += 1\n    put!(input, Caller(count[1], c.time, 0.0, 0.0))\nend","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We implement our caller queue as a Channel eventually blocking a process if it calls take!. The serve function calls a @delay from the Clock. This suspends a process for the required simulation time. Note that the serve process stop!s the clock after the last caller is finished.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Next we initialize our constants, setup a simulation environment,  and start our servers as process!es. Arrivals are an event-based Poisson process as in the first example [3]. We @run! the clock for enough time:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Random.seed!(123)\nconst N = 1000\nconst M_arr = Exponential(2.5)\nconst M_a   = Exponential(3)\nconst M_b   = Exponential(4)\n\nclock = Clock()\ninput = Channel{Caller}(Inf)\noutput = Caller[]\ns1 = Server(1, M_a, 0.0)\ns2 = Server(2, M_b, 0.0)\n@process serve(clock, s1, input, output, N)\n@process serve(clock, s2, input, output, N)\n@event arrive(clock,input,count) every M_arr\n@run! clock 5000","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"\"run! halted with 2005 clock events, 0 sample steps, simulation time: 2464.01\"","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The clock stopped at 2464. We served 1000 callers in 2464 virtual minutes. This is an average lead time of 2.5 min. Doesn't seem so bad.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> s1.tbusy / clock.time\n0.7256119737495218\n\njulia> s2.tbusy / clock.time\n0.7422549861860762","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Also our servers have been busy only about 73% of the time. Could we give them some other work to do? How about waiting times for callers?","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using Plots\nwt = [c.t‚ÇÇ - c.t‚ÇÅ for c in output]\nplot(wt, title=\"A-B-Call center \", xlabel=\"callers\", ylabel=\"waiting time [min]\", legend=false)\nsavefig(\"ccenter.png\")","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Image: call center)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Given the average values, something unexpected emerges: The responsiveness of our call center is not good and waiting times often get way too long. If we want to shorten them, we must improve our service times or add more servers.","category":"page"},{"location":"intro/#Evaluation","page":"Introduction","title":"Evaluation","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It is easy to simulate discrete event systems such as continuous-time stochastic processes or queueing systems with DiscreteEvents. It integrates well with Julia.","category":"page"},{"location":"intro/#Further-examples","page":"Introduction","title":"Further examples","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"You can find more examples at DiscreteEventsCompanion.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[1]: This is a modified version of example 4.1.1 in Tijms: A First Course in Stochastic Models, Wiley 2003, p 143ff","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[2]: This is a simplified version of the Able-Baker Call Center Problem in Banks, Carson, Nelson, Nicol: Discrete-Event System Simulation, Pearson 2005, p 35 ff","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[3]: Different approaches to modeling: e.g. event-based and process-based can be combined.","category":"page"},{"location":"news/#News-in-v0.3.5","page":"News","title":"News in v0.3.5","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"news/","page":"News","title":"News","text":"multithreading (parallel clocks) has been removed from exports, testing and documentation as it was unstable and has been broken by Julia 1.7 and 1.8","category":"page"},{"location":"news/#Earlier-releases","page":"News","title":"Earlier releases","text":"","category":"section"},{"location":"news/","page":"News","title":"News","text":"Release notes: A look at earlier releases.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The following types are handled internally by DiscreteEvents.jl, but maybe necessary for analyzing and debugging clocks and event schedules.","category":"page"},{"location":"internals/#Events","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"AbstractEvent\nDiscreteEvent\nDiscreteCond\nSample","category":"page"},{"location":"internals/#DiscreteEvents.AbstractEvent","page":"Internals","title":"DiscreteEvents.AbstractEvent","text":"Supertype for events.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.DiscreteEvent","page":"Internals","title":"DiscreteEvents.DiscreteEvent","text":"`DiscreteEvent{T<:Action, X} <: AbstractEvent A discrete event is an Action to be executed at an event time.\n\nArguments, fields\n\nex::T: a function or an expression or a tuple of them,\nt::Float64: event time,\nŒît::X: repeat interval (Float64, Distribution or Nothing),\nn::Int: number of repeats.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.DiscreteCond","page":"Internals","title":"DiscreteEvents.DiscreteCond","text":"DiscreteCond{S<:Action, T<:Action} <: AbstractEvent\n\nA condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments, fields\n\ncond::S: a conditional function or an expression or a tuple of them   (conditions must evaluate to Bool),\nex::T: a function or an expression or a tuple of them to be executed   if conditions are met,\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.Sample","page":"Internals","title":"DiscreteEvents.Sample","text":"Sample{T<:Action} <: AbstractEvent\n\nSampling actions are executed at sampling time.\n\nArguments, fields\n\nex<:Action: an Action to be executed at sample time.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Clocks","page":"Internals","title":"Clocks","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"There is an abstract type for clocks and an active clock, used for controlling parallel clocks.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"AbstractClock\nGlobalClock\nActiveClock\nLocalClock\nlocalClock","category":"page"},{"location":"internals/#DiscreteEvents.AbstractClock","page":"Internals","title":"DiscreteEvents.AbstractClock","text":"Supertype for clocks.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.GlobalClock","page":"Internals","title":"DiscreteEvents.GlobalClock","text":"Global clock with vector of active clocks.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.ActiveClock","page":"Internals","title":"DiscreteEvents.ActiveClock","text":"ActiveClock{E <: ClockEvent} <: AbstractClock\n\nAn active clock is a wrapper around a local Clock on a  parallel thread. It is operated by a thread local task. The master  clock on thread 1 communicates with it through messages over its channels. \n\nFields\n\nclock::Clock: the thread specific local clock,\nmaster::Ref{Clock}: a pointer to the master clock (on thread 1),\nforth::Channel{E}: the command channel from master,\nback::Channel{E}: the response channel to master,\nid::Int: the clocks id/thread number,\ntask::Task: the active clock`s task.\n\nnote: Don't setup an active clock explicitly!\nIt is done implicitly with PClock or by fork!ing  a Clock to other available threads.\n\nOn a parallel thread tasks can access their local clock with  pclock(clk). Then they can schedule 'thread local'  events, delay! or wait! on it.\n\nnote: Don't share active clocks between threads!\nIn multithreading we communicate over channels and don't want  to share variables between threads. A user can still access  active clocks for diagnostic purposes.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.LocalClock","page":"Internals","title":"DiscreteEvents.LocalClock","text":"Local clock with reference to a wrapping active clock.\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.localClock","page":"Internals","title":"DiscreteEvents.localClock","text":"localClock(c::Clock)\n\nCreate a thread local clock with an undefined reference to an active clock which inherits parameters of the master clock c.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"Schedule and ClockChannel are two important Clock substructures:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Schedule\nClockChannel","category":"page"},{"location":"internals/#DiscreteEvents.Schedule","page":"Internals","title":"DiscreteEvents.Schedule","text":"Schedule()\n\nA schedule contains events, conditional events and sampling functions  to be executed or evaluated on the clock's time line.\n\nFields\n\nevents::PriorityQueue{DiscreteEvent,Float64}: scheduled events,\ncevents::Array{DiscreteCond,1}: conditional events to evaluate at each tick,\nsamples::Array{Sample,1}: sampling expressions to evaluate at each tick,\n\n\n\n\n\n","category":"type"},{"location":"internals/#DiscreteEvents.ClockChannel","page":"Internals","title":"DiscreteEvents.ClockChannel","text":"ClockChannel{T <: ClockEvent}\n\nProvide a message channel to an active clock or a real time clock.\n\nFields\n\nref::Ref{Task}: a reference to an active clock task, useful for diagnosis,\nforth::Channel{T}: a communication channel to an active clock,\nback::Channel{T}: response channel from the active clock,\nthread::Int: the thread id of the active clock,\ndone::Bool: flag indicating if the active clock has completed its cycle,\nload::Int: internal flag.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Clock-concurrency","page":"Internals","title":"Clock concurrency","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"If a task after activation by the clock gives control back to the Julia scheduler (e.g. by reading from a channel or by doing an IO-operation), it enqueues for its next schedule behind the clock. The clock may then increment time to t_i+1 before the task can finish its job at current event time t_i.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are several ways to solve this problem:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The clock does a 2‚Åø·µà yield() after invoking a task and enqueues again at the end of the scheduling queue. This is implemented for delay! and wait! of processes and should be enough for most those cases.\nActors push! their message channel to the clock.channels vector and the clock will only proceed to the next event if all registered channels are empty [1].\nTasks use now! to let the (master) clock do IO-operations for them. They can also print via the clock.","category":"page"},{"location":"internals/#Error-handling-and-diagnosis","page":"Internals","title":"Error handling and diagnosis","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"prettyClock","category":"page"},{"location":"internals/#DiscreteEvents.prettyClock","page":"Internals","title":"DiscreteEvents.prettyClock","text":"prettyClock(on::Bool)\n\nSwitch pritty printing for clocks on and off.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"[1]: In YAActL you can  register! to a Vector{Channel}. To register actors is also useful for diagnosis.","category":"page"},{"location":"events/#Events","page":"Events","title":"Events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Events are computations Œ±Œ≤Œ≥ at times t_1t_2t_3 We call those computations actions.","category":"page"},{"location":"events/#Actions","page":"Events","title":"Actions","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Actions are Julia functions or expressions to be executed later:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Action\nfun","category":"page"},{"location":"events/#DiscreteEvents.Action","page":"Events","title":"DiscreteEvents.Action","text":"Action\n\nAn action is either  a Function or an Expr or a Tuple of them.  It can be scheduled in an event for later execution.\n\n\n\n\n\n","category":"type"},{"location":"events/#DiscreteEvents.fun","page":"Events","title":"DiscreteEvents.fun","text":"fun(f::Function, args...; kwargs...)\n\nSave a function f and its arguments in a closure for later execution.\n\nArguments\n\nThe arguments args... and keyword arguments kwargs... to fun are passed to f at execution but may change their values between beeing captured in fun and fs later execution. If f needs their current values at execution time there are two possibilities:\n\nfun can take funs, function closures, symbols or expressions at the place of values  or variable arguments. They are evaluated at event time just before being passed to f.  There is one exception: if f is an event!, its arguments are passed on unevaluated.\nA mutable type argument (Array, struct ...) is always current. You can  also change its content from within a function.\n\nIf using Symbols or Expr in fun you get a one time warning. They are  evaluated at global scope in Module Main only and therefore cannot be used by other modules.\n\n\n\n\n\n","category":"function"},{"location":"events/","page":"Events","title":"Events","text":"Actions can be combined into tuples:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"using DiscreteEvents\na = 1\nprintln(a) isa Action        # a function call is not an action\nfun(println, a) isa Action   # wrapped in a fun it is an action\nisa(()->println(a), Action)  # an anonymous function\n:(println(a)) isa Action     # an expression\n(()->println(a), fun(println, a), :(println(a))) isa Action # a tuple of them","category":"page"},{"location":"events/#Expressions-and-Symbols","page":"Events","title":"Expressions and Symbols","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Expressions too are Actions. Also you can pass symbols to fun to delay evaluation of variables. Exprs and Symbols are evaluated at global scope in Module Main only. This is a user convenience feature. Other modules using DiscreteEvents cannot use them in events and have to use functions.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"warning: Evaluating expressions is slow!\nUsage of Expr or Symbol will generate a one time warning. You can replace them easily with funs or function closures. ","category":"page"},{"location":"events/#Timed-Events","page":"Events","title":"Timed Events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Actions can be scheduled as events at given times:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Timing\nevent!(::CL,::A,::U)  where {CL<:AbstractClock,A<:Action,U<:Number}","category":"page"},{"location":"events/#DiscreteEvents.Timing","page":"Events","title":"DiscreteEvents.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"events/#DiscreteEvents.event!-Union{Tuple{U}, Tuple{A}, Tuple{CL}, Tuple{CL, A, U}} where {CL<:DiscreteEvents.AbstractClock, A<:Union{Expr, Function, Tuple{Vararg{Union{Expr, Function}, N} where N}}, U<:Number}","page":"Events","title":"DiscreteEvents.event!","text":"event!([clk], ex, t; <keyword arguments>)\nevent!([clk], ex, t, cy; <keyword arguments>)\nevent!([clk], ex, T, t; <keyword arguments>)\n\nSchedule an event for a given time t. \n\nIf t is a Distribution, event time is evaluated as rand(t).   If cy is a Distribution, the event is repeated after a random  interval rand(cy). If the evaluated time ‚â§ clk.time, the event  is scheduled at clk.time.\n\nArguments\n\nclk<:AbstractClock: clock, it not supplied, the event is scheduled to ùê∂,\nex<:Action: an expression or function or a tuple of them,\nT::Timing: a timing, one of at, after or every,\nt: event time, Number or Distribution,\ncy: repeat cycle, Number or Distribution.\n\nKeyword arguments\n\nn::Int=typemax(Int): number of repeating events,\ncid::Int=clk.id: if cid ‚â† clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads,\n\nExamples\n\njulia> using DiscreteEvents, Distributions, Random\n\njulia> Random.seed!(123);\n\njulia> c = Clock()\nClock 1: state=:idle, t=0.0, Œît=0.01, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> f(x) = x[1] += 1\nf (generic function with 1 method)\n\njulia> a = [0]\n1-element Array{Int64,1}:\n 0\n\njulia> event!(c, fun(f, a), 1)                     # 1st event at 1\n\njulia> event!(c, fun(f, a), at, 2)                 # 2nd event at 2\n\njulia> event!(c, fun(f, a), after, 3)              # 3rd event after 3\n\njulia> event!(c, fun(f, a), every, Exponential(3)) # Poisson process with Œª=1/3\n\njulia> run!(c, 50)\n\"run! finished with 26 clock events, 0 sample steps, simulation time: 50.0\"\n\njulia> a\n1-element Array{Int64,1}:\n 26\n\n\n\n\n\n","category":"method"},{"location":"events/#Conditional-Events","page":"Events","title":"Conditional Events","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Actions can be scheduled as events under given conditions:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"event!(::T,::A,::C) where {T<:AbstractClock,A<:Action,C<:Action}","category":"page"},{"location":"events/#DiscreteEvents.event!-Union{Tuple{C}, Tuple{A}, Tuple{T}, Tuple{T, A, C}} where {T<:DiscreteEvents.AbstractClock, A<:Union{Expr, Function, Tuple{Vararg{Union{Expr, Function}, N} where N}}, C<:Union{Expr, Function, Tuple{Vararg{Union{Expr, Function}, N} where N}}}","page":"Events","title":"DiscreteEvents.event!","text":"event!([clk], ex, cond; <keyword arguments>)\n\nSchedule ex as a conditional event, conditions cond get evaluated at each clock tick.\n\nArguments\n\nclk<:AbstractClock: if no clock is supplied, the event is scheduled to ùê∂,\nex<:Action: an expression or function or a tuple of them,\ncond<:Action: a condition is true if all functions or expressions therein return true,\n\nKeyword arguments\n\ncid::Int=clk.id: if cid ‚â† clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> c = Clock()   # create a new clock\nClock 1: state=:idle, t=0.0, Œît=0.01, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> event!(c, fun((x)->println(tau(x), \": now I'm triggered\"), c), fun(>=, fun(tau, c), 5))\n\njulia> run!(c, 10)   # sampling is not exact, so it takes 502 sample steps to fire the event\n5.009999999999938: now I'm triggered\n\"run! finished with 0 clock events, 502 sample steps, simulation time: 10.0\"\n\n\n\n\n\n","category":"method"},{"location":"events/","page":"Events","title":"Events","text":"note: Use inequalities to express conditions\nConditions should be expressed with inequalities like <, ‚â§, ‚â•, > rather than with equality == in order to make sure that they can be detected, e.g. tau() ‚â• 100 is preferable to tau() == 100.","category":"page"},{"location":"events/#The-@event-Macro","page":"Events","title":"The @event Macro","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"If a function has a clock as its first argument, you can use the @event macro to schedule it. This wraps it into a fun closure and then calls event! with it.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"@event","category":"page"},{"location":"events/#DiscreteEvents.@event","page":"Events","title":"DiscreteEvents.@event","text":"@event f(arg...) T t [n]\n\nSchedule a function f(arg...) as an event to a clock.\n\nArguments\n\nf: function to be executed at event time,\narg...: its arguments, the first argument must be a clock,\nT: a Timing (at, after, every),\nt: a Number or a Distribution,\nn::Int: repetitions for a repeat event.\n\n\n\n\n\n@event f(farg...) c(carg...)\n@event f(farg...) ca\n\nSchedule a function f(farg...) as a conditional event to a clock.\n\nArguments\n\nf: function to be executed at event time,\nfarg...: its arguments, the first argument must be a clock,\nc: function to be evaluated at the clock's sample rate, if it   returns true, the event is triggered,\ncarg...: arguments to c,\nca: an anyonymous function of the form ()->... to be evaluated    at the clock's sample rate, if it returns true, the event   is triggered.\n\n\n\n\n\n","category":"macro"},{"location":"events/#Use-Cases","page":"Events","title":"Use Cases","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Currently @event supports the following use cases (it accepts a number or a distribution as time t argument):","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"@event f(clk, a, b) at t        # schedule f(clk, a, b) at time t\n@event f(clk, a, b) t           # the same\n@event f(clk, a, b) after t     # schedule f(clk, a, b) after t time units\n@event f(clk, a, b) every t     # schedule it every t unit\n@event f(clk, a, b) every t 10  # schedule it every t unit for 10 times\n@event f(clk, a, b) g(c)        # schedule it on condition g(c)\n@event f(clk, a, b) :a ‚â• 5      # schedule it on condition a ‚â• 5\n@event f(clk, a, b) ()-> a‚â•5 && tau(clk)‚â•8  # on condition of an anonymous function","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"The first call gets expanded to event!(clk, fun(f, clk, a, b), after, t).","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"Note: the @event macro doesn't accept keyword arguments. If you want to use event! with keyword arguments, you must use it explicitly.","category":"page"},{"location":"events/#Continuous-Sampling","page":"Events","title":"Continuous Sampling","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Actions can be registered for sampling and are then executed \"continuously\" at each clock increment Œît. The default clock sample rate Œît is 0.01 time units.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"sample_time!\nperiodic!\n@periodic","category":"page"},{"location":"events/#DiscreteEvents.sample_time!","page":"Events","title":"DiscreteEvents.sample_time!","text":"sample_time!([clk::Clock], Œît::N) where {N<:Number}\n\nSet the clock's sample rate starting from now (tau(clk)).\n\nArguments\n\nclk::Clock: if not supplied, set the sample rate on ùê∂,\nŒît::N: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"events/#DiscreteEvents.periodic!","page":"Events","title":"DiscreteEvents.periodic!","text":"periodic!([clk], ex, Œît; <keyword arguments>)\nperiodic!(clk, ex; <keyword arguments>)\n\nRegister an Action ex for periodic execution at the clock`s sample rate.\n\nArguments\n\nclk<:AbstractClock: if not supplied, it registers on ùê∂,\nex<:Action: an expression or function or a tuple of them,\nŒît<:Number=clk.Œît: set the clock's sampling rate, if no Œît is given, it takes   the current sampling rate, if ‚â§ 0, it calculates a positive one,\n\nKeyword arguments\n\ncid::Int=clk.id: if cid ‚â† clk.id, sample at the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the periodic event to other available threads.\n\n\n\n\n\n","category":"function"},{"location":"events/#DiscreteEvents.@periodic","page":"Events","title":"DiscreteEvents.@periodic","text":"@periodic f(arg...) [Œît]\n\nRegister a function f(arg...) for periodic execution at the  clock`s sample rate.\n\nArguments\n\nf: function to be executed periodically,\narg...: its arguments, the first argument must be a clock,\nŒît: for setting the clock's sample rate.\n\n\n\n\n\n","category":"macro"},{"location":"events/#Events-and-Variables","page":"Events","title":"Events and Variables","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Actions often depend on data or modify it. The data may change between the definition of an action and its later execution. If an action uses a mutable variable like an array or a mutable struct, it gets current data at event time and it is fast. If the action modifies the data, this is the best way to do it:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"using DiscreteEvents\na = [1]                  # define a mutable variable a\nf(x; y=2) = (x[1] += y)  # define a function f\nff = fun(f, a);          # enclose f and a in a fun ff\na[1] += 1                # modify a\nff()                     # execute ff\na[1]                     # a has been modified correctly","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"There are good reasons to avoid global variables but if you want to work with them, you can do it in several ways:","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"g(x; y=1) = x+y                 # define a function g\nx = 1;                          # define a global variable x = 1\ngg = fun(g, :x, y=2);           # pass x as a symbol to g\nx += 1                          # increment x\n2\ngg()                            # now g gets a current x and gives a warning\nhh = fun(g, fun(()->x), y=3);   # reference x with an anonymous fun\nx += 1                          # increment x\nhh()                            # g gets again a current x\nii = fun(g, ()->x, y=4);        # reference x with an anonymous function\nx += 1                          # increment x\nii()                            # g gets an updated x","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"To modify a global variable, you have to use the global keyword inside your function.","category":"page"},{"location":"events/#Events-with-Time-Units","page":"Events","title":"Events with Time Units","text":"","category":"section"},{"location":"events/","page":"Events","title":"Events","text":"Timed events can be scheduled with time units. Times are converted to the clock's time unit.","category":"page"},{"location":"events/","page":"Events","title":"Events","text":"using Unitful\nimport Unitful: s, minute, hr\nc = Clock()\nevent!(c, fun(f, a), 1s)\nsetUnit!(c, s)\nevent!(c, fun(f, a), 1minute)\nevent!(c, fun(f, a), after, 1hr)","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Problems","page":"Troubleshooting","title":"Problems","text":"","category":"section"},{"location":"troubleshooting/#Process-startup","page":"Troubleshooting","title":"Process startup","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Under some environments (e.g. Jupyter) it may happen, that the processes have not started completely before the clock runs. In such cases it may help to put a little sleep, e.g. sleep!(0.1) between process!(‚Ä¶) and run!(‚Ä¶) to ensure that all started processes have enqueued for clock events.","category":"page"},{"location":"troubleshooting/#Clock-information","page":"Troubleshooting","title":"Clock information","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Normally for clocks pretty printing is enabled. For diagnostic purposes you can switch pretty printing off and on:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia> clk = Clock()\nClock thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> DiscreteEvents._show_default[1] = true;\n\njulia> clk\nClock(0, DiscreteEvents.Undefined(), 0.0, , 0.0, DiscreteEvents.AC[], DiscreteEvents.Schedule(DataStructures.PriorityQueue{DiscreteEvents.DiscreteEvent,Float64,Base.Order.ForwardOrdering}(), DiscreteEvents.DiscreteCond[], DiscreteEvents.Sample[]), Dict{Any,Prc}(), 0.0, 0.0, 0.0, 0, 0)\n\njulia> DiscreteEvents._show_default[1] = false;\n\njulia> clk\nClock thread 1 (+ 0 ac): state=DiscreteEvents.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0","category":"page"},{"location":"troubleshooting/#A-process-fails","page":"Troubleshooting","title":"A process fails","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If c is your clock, you get the list of all running processes with c.processes. You  then look at the failed process with c.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia> ùê∂.processes\nDict{Any,Prc} with 2 entries:\n  2 => Prc(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{‚Ä¶\n  1 => Prc(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel‚Ä¶\njulia> ùê∂.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\n[....]","category":"page"},{"location":"troubleshooting/#Report","page":"Troubleshooting","title":"Report","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Otherwise please report your problem and open an issue or commit your solution to the repo.  ","category":"page"},{"location":"resources/#Resources","page":"Resources","title":"Resources","text":"","category":"section"},{"location":"resources/","page":"Resources","title":"Resources","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"Shared resources with limited capacity are often needed in simulations.","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"One approach to model them, is to use Julia Channels with their API. This is thread-safe and thus should be preferred for multithreading applications.\nUsing Resource is a second possibility to model shared resources. Its interface gives more flexibility and is faster in single threaded applications, but in multithreading the user must avoid race conditions by explicitly wrapping access with lock -‚Ä¶ access ‚Ä¶- unlock ‚Äì if the resources are shared by multiple tasks.","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"Resource\ncapacity\nisfull\nisready\nisempty\nempty!\nlength\npush!\npop!\npushfirst!\npopfirst!\nfirst\nlast","category":"page"},{"location":"resources/#DiscreteEvents.Resource","page":"Resources","title":"DiscreteEvents.Resource","text":"Resource{T}(capacity)\n\nA Resource implements a Deque with a limited capacity. If used in multithreading applications, the user must avoid race conditions by explicitly wrapping modifying calls with lock-unlock.\n\nFields\n\nitems::Deque{T}: resource buffer\ncapacity::Number=Inf: the capacity is limited to the given integer,\nlock::ReentrantLock: a lock for coordinating resource access by tasks.\n\nExample\n\njulia> \n\nnote: Note\nIn order to use the full interface to Resource you have to load DataStructures.\n\n\n\n\n\n","category":"type"},{"location":"resources/#DataStructures.capacity","page":"Resources","title":"DataStructures.capacity","text":"capacity(r::Resource)\n\nGet the capacity of a resource\n\n\n\n\n\ncapacity(ch::Channel)\n\nGet the capacity of a channel.\n\n\n\n\n\n","category":"function"},{"location":"resources/#DataStructures.isfull","page":"Resources","title":"DataStructures.isfull","text":"isfull(r::Resource)\n\nTest whether the resource is full\n\n\n\n\n\nisfull(ch::Channel)\n\nTest whether a channel is full.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.isready","page":"Resources","title":"Base.isready","text":"isready(r::Resource)\n\nTest whether an item is available.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.isempty","page":"Resources","title":"Base.isempty","text":"isempty(r::Resource)\n\nTest whether the resource is empty.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.empty!","page":"Resources","title":"Base.empty!","text":"empty!(r::Resource)\n\nReset the resource buffer (deque).\n\n\n\n\n\nempty!(ch::Channel)\n\nReset a channel, throw away the elements stored to it.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.length","page":"Resources","title":"Base.length","text":"length(r::Resource)\n\nGet the number of elements available.\n\n\n\n\n\nlength(ch::Channel)\n\nGet the number of items in a channel.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.push!","page":"Resources","title":"Base.push!","text":"push!(r::Resource, x)\n\nAdd an element to the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.pop!","page":"Resources","title":"Base.pop!","text":"pop!(r::Resource)\n\nRemove an element from the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.pushfirst!","page":"Resources","title":"Base.pushfirst!","text":"pushfirst!(r::Resource, x)\n\nAdd an element to the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.popfirst!","page":"Resources","title":"Base.popfirst!","text":"popfirst!(r::Resource)\n\nRemove an element from the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.first","page":"Resources","title":"Base.first","text":"first(r::Resource)\n\nGet the element at the front of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.last","page":"Resources","title":"Base.last","text":"last(r::Resource)\n\nGet the element at the back of a resource deque.\n\n\n\n\n\n","category":"function"},{"location":"resources/","page":"Resources","title":"Resources","text":"Resource provides a lock-unlock API for multithreading applications.","category":"page"},{"location":"resources/","page":"Resources","title":"Resources","text":"lock\nunlock\nislocked\ntrylock","category":"page"},{"location":"resources/#Base.lock","page":"Resources","title":"Base.lock","text":"lock(r::Resource)\n\nAcquire the resource lock when it becomes available. If the lock is already locked by a different task/thread, wait for it to become available.\n\nEach lock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.unlock","page":"Resources","title":"Base.unlock","text":"unlock(r::Resource)\n\nReleases ownership of the resource lock.\n\nIf this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.islocked","page":"Resources","title":"Base.islocked","text":"islocked(r::Resource)\n\nCheck whether the lock is held by any task/thread. This should not be used for synchronization (see instead trylock).\n\n\n\n\n\n","category":"function"},{"location":"resources/#Base.trylock","page":"Resources","title":"Base.trylock","text":"trylock(r::Resource)\n\nAcquire the resource lock if it is available, and return true if successful. If the lock is already locked by a different task/thread, return false.\n\nEach successful trylock must be matched by an unlock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"usage/#Single-threaded-Speed-up","page":"Utilities","title":"Single-threaded Speed-up","text":"","category":"section"},{"location":"usage/","page":"Utilities","title":"Utilities","text":"The Julia scheduler is running on thread 1. If your application uses tasks or channels on thread 1 (e.g. with process!), it has to compete against other background tasks. You can remove this competition and speed up your application significantly (often by times10 or more) by moving it to a thread other than 1.","category":"page"},{"location":"usage/","page":"Utilities","title":"Utilities","text":"onthread","category":"page"},{"location":"usage/#DiscreteEvents.onthread","page":"Utilities","title":"DiscreteEvents.onthread","text":"onthread(f::F, tid::Int; wait::Bool=true) where {F<:Function}\n\nExecute a function f on thread tid. \n\nTo execute f on a thread other than 1 can speed it up  significantly if it depends on asynchronous tasks.\n\nArguments\n\nf::Function:     function to execute\ntid::Int:        thread id\nwait::Bool=true: if true, it waits for function to finish\n\nExample\n\njulia> using DiscreteEvents, .Threads\n\njulia> onthread(2) do; threadid(); end\n2\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Utilities","title":"Utilities","text":"Look at the M/M/c benchmarks and to this example on DiscreteEventsCompanion for an illustration. You cannot speedup applications not using tasks or channels with this technique.","category":"page"},{"location":"usage/#Parallel-RNG-Seed","page":"Utilities","title":"Parallel RNG Seed","text":"","category":"section"},{"location":"usage/","page":"Utilities","title":"Utilities","text":"pseed!","category":"page"},{"location":"usage/#DiscreteEvents.pseed!","page":"Utilities","title":"DiscreteEvents.pseed!","text":"pseed!(s::Int)\n\nSeed each of the thread local RNGs with s*threadid() to get  reproducible, but different random number sequences on each thread.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#Clocks","page":"Clocks","title":"Clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"CurrentModule = DiscreteEvents","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Clocks schedule and execute actions, computations that happen as events at specified times (or under specified conditions).","category":"page"},{"location":"clocks/#Virtual-Clocks","page":"Clocks","title":"Virtual Clocks","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"A Clock is not bound to physical time and executes an event sequence as fast as possible by jumping from event to event.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Clock\nClock(::T) where T<:Number","category":"page"},{"location":"clocks/#DiscreteEvents.Clock","page":"Clocks","title":"DiscreteEvents.Clock","text":"Clock{AC} <: AbstractClock\n\nA virtual clock structure, used for global and thread local clocks.\n\nFields\n\nid::Int: clock ident number 1: master clock, > 1: parallel clock,\nac::AC: if id == 1: a Vector{ClockChannel} else: Ref{ActiveClock},\nstate::ClockState: clock state,\ntime::Float64: clock time,\nunit::FreeUnits: time unit,\nend_time::Float64: end time for simulation,\nŒît::Float64: sampling time, timestep between ticks,\nsc::Schedule: the clock Schedule (events, cond events and sampling),\nprocesses::Dict{Any, Prc}: registered Prces,\nchannels::Vector{Channel}: registered (Actor) channels,\ntn::Float64: next timestep,\ntev::Float64: next event time,\nevcount::Int: event counter,\nscount::Int: sample counter\n\n\n\n\n\n","category":"type"},{"location":"clocks/#DiscreteEvents.Clock-Tuple{T} where T<:Number","page":"Clocks","title":"DiscreteEvents.Clock","text":"Clock(Œît::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T<:Number,U<:Number}\n\nCreate a new virtual clock.\n\nArguments\n\nŒît::T=0.01: time increment for sampling. Œît can be set later with sample_time!.\nt0::U=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. t0=60s.\n\nThe created clock has id==1 (master).\n\n\n\n\n\n","category":"method"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"You can create clocks easily:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"using DiscreteEvents, Unitful, .Threads\nimport Unitful: s, minute, hr\nc = Clock()                  # create a unitless clock (standard)\nc1 = Clock(1s, unit=minute)  # create a clock with unit [minute]\nc2 = Clock(1s)               # create a clock with implicit unit [s]\nc3 = Clock(t0=60s)           # another clock with implicit unit [s]\nc4 = Clock(1s, t0=1hr)       # here Œît's unit [s] takes precedence","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"There is a default clock ùê∂ for experimental work:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"ùê∂","category":"page"},{"location":"clocks/#DiscreteEvents.ùê∂","page":"Clocks","title":"DiscreteEvents.ùê∂","text":"ùê∂\n\nùê∂ (ùê∂ = \\itC+tab) is a default clock, ready to use. \n\nExamples\n\njulia> using DiscreteEvents\n\njulia> resetClock!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.\"\n\njulia> ùê∂  # default clock\nClock 1: state=:idle, t=0.0, Œît=0.01, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"constant"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"You can query the current clock time:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"tau","category":"page"},{"location":"clocks/#DiscreteEvents.tau","page":"Clocks","title":"DiscreteEvents.tau","text":"tau(clk::Clock=ùê∂)\n\nReturn the current simulation time.\n\nExamples\n\njulia> using DiscreteEvents\n\njulia> resetClock!(ùê∂)   # reset the default clock\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.\"\njulia> tau()            # gives the default clock's time\n0.0\n\n\n\n\n\n","category":"function"},{"location":"clocks/#Real-Time-Clocks-(Experimental)","page":"Clocks","title":"Real Time Clocks (Experimental)","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Real time clocks are a new feature in v0.3 and thus cannot yet be considered as stable. Please try and report problems.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"RTClocks schedule and execute actions on a real (system) time line.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"RTClock\ncreateRTClock\nstopRTClock","category":"page"},{"location":"clocks/#DiscreteEvents.RTClock","page":"Clocks","title":"DiscreteEvents.RTClock","text":"RTClock{E <: ClockEvent} <: AbstractClock\n\nA real time clock checks every given period for scheduled events and executes them. It has a time in seconds since its start or last reset and uses system time for updating.\n\nReal time clocks are controlled over channels. Multiple real time clocks can be setup with arbitrary periods (‚â• 1 ms). Real time clocks should not be created directly but rather with CreateRTClock.\n\nFields\n\nTimer::Timer:     clock period in seconds, minimum is 0.001 (1 ms)\nclock::Clock:     clock work\ncmd::Channel{T}:  command channel to asynchronous clock\nback::Channel{T}: back channel from async clock\nid::Int:          arbitrary id number\nthread::Int:      thread the async clock is living in\ntime::Float64:    clock time since start in seconds\nt0::Float64:      system time at clock start in seconds\nT::Float64:       clock period in seconds\n\n\n\n\n\n","category":"type"},{"location":"clocks/#DiscreteEvents.createRTClock","page":"Clocks","title":"DiscreteEvents.createRTClock","text":"createRTClock(T::Float64, id::Int, thrd::Int=nthreads(); ch_size::Int=256)\n\nCreate, start and return a real time Clock.\n\nThe clock takes the current system time and starts to count in seconds with the given period T. Events or sampling functions can then be scheduled to it.\n\nArguments\n\nT::Float64:           period (clock resolution) in seconds, T ‚â• 0.001\nid::Int:              clock identification number other than 0:nthreads()\nthrd::Int=nthreads(): thread, the clock task should run in\nch_size::Int=256:     clock communication channel size\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.stopRTClock","page":"Clocks","title":"DiscreteEvents.stopRTClock","text":"stopRTClock(rtc::RTClock)\n\nStop a real time clock.\n\n\n\n\n\n","category":"function"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"You can work with real time clocks easily:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"rtc = createRTClock(0.01, 99)     # create a real time clock\nsleep(1)\ntau(rtc)                          # query its time after a sleep\na = [1]                           # create a mutable variable\nf(x) = x[1] += 1                  # an incrementing function \nevent!(rtc, fun(f, a), every, 1)  # increment now and then every second \nsleep(3)                          # sleep 3 seconds\na[1]                              # query a\nstopRTClock(rtc)                  # stop the clock","category":"page"},{"location":"clocks/#Clock-Operation","page":"Clocks","title":"Clock Operation","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"Virtual clocks can be run, stopped or stepped through and thereby used to simulate chains of events.","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"run!\n@run!\nincr!\nresetClock!\nstop!\nresume!\nsync!","category":"page"},{"location":"clocks/#DiscreteEvents.run!","page":"Clocks","title":"DiscreteEvents.run!","text":"run!(clk::Clock, duration::N) where {N<:Number}\n\nRun a simulation for a given duration.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.@run!","page":"Clocks","title":"DiscreteEvents.@run!","text":"@run! clk t\n\nRun a clock clk for a duration t. \n\n\n\n\n\n","category":"macro"},{"location":"clocks/#DiscreteEvents.incr!","page":"Clocks","title":"DiscreteEvents.incr!","text":"incr!(clk::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.resetClock!","page":"Clocks","title":"DiscreteEvents.resetClock!","text":"resetClock!(clk::Clock, Œît::T=0.01; t0::U=0; <keyword arguments>) where {T<:Number, U<:Number}\n\nReset a clock.\n\nArguments\n\nclk::Clock\nŒît::T=0.01: sample rate\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Œît::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock 1: state=:idle, t=60.0s, Œît=1.0s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> resetClock!(c)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.\"\n\njulia> c\nClock 1: state=:idle, t=0.0, Œît=0.01, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\nresetClock!(rtc::RTClock)\n\nReset a real time clock. Set its time to zero and delete all scheduled and sampling events.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.stop!","page":"Clocks","title":"DiscreteEvents.stop!","text":"stop!(clk::Clock)\n\nStop a running simulation.\n\n\n\n\n\nStop a Prc\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.resume!","page":"Clocks","title":"DiscreteEvents.resume!","text":"resume!(clk::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#DiscreteEvents.sync!","page":"Clocks","title":"DiscreteEvents.sync!","text":"sync!(clk::Clock, to::Clock=ùê∂)\n\nForce a synchronization of two clocks. Change all registered times of clk accordingly. Convert or force clk.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"clocks/#Time-Units","page":"Clocks","title":"Time Units","text":"","category":"section"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"You can set time units of a virtual clock:","category":"page"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"setUnit!","category":"page"},{"location":"clocks/#DiscreteEvents.setUnit!","page":"Clocks","title":"DiscreteEvents.setUnit!","text":"setUnit!(clk::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nclk::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using DiscreteEvents, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60)     # setup a new clock with t0=60\nClock 1: state=:idle, t=60.0, Œît=0.01, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tau(c)               # current time is 60.0 NoUnits\n60.0\n\njulia> setUnit!(c, s)       # set clock unit to Unitful.s\n60.0 s\n\njulia> tau(c)               # current time is now 60.0 s\n60.0 s\n\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\n\njulia> tau(c)               # current time is now 1.0 minute\n1.0 minute\n\njulia> isa(tau(c), Time)\ntrue\n\njulia> uconvert(s, tau(c))  # ... which can be converted to other time units\n60.0 s\n\njulia> tau(c).val           # it has a value of 1.0\n1.0\n\njulia> c.time               # internal clock time is set to 1.0 (a Float64)\n1.0\n\njulia> c.unit               # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"clocks/","page":"Clocks","title":"Clocks","text":"note: Note\nThis is not yet implemented for parallel clocks!","category":"page"},{"location":"processes/#Processes","page":"Processes","title":"Processes","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Processes are typical event sequences running as asynchronous tasks.","category":"page"},{"location":"processes/#Process-Setup","page":"Processes","title":"Process Setup","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"To setup a process, you","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"implement it in a function taking a Clock variable as its first argument,\nwrap it into Prc and start it as an asynchronous task with process!. The @process macro does this in one call.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"Prc\nprocess!\n@process","category":"page"},{"location":"processes/#DiscreteEvents.Prc","page":"Processes","title":"DiscreteEvents.Prc","text":"Prc(id, f, arg...; kw...)\nPrc(f, arg...; kw...)\n\nPrepare a function to run as a process and get registered to a clock.\n\nArguments, Fields\n\nid: some unique identification for registration, \nf::Function: a function f(clk, arg...; kw...), must take clk    (a Clock) as its first argument,\narg...: further arguments to f\nkw...: keyword arguments to f\n\nFields identified during registration\n\nid: if it is not provided, some integer will be calculated    for it during registration,\ntask::Union{Task,Nothing}: a task structure used for diagnosis,\nclk::Union{AbstractClock,Nothing}: clock where the process is    registered,\n\nnote: The clock is identified dynamically!\nThe clock clk where a process runs and gets registered is identified during process startup and then passed as 1st  argument to f. \n\n\n\n\n\n","category":"type"},{"location":"processes/#DiscreteEvents.process!","page":"Processes","title":"DiscreteEvents.process!","text":"process!([clk], prc, cycles; <keyword arguments>)\n\nRegister a Prc to a clock, start an asynchronous task  executing the process function in a loop and return the id it  was registered with. It can then be found under clk.processes[id].\n\nArguments\n\nc<:AbstractClock: if not provided, the process runs under ùê∂,\nprc::Prc: it contains a function and its arguments,\ncycles<:Number=Inf: number of loop cycles the process should run,\n\nKeyword arguments\n\ncid::Int=clk.id: if cid ‚â† clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.\n\n\n\n\n\n","category":"function"},{"location":"processes/#DiscreteEvents.@process","page":"Processes","title":"DiscreteEvents.@process","text":"@process f(arg...) [cycles]\n\nCreate a process from a function f(arg...).\n\nWrap a function and its arguments in a Prc and start it with  process!.\n\nArguments\n\nf: a function,\narg...: arguments, the first argument must be an AbstractClock,\ncycles::Int: the number of cycles, f should run.\n\nReturns\n\nan Int process id.\n\n\n\n\n\n","category":"macro"},{"location":"processes/#Delay-and-Wait-‚Ä¶","page":"Processes","title":"Delay and Wait ‚Ä¶","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Functions implementing processes create events implicitly by calling delay! or wait! on their clock. They wait for resources to be available by using take! and put! on  channels. Those calls will suspend an asynchronous task until a given time or until certain conditions are met or requested resources are available.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"delay!\n@delay\nwait!\n@wait","category":"page"},{"location":"processes/#DiscreteEvents.delay!","page":"Processes","title":"DiscreteEvents.delay!","text":"delay!(clk, Œît)\ndelay!(clk, T, t)\n\nDelay (suspend) a process for a time interval Œît on the clock clk.\n\nArguments\n\nclk::Clock,\nŒît: time interval, Number or Distribution,\nT::Timing: only until is accepted,\nt: time delay, Number or Distribution.\n\n\n\n\n\n","category":"function"},{"location":"processes/#DiscreteEvents.@delay","page":"Processes","title":"DiscreteEvents.@delay","text":"@delay clk Œît\n@delay clk until t\n\nDelay a process on a clock clk for a time interval Œît or until a time t.\n\n\n\n\n\n","category":"macro"},{"location":"processes/#DiscreteEvents.wait!","page":"Processes","title":"DiscreteEvents.wait!","text":"wait!(clk, cond)\n\nDelay (suspend) a process on a clock clk until a condition has become true.\n\nArguments\n\nclk::Clock,\ncond<:Action: a condition, true if all expressions or functions therein return true.\n\n\n\n\n\n","category":"function"},{"location":"processes/#DiscreteEvents.@wait","page":"Processes","title":"DiscreteEvents.@wait","text":"@wait clk f(arg...)\n\nConditionally wait on a clock clk until f(arg...) returns true.\n\n\n\n\n\n","category":"macro"},{"location":"processes/#Interrupts","page":"Processes","title":"Interrupts","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"If other events (e.g. representing reneging customers, failures) interrupt the typical event sequence of a process, it is waiting for a time or condition or resource and not ready to respond to something else. Processes therefore must use exception handling to handle unexpected events.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"PrcException\ninterrupt!","category":"page"},{"location":"processes/#DiscreteEvents.PrcException","page":"Processes","title":"DiscreteEvents.PrcException","text":"PrcException(event, value)\n\nAn exception to be thrown at processes.\n\nArguments, fields\n\nevent: deliver an event to the interrupted task\nvalue: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"processes/#DiscreteEvents.interrupt!","page":"Processes","title":"DiscreteEvents.interrupt!","text":"interrupt!(p::Prc, ev, value)\n\nInterrupt a Prc by throwing a PrcException to it.\n\n\n\n\n\n","category":"function"},{"location":"processes/","page":"Processes","title":"Processes","text":"An example at DiscreteEventsCompanion illustrates how to handle interrupts to a process. Things can get messy quickly if there are several unusual events which have to be handled in a process.","category":"page"},{"location":"processes/#Now","page":"Processes","title":"Now","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"Processes (or asynchronous tasks in general) transfer IO-operations with a now! call to the (master) clock to ensure they get executed at current clock time. As a convenience you can print directly to the clock.","category":"page"},{"location":"processes/","page":"Processes","title":"Processes","text":"now!\nprint(::Clock, ::IO, ::Any, ::Any)\nprintln(::Clock, ::IO, ::Any, ::Any)","category":"page"},{"location":"processes/#DiscreteEvents.now!","page":"Processes","title":"DiscreteEvents.now!","text":"now!(clk::Clock, ex::A) where {A<:Action}\n\nTransfer an IO-operation ex to clk or if it is a parallel clock to the master clock (on thread 1). The clock executes it before  proceeding to the next time step.\n\n\n\n\n\n","category":"function"},{"location":"processes/#Base.print-Tuple{Clock, IO, Any, Any}","page":"Processes","title":"Base.print","text":"print(clk::Clock, [io::IO], x, xs...)\n\nCreate a now! event to a busy clock clk to print(x, xs...)  to io (or to stdout).\n\nIf the clock is not busy, x and xs... are printed as usual. print(clk) still prints repr(clk).\n\n\n\n\n\n","category":"method"},{"location":"processes/#Base.println-Tuple{Clock, IO, Any, Any}","page":"Processes","title":"Base.println","text":"println(clk::Clock, [io::IO], xs...)\n\nCreate a now! event to a busy clock clk to println(x, xs...)  to io (or to stdout).\n\nIf the clock is not busy, x and xs... are printed as usual. println(clk) still prints repr(clk).\n\n\n\n\n\n","category":"method"},{"location":"processes/#Examples","page":"Processes","title":"Examples","text":"","category":"section"},{"location":"processes/","page":"Processes","title":"Processes","text":"The A-B Call Center Problem illustrates how to implement and setup a process. ","category":"page"},{"location":"#DiscreteEvents.jl","page":"Home","title":"DiscreteEvents.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for discrete event generation and simulation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiscreteEvents.jl [1] introduces a clock and allows to schedule arbitrary functions or expressions as actions on the clock's timeline. It provides simple, yet powerful ways to model and simulate discrete event systems (DES).","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NEWS: What is new about this version?\nIntroduction: Get an overview and learn the basics.\nManual: Get detailed informations about types, functions and macros.\nInternals: some internal types and functions.\nTroubleshooting: If something doesn't work as expected.\nVersion history: A list of features and changes.","category":"page"},{"location":"#Development","page":"Home","title":"Development","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiscreteEvents is in development. Please use, test and help  evolve it. Its GitHub repository is at https://github.com/JuliaDynamics/DiscreteEvents.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: DiscreteEvents.jl as of v0.3 has been renamed from Simulate.jl, see issue #13.","category":"page"}]
}
