var documenterSearchIndex = {"docs":
[{"location":"history/#Version-history-1","page":"History","title":"Version history","text":"","category":"section"},{"location":"history/#v0.2.0-(development)-1","page":"History","title":"v0.2.0 (development)","text":"","category":"section"},{"location":"history/#","page":"History","title":"History","text":"next: conditional events with event!(sim, ex, cond) and wait!(cond) where cond::Union{SimExpr, Array{SimExpr,1}},\nevent! can be called without the first clock argument, it then goes to ùê∂.\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: ùêÖ for SimFunction and ùêè for SimProcess\nintroduced process-based simulation with SimProcess and process!,\nextensive documentation\nmore examples","category":"page"},{"location":"history/#v0.1.0-1","page":"History","title":"v0.1.0","text":"","category":"section"},{"location":"history/#","page":"History","title":"History","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions.\nintroduced a central clock variable ùê∂\nClock state machine with init!, run!, incr!, stop!, resume!\nLogger and logging functions\nfirst documentation\nfirst examples\nCI and development setup","category":"page"},{"location":"examples/examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"The examples are intended to show, how Simulate.jl can be used and how the different approaches to modeling and simulation can be effectively combined.","category":"page"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Pages = [\"greeting.md\", \"singleserver.md\", \"tabletennis.md\"]","category":"page"},{"location":"examples/examples/#Notebooks-1","page":"Examples","title":"Notebooks","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"greeting.ipynb: a first illustration\ntabletennis.ipynb: a simple table tennis simulation.\nsingleserver.ipynb: single server modeling, simulation and analysis.\npostoffice.ipynb: process based simulation of a post office,\ndicegame.ipynb: process based simulation of Goldratt's dice game - must yet be adopted to Simulate!","category":"page"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Jupyter-notebooks are here in the repo","category":"page"},{"location":"examples/examples/#Programs-1","page":"Examples","title":"Programs","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Julia programs/.jl-files are here in the repo.","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"CurrentModule = Simulate","category":"page"},{"location":"internals/#Module-1","page":"Internals","title":"Module","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Simulate","category":"page"},{"location":"internals/#Simulate.Simulate","page":"Internals","title":"Simulate.Simulate","text":"Simulate\n\nA Julia package for discrete event simulation based on state machines.\n\n\n\n\n\n","category":"module"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The module contains two main types: Clock and Logger. Both are implemented as state machines. The implementation functions and types are not exported. The exported functions documented above under Usage are commands to the internal state machines.","category":"page"},{"location":"internals/#State-machines-1","page":"Internals","title":"State machines","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We have some definitions for them to work.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEngine","category":"page"},{"location":"internals/#Simulate.SEngine","page":"Internals","title":"Simulate.SEngine","text":"supertype for state machines in Sim.jl\n\n\n\n\n\n","category":"type"},{"location":"internals/#States-1","page":"Internals","title":"States","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined states for state machines.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SState\nUndefined\nIdle\nEmpty\nBusy\nHalted","category":"page"},{"location":"internals/#Simulate.SState","page":"Internals","title":"Simulate.SState","text":"supertype for states\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Undefined","page":"Internals","title":"Simulate.Undefined","text":"a state machine is undefined (after creation)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Idle","page":"Internals","title":"Simulate.Idle","text":"a state machine is idle\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Empty","page":"Internals","title":"Simulate.Empty","text":"a state machine is empty\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Busy","page":"Internals","title":"Simulate.Busy","text":"a state machine is busy\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Halted","page":"Internals","title":"Simulate.Halted","text":"a state machine is halted\n\n\n\n\n\n","category":"type"},{"location":"internals/#Events-1","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined events.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEvent\nInit\nSetup\nSwitch\nLog\nStep\nRun\nStart\nStop\nResume\nClear","category":"page"},{"location":"internals/#Simulate.SEvent","page":"Internals","title":"Simulate.SEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Init","page":"Internals","title":"Simulate.Init","text":"Init(info): Init event with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Setup","page":"Internals","title":"Simulate.Setup","text":"Setup(vars::Array{Symbol,1}, scope::Module): setup a logger with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Switch","page":"Internals","title":"Simulate.Switch","text":"Switch(to): switch to some other mode\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Log","page":"Internals","title":"Simulate.Log","text":"Log(): record command for logging\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Step","page":"Internals","title":"Simulate.Step","text":"Step(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Run","page":"Internals","title":"Simulate.Run","text":"Run(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Start","page":"Internals","title":"Simulate.Start","text":"Start(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Stop","page":"Internals","title":"Simulate.Stop","text":"Stop(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Resume","page":"Internals","title":"Simulate.Resume","text":"Resume(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Clear","page":"Internals","title":"Simulate.Clear","text":"Clear(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Transition-functions-1","page":"Internals","title":"Transition functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In state machines transitions occur depending on states and events. The different transitions are described through different methods of the step!-function.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"step!","category":"page"},{"location":"internals/#Simulate.step!","page":"Internals","title":"Simulate.step!","text":"step!(A::SEngine, q::SState, œÉ::SEvent)\n\nDefault transition for clock and logger.\n\nThis is called if no otherwise defined transition occurs.\n\nArguments\n\nA::SEngine: state machine for which a transition is called\nq::SState:  state of the state machine\nœÉ::SEvent:  event, triggering the transition\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, ::Init)\n\ninitialize a clock.\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, œÉ::Union{Step,Run})\n\nif uninitialized, initialize and then Step or Run.\n\n\n\n\n\nstep!(sim::Clock, ::Union{Idle,Busy,Halted}, ::Step)\n\nstep forward to next tick or scheduled event. At a tick evaluate all sampling expressions, or, if an event is encountered evaluate the event expression.\n\nThe internal clock times sim.tev and sim.tsa must always be set to be at least sim.time.\n\n\n\n\n\nstep!(sim::Clock, ::Idle, œÉ::Run)\n\nRun a simulation for a given duration.\n\nThe duration is given with Run(duration). Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\nstep!(sim::Clock, ::Busy, ::Stop)\n\nStop the clock.\n\n\n\n\n\nstep!(sim::Clock, ::Halted, ::Resume)\n\nResume a halted clock.\n\n\n\n\n\nstep!(sim::Clock, q::SState, œÉ::SEvent)\n\ncatch all step!-function.\n\n\n\n\n\nstep!(A::Logger, ::Undefined, œÉ::Init)\n\nInitialize a logger.\n\n\n\n\n\nstep!(A::Logger, ::Empty, œÉ::Setup)\n\nSetup a logger with logging variables. They are given by Setup(vars, scope).\n\n\n\n\n\nstep!(A::Logger, ::Idle, ::Clear)\n\nClear the last record and the data table of a logger.\n\n\n\n\n\nstep!(A::Logger, ::Idle, œÉ::Log)\n\nLogging event.\n\n\n\n\n\nstep!(A::Logger, ::Idle, œÉ::Switch)\n\nSwitch the operating mode of a logger by Switch(to).\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"internals/#Other-internal-types-and-functions-1","page":"Internals","title":"Other internal types and functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SimEvent\nSample\nsconvert\nsimExec\nnextevent\nnextevtime\nchecktime\nsetTimes\nstartup!\nloop","category":"page"},{"location":"internals/#Simulate.SimEvent","page":"Internals","title":"Simulate.SimEvent","text":"SimEvent(ex::Array{SimExpr, 1}, scope::Module, t::Float64, Œît::Float64)\n\nCreate a simulation event: a SimExpr or an array of SimExpr to be executed at event time.\n\nArguments\n\nex::Array{SimExpr, 1}: an array of SimExpr to be evaluated at event time,\nscope::Module: evaluation scope,\nt::Float64: event time,\nŒît::Float64: repeat rate with which the event gets repeated.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Sample","page":"Internals","title":"Simulate.Sample","text":"Sample(ex::SimExpr, scope::Module)\n\nCreate a sampling expression.\n\nArguments\n\nex::SimExpr: expression or SimFunction to be called at sample time\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.sconvert","page":"Internals","title":"Simulate.sconvert","text":"sconvert(ex::Union{SimExpr,Array,Tuple})::Array{SimExpr,1}\n\nconvert a SimExpr or an array or a tuple of it to an Array{SimExpr,1}\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.simExec","page":"Internals","title":"Simulate.simExec","text":"simExec(ex::Union{SimExpr, Array{SimExpr,1}}, m::Module=Main)\n\nevaluate the event expressions or SimFunctions.\n\nReturn\n\nthe evaluated value or a tuple of evaluated values\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevent","page":"Internals","title":"Simulate.nextevent","text":"nextevent(sim::Clock)\n\nReturn the next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevtime","page":"Internals","title":"Simulate.nextevtime","text":"nextevtime(sim::Clock)\n\nReturn the internal time (unitless) of next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.checktime","page":"Internals","title":"Simulate.checktime","text":"checktime(sim::Clock, t::Number)::Float64\n\ncheck t given according to clock settings and return value\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.setTimes","page":"Internals","title":"Simulate.setTimes","text":"setTimes(sim::Clock)\n\nset clock times for next event or sampling action. The internal clock times sim.tev and sim.tsa must always be set to be at least sim.time.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.startup!","page":"Internals","title":"Simulate.startup!","text":"startup!(p::SimProcess)\n\nStart a SimProcess as a task in a loop.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.loop","page":"Internals","title":"Simulate.loop","text":"loop(p::SimProcess)\n\nPut a SimProcess in a loop, which can be broken by a SimException.\n\n\n\n\n\n","category":"function"},{"location":"troubleshooting/#Troubleshooting-1","page":"Troubeshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#A-SimProcess-fails-1","page":"Troubeshooting","title":"A SimProcess fails","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubeshooting","title":"Troubeshooting","text":"You can check, if that is the case: if ùê∂ is your clock, you get the list of all running processes with ùê∂.processes. Than you can look at the failed process with ùê∂.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/#","page":"Troubeshooting","title":"Troubeshooting","text":"julia> ùê∂.processes\nDict{Any,SimProcess} with 2 entries:\n  2 => SimProcess(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{‚Ä¶\n  1 => SimProcess(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel‚Ä¶\njulia> ùê∂.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\nClosest candidates are:\n  round(::Float64, ::RoundingMode{:Nearest}) at float.jl:370\n  round(::Float64, ::RoundingMode{:Up}) at float.jl:368\n  round(::Float64, ::RoundingMode{:Down}) at float.jl:366\n  ...\nlogevent(::Int64, ::Channel{Any}, ::String, ::Int64) at ./In[6]:12\npeople(::Channel{Any}, ::Channel{Any}, ::Float64) at ./In[17]:8\nloop(::SimProcess) at /Users/paul/.julia/packages/Simulate/BOeZP/src/process.jl:37\n(::getfield(Simulate, Symbol(\"##19#20\")){SimProcess})() at ./task.jl:268","category":"page"},{"location":"examples/singleserver/#Single-server-1","page":"Single server","title":"Single server","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: single server)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Initially there are no jobs in the queue Q and the machine M is idle.\nJobs arrive with an inter-arrival-time t_aand are added to Q.\nIf M is idle, it loads a job, changes to busy and executes the job with service time t_s.\nAfter that it changes to idle and, if Q is not empty, it loads the next job.","category":"page"},{"location":"examples/singleserver/#Implementing-it-1","page":"Single server","title":"Implementing it","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use this simple example for illustration of how it can be modeled, simulated and analyzed using Sim.jl. First we have to import the necessary modules:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"using Simulate, Random, Distributions, DataFrames, Plots, LaTeXStrings\npyplot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We have to define some data structures, variables and a function for collecting stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"abstract type MState end\n\nstruct Idle <: MState end\nstruct Busy <: MState end\n\nmutable struct Job\n    no::Int64\n    ts::Float64\n    t1::Float64\n    t2::Float64\n    t3::Float64\nend\n\nmutable struct Machine\n    state::MState\n    job\nend\n\nQ = Job[]   # input queue\nS = Job[]   # stock\nM = Machine(Idle(), 0)\ndf = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\ncount = 1\nprinting = true\n\nstats() = push!(df, (œÑ(), length(Q), M.state == Busy() ? 1 : 0, length(S)))","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can model our system activity-based und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use the arrival-function for modeling arrival rate t_a with an Erlang and service time t_s with a Normal distribution. We determine the capacity of the server with a c variable such that c  1 gives us overcapacity and c = 1 means that mean service time equals mean arrival rate bart_s = bart_a.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function arrive(Œº, œÉ, c)\n    @assert Œº ‚â• 1 \"Œº must be ‚â• 1\"\n    ts = rand(Normal(Œº, œÉ))/c\n    job = Job(count, ts, œÑ(), 0, 0)\n    global count += 1\n    push!(Q, job)\n    ta = rand(Erlang())*Œº\n    event!(ùê∂, SimFunction(arrive, Œº, œÉ, c), after, ta)  # we schedule the next arrival\n    printing ? println(œÑ(), \": job $(job.no) has arrived\") : nothing # œÑ() is the current time\n    if M.state == Idle()\n        load()\n    else\n        stats()\n    end\nend\n\nfunction load()\n    M.state = Busy()\n    M.job = popfirst!(Q)\n    M.job.t2 = œÑ()\n    event!(ùê∂, SimFunction(unload), after, M.job.ts)  # we schedule the unload\n    printing ? println(œÑ(), \": job $(M.job.no) has been loaded\") : nothing\n    stats()\nend\n\nfunction unload()\n    M.state = Idle()\n    M.job.t3 = œÑ()\n    push!(S, M.job)\n    printing ? println(œÑ(), \": job $(M.job.no) has been finished\") : nothing\n    stats()\n    M.job = 0\n    if !isempty(Q)\n        load()\n    end\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We want to collect stats() at a sample rate of 0.1:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"sample_time!(ùê∂, 0.1)  # we determine the sample rate\nSim.sample!(ùê∂, SimFunction(stats));  # we register stats() as sampling function","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and mu = 5, sigma = 15 and c = 1 and let our system run for 30 minutes (let's assume our time unit be minutes):","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Random.seed!(2019)\narrive(5, 1/5, 1)  # we schedule the first event\nrun!(ùê∂, 30)        # and run the simulation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This will give us as output:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"0: job 1 has arrived\n0: job 1 has been loaded\n4.947453062901819: job 1 has been finished\n8.515206032139384: job 2 has arrived\n8.515206032139384: job 2 has been loaded\n8.56975795472613: job 3 has arrived\n8.666481204359087: job 4 has arrived\n10.338522593089287: job 5 has arrived\n11.021099411385869: job 6 has arrived\n13.267881315092211: job 7 has arrived\n13.703372376147774: job 2 has been finished\n13.703372376147774: job 3 has been loaded\n18.726550601155594: job 3 has been finished\n18.726550601155594: job 4 has been loaded\n19.55941423914075: job 8 has arrived\n19.58302738045451: job 9 has arrived\n20.543366077813385: job 10 has arrived\n22.752994020639125: job 11 has arrived\n23.563550850400553: job 4 has been finished\n23.563550850400553: job 5 has been loaded\n23.960464112286694: job 12 has arrived\n26.84742108339802: job 13 has arrived\n28.18186102251928: job 5 has been finished\n28.18186102251928: job 6 has been loaded\n\"run! finished with 17 events, simulation time: 30.0\"","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Using our collected data, we can plot the simulation model trajectory:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function trajectory_plot()\n    p1 = plot(df.time, df.buffer, ylabel=\"buffer\", fill=(0,0.1,:blue))\n    p2 = plot(df.time, df.machine, ylabel=\"machine\", fill=(0,0.1,:blue))\n    p3 = plot(df.time, df.finished, xlabel=\"time [min]\", ylabel=\"stock\", fill=(0,0.1,:blue))\n    plot(p1,p2,p3, layout=(3,1), legend=false)\nend\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 1)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 \"minutes\".","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"printing = false\nrun!(ùê∂, 970)        # we continue the simulation\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren't very instructive, so let's compare lead time W and number of jobs in the system L = textbuffer_size + textmachine_load:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function WvsL() # get more instructive info from simulation run\n    t = [j.t1 for j ‚àà S]\n    W = [j.t3 - j.t1 for j ‚àà S]\n    ts = [j.t3 - j.t2 for j ‚àà S]\n    subs = [i ‚àà t for i ‚àà df.time]\n    L = (df.buffer + df.machine)[subs]\n    l = df.machine[subs]\n    DataFrame(time=t, load=l, W=W, L=L, ts=ts)\nend\nd = WvsL()\nplot(d.time, d.W, label=\"W [min]\", xlabel=\"time [min]\", lw=2, legend=:topleft, title=\"L and W over time\")\nplot!(d.time, d.L, label=\"L [jobs]\", lw=2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: L and W over time)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Lead time W and unfinished jobs L are clearly increasing, the system is not stationary and gets jammed over time. Let's collect some stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"collect_stats() =\n    (Lm = mean(d.L), Wm = mean(d.W), Œ∑ = mean(df.machine), tsm = mean(d.ts))\ncollect_stats()\n(Lm = 16.21105527638191, Wm = 78.8196419189297, Œ∑ = 0.9778719397363466, tsm = 5.003771234356064)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Server load of overlineŒ∑  98 is great, but the mean queue length overlineL of 16 and mean lead time overlineW  79 min are way too long for a service time of t_s  5 min. So let's analyze the dependency of mean queue length overlineL on server capacity c. For that we can manipulate the server capacity in the arrival function and collect the results in a table:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], Œ∑=Float64[], tsm=Float64[])\nfor c ‚àà collect(0.97:0.01:1.7)\n    global Q = Job[]   # input queue\n    global S = Job[]   # stock\n    global M = Machine(Idle(), 0)\n    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\n    global count = 1\n\n    reset!(ùê∂)                            # reset ùê∂\n    sample_time!(ùê∂, 1)                   # set sample rate to 1\n    Sim.sample!(ùê∂, SimFunction(stats))   # register the stats() function for sampling\n\n    Random.seed!(2019)\n    arrive(5, 1/5, c)\n    run!(ùê∂, 1000)                        # run another simulation for 1000 \"min\"\n    global d = WvsL()\n    s = collect_stats()\n    push!(df1, (c, s.Lm, s.Wm, s.Œ∑, s.tsm))\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can look at it in a scatter plot:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.c, df1.Wm, title=L\"\\overline{W}\"*\" and \"*L\"\\overline{L}\"*\" over server capacity\",\n    xlabel=\"server capacity\", marker = (:o, 3, 0.4, :blue), label=L\"\\overline{W}\"*\" [min]\")\nscatter!(df1.c, df1.Lm, marker = (:x, 4), label=L\"\\overline{L}\"*\" [jobs]\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: W and L over server capacity)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We need to increase server capacity much in order to avoid long queues and waiting times.","category":"page"},{"location":"examples/singleserver/#How-about-Little's-law?-1","page":"Single server","title":"How about Little's law?","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"overlineW and overlineL seem to be proportional. This is stated by Little's law:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"beginequation\nL = lambdatimes W\nendequation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"for stationary systems with lambda = arrival rate. In our case lambda = t_a = 5. Let's look at it:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.Lm, df1.Wm, xlabel=L\"\\overline{L}\"*\" [jobs]\", ylabel=L\"\\overline{W}\"*\" [min]\",\n    marker = (:o, 4, 0.4, :blue), label=\"data\", title=\"Little's law\", legend=:topleft)\nplot!(df1.Lm, df1.Lm*5, label=\"theory \"*L\"(\\overline{L}\\times 5)\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: Little's law)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little's law seems not to be a bad one. In order to analyze stability and stationarity and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with Simulate.jl ...","category":"page"},{"location":"examples/singleserver/#-1","page":"Single server","title":"üòÑ","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"pb, 2019-11-01","category":"page"},{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = Simulate","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Simulate.jl is not yet an registered package and is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using Simulate","category":"page"},{"location":"usage/#Modeling-and-simulation-1","page":"Usage","title":"Modeling and simulation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A virtual Clock allows to schedule Julia functions or expressions as timed events or as sampling actions, which occur at predefined clock ticks. When we run the Clock, it fires the events at their scheduled times and executes the sampling actions at each tick.","category":"page"},{"location":"usage/#Silly-example-1","page":"Usage","title":"Silly example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"m = @__MODULE__ # catching the current module is needed for documentation\nusing Printf\ncomm = [\"Hi, nice to meet you!\", \"How are you?\", \"Have a nice day!\"];\ngreet(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", œÑ(), name, comm[n])\nfunction foo(n) # 1st passerby\n    greet(\"Foo\", n)\n    event!(ùê∂, :(bar($n)), after, 2*rand(), scope = m)\nend\nfunction bar(n) # 2nd passerby\n    greet(\"Bar\", n)\n    if n < 3\n       event!(ùê∂, :(foo($n+1)), after, 2*rand(), scope = m)\n    else\n       println(\"bye bye\")\n    end\nend\nevent!(ùê∂, :(foo(1)), at, 10*rand(), scope = m); # create an event for a start\nrun!(ùê∂, 20) # and run the simulation","category":"page"},{"location":"usage/#Types-and-constants-1","page":"Usage","title":"Types and constants","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Clock\nTiming\nSimFunction\nSimExpr\nSimProcess\nSimException","category":"page"},{"location":"usage/#Simulate.Clock","page":"Usage","title":"Simulate.Clock","text":"Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)\n\nCreate a new simulation clock.\n\nArguments\n\nŒît::Number=0: time increment\nt0::Number=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by\n\nsetting e.g. unit=minute or implicitly by giving Œît as a time or else setting t0 to a time, e.g. t0=60s.\n\nIf no Œît is given, the simulation doesn't tick, but jumps from event to event. Œît can be set later with sample_time!.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> init!(c)\nSimulate.Idle()\njulia> c = Clock(1s, unit=minute)\nClock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, processes: 0, sampling: 0, sample rate Œît=0.016666666666666666\njulia> c = Clock(1s)\nClock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, processes: 0, sampling: 0, sample rate Œît=1.0\njulia> c = Clock(t0=60s)\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> c = Clock(1s, t0=1hr)\nClock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, processes: 0, sampling: 0, sample rate Œît=1.0\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.Timing","page":"Usage","title":"Simulate.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time\nafter: schedule an event a given time after current time\nevery: schedule an event every given time from now on\nbefore: a timed condition is true before a given time.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.SimFunction","page":"Usage","title":"Simulate.SimFunction","text":"SimFunction(func::Function, arg...; kw...)\nùêÖ(func::Function, arg...; kw...)\n\nPrepare a function to be called as event in a simulation (bold ùêÖ is \\bfF+Tab).\n\nArguments\n\nfunc::Function: function to be executed at a later simulation time\narg...: arguments to the function\nkw...: keyword arguments\n\nBe aware that, if the variables stored in a SimFunction are composite types, they can change until they are evaluated later by func. But that's the nature of simulation.\n\nExample\n\njulia> using Simulate\n\njulia> f(a,b,c; d=4, e=5) = a+b+c+d+e  # define a function\nf (generic function with 1 method)\n\njulia> sf = SimFunction(f, 10, 20, 30, d=14, e=15)  # store it as SimFunction\nSimFunction(f, (10, 20, 30), Base.Iterators.Pairs(:d => 14,:e => 15))\n\njulia> sf.func(sf.arg...; sf.kw...)  # and it can be executed later\n89\n\njulia> d = Dict(:a => 1, :b => 2) # now we set up a dictionary\nDict{Symbol,Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> f(t) = t[:a] + t[:b] # and a function adding :a and :b\nf (generic function with 2 methods)\n\njulia> f(d)  # our add function gives 3\n3\n\njulia> ff = SimFunction(f, d)   # we set up a SimFunction\nSimFunction(f, (Dict(:a => 1,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> d[:a] = 10  # later somehow we need to change d\n10\n\njulia> ff  # our SimFunction ff has changed too\nSimFunction(f, (Dict(:a => 10,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> ff.func(ff.arg...; ff.kw...)  # and calling it gives a different result\n12\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.SimExpr","page":"Usage","title":"Simulate.SimExpr","text":"SimExpr = Union{Expr, SimFunction}\n\nA type which is either a SimFunction or any Julia expression Expr.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Simulate.SimProcess","page":"Usage","title":"Simulate.SimProcess","text":"SimProcess( id, func::Function, body,\n            input::Channel=Channel(Inf), output::Channel=Channel(Inf),\n            arg...; kw...)\nùêè(id, func::Function, body,\n  input::Channel=Channel(Inf), output::Channel=Channel(Inf), arg...; kw...)\n\nPrepare a function to run as a process in a simulation (bold ùêè is \\bfP+Tab).\n\nArguments\n\nid: some unique identification\nfunc::Function: a function f(in::Channel, out::Channel, arg...; kw...)\ninput::Channel=Channel(Inf): fs input channel\noutput::Channel=Channel(Inf): fs output channel\narg...: further arguments to f\nkw...: keyword arguments to f\n\nNote: A function f running as a SimProcess is put in a loop. So it has to give back control by e.g. doing a take!(input) on its input channel or by calling delay! etc., which will yield it. Otherwise it will after start starve everything else!\n\n#Examples\n\n\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.SimException","page":"Usage","title":"Simulate.SimException","text":"SimException(ev::SEvent, value=nothing)\n\nDefine a SimException, which can be thrown to processes.\n\nParameters\n\nev::SEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"usage/#Central-time-1","page":"Usage","title":"Central time","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"ùê∂","category":"page"},{"location":"usage/#Simulate.ùê∂","page":"Usage","title":"Simulate.ùê∂","text":"ùê∂\nClk\n\nitalic ùê∂ (\\itC+Tab) or Clk is the central Clock()-variable.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> ùê∂  # central clock\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> Clk  # alias\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> ùê∂.time\n0.0\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Functions-1","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"setUnit!\nœÑ\nsample_time!\nevent!\nsample!\nprocess!\ndelay!\nstart!\nincr!\nrun!\nstop!\nresume!\nsync!\nreset!","category":"page"},{"location":"usage/#Simulate.setUnit!","page":"Usage","title":"Simulate.setUnit!","text":"setUnit!(sim::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nsim::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful\n\nTime unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60) # setup a new clock with t0=60\nClock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> œÑ(c) # current time is 60.0 NoUnits\n60.0\njulia> setUnit!(c, s)  # set clock unit to Unitful.s\n60.0 s\njulia> œÑ(c) # current time is now 60.0 s\n60.0 s\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\njulia> œÑ(c) # current time is now 1.0 minute\n1.0 minute\njulia> typeof(œÑ(c))  # œÑ(c) now returns a time Quantity ...\nQuantity{Float64,ùêì,Unitful.FreeUnits{(minute,),ùêì,nothing}}\njulia> isa(œÑ(c), Time)\ntrue\njulia> uconvert(s, œÑ(c)) # ... which can be converted to other time units\n60.0 s\njulia> œÑ(c).val  # it has a value of 1.0\n1.0\njulia> c.time  # internal clock time is set to 1.0 (is a Float64)\n1.0\njulia> c.unit  # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.œÑ","page":"Usage","title":"Simulate.œÑ","text":"œÑ(sim::Clock=ùê∂)\ntau(sim::Clock=Tau)\n\nReturn the current simulation time (œÑ=\tau+Tab).\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> œÑ() # gives the central time\n0.0\njulia> tau() # alias, gives the central time\n0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sample_time!","page":"Usage","title":"Simulate.sample_time!","text":"sample_time!(sim::Clock, Œît::Number)\n\nset the clock's sampling time starting from now (œÑ(sim)).\n\nArguments\n\nsim::Clock\nŒît::Number: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.event!","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64\nevent!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)::Float64\nevent!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple})::Float64\nevent!(ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)\nevent!(ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)\nevent!(ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\n\nSchedule an event for a given simulation time or under a condition.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to ùê∂,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\nt::Float64 or t::Time: simulation time,\nT::Timing: a timing, at, after or every (before behaves like at),\ncond::{SimExpr, Array, Tuple}: a condition is an expression or SimFunction\n\nor an array or tuple of them. It is only True if all expressions or SimFunctions return true.\n\nscope::Module=Main: scope for the expressions to be evaluated\ncycle::Float64=0.0: repeat cycle time for an event\n\nreturns\n\nScheduled internal simulation time (unitless) for that event. May return a time > t from repeated applications of nextfloat(t) if there are events scheduled for t.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\njulia> event!(ùê∂, SimFunction(myfunc, 1, 2), 1) # a 1st event\n1.0\njulia> event!(ùê∂, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time\n1.0000000000000002\njulia> event!(ùê∂, SimFunction(myfunc, 3, 4), 1s)\nWarning: clock has no time unit, ignoring units\n1.0000000000000004\njulia> setUnit!(ùê∂, s)\n0.0 s\njulia> event!(ùê∂, SimFunction(myfunc, 4, 5), 1minute)\n60.0\njulia> event!(ùê∂, SimFunction(myfunc, 5, 6), after, 1hr)\n3600.0\njulia> ùê∂\nClock: state=Simulate.Idle(), time=0.0, unit=s, events: 5, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> run!(ùê∂, 1hr)\n\"run! finished with 5 events, simulation time: 3600.0\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sample!","page":"Usage","title":"Simulate.sample!","text":"sample!(sim::Clock, ex::Union{Expr, SimFunction}; scope::Module=Main)\n\nenqueue an expression for sampling.\n\nArguments\n\nsim::Clock\nex::Union{Expr, SimFunction}: an expression or function\nscope::Module=Main: optional, a scope for the expression to be evaluated in\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.process!","page":"Usage","title":"Simulate.process!","text":"process!(sim::Clock, p::SimProcess)\n\nRegister a SimProcess to a clock and return the id it was registered with. It can then be found under sim.processes[id].\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.delay!","page":"Usage","title":"Simulate.delay!","text":"delay!(sim::Clock, t::Number)\n\ndelay the calling process or function for a time t on the clock sim.\n\nOther methods:\n\ndelay!(t::Number): equivalent to delay!(ùê∂, t)\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.start!","page":"Usage","title":"Simulate.start!","text":"start!(sim::Clock)\n\nStart all registered processes in a clock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.incr!","page":"Usage","title":"Simulate.incr!","text":"incr!(sim::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.run!","page":"Usage","title":"Simulate.run!","text":"run!(sim::Clock, duration::Number)\n\nRun a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!","page":"Usage","title":"Simulate.stop!","text":"stop!(sim::Clock)\n\nStop a running simulation.\n\n\n\n\n\nstop!(p::SimProcess)\n\nStop a SimProcess by throwing a SimException to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.resume!","page":"Usage","title":"Simulate.resume!","text":"resume!(sim::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sync!","page":"Usage","title":"Simulate.sync!","text":"sync!(sim::Clock, to::Clock=ùê∂)\n\nForce a synchronization of two clocks. Change all registered times of sim accordingly. Convert or force sim.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.reset!","page":"Usage","title":"Simulate.reset!","text":"reset!(sim::Clock, Œît::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)\n\nreset a clock\n\nArguments\n\nsim::Clock\nŒît::Number=0: time increment\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are\n\ndeleted. If hard=false, then only time is reset, event and sampling times are adjusted accordingly.\n\nunit=NoUnits: the Time unit for the clock after reset. If a Œît::Time is\n\ngiven, its Time unit goes into the clock Time unit. If only t0::Time is given, its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, processes: 0, sampling: 0, sample rate Œît=1.0\njulia> reset!(c)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> c\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, processes: 0, sampling: 0, sample rate Œît=0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Logging-1","page":"Usage","title":"Logging","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A Logger allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger's state it can be printed or stored in a table.","category":"page"},{"location":"usage/#Example-1","page":"Usage","title":"Example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sim = Clock(); # create a clock\nl = Logger(); # create a logging variable\ninit!(l, sim); # initialize the logger\n(a, b, c) = 1, 1, 1 # create some variables\nsetup!(l, [:a, :b, :c], scope = m); # register them for logging\nrecord!(l) # record the variables with the current clock time\nl.last # show the last record\nfunction f()  # a function for increasing and recording the variables\n  global a += 1\n  global b = a^2\n  global c = a^3\n  record!(l)\nend\nswitch!(l, 1); # switch logger to printing\nf() # increase and record the variables\nswitch!(l, 2); # switch logger to storing in data table\nfor i in 1:10 # create some events\n    event!(sim, :(f()), i, scope = m)\nend\nrun!(sim, 10) # run a simulation\nl.df # view the recorded values","category":"page"},{"location":"usage/#Types-1","page":"Usage","title":"Types","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Logger","category":"page"},{"location":"usage/#Simulate.Logger","page":"Usage","title":"Simulate.Logger","text":"Logger()\n\nSetup and return a logging variable.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Functions-2","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"init!\nsetup!\nswitch!\nrecord!\nclear!","category":"page"},{"location":"usage/#Simulate.init!","page":"Usage","title":"Simulate.init!","text":"init!(sim::Clock)\n\ninitialize a clock.\n\n\n\n\n\ninit!(L::Logger, sim::Clock)\n\nInitialize a Logger.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.setup!","page":"Usage","title":"Simulate.setup!","text":"setup!(L::Logger, vars::Array{Symbol})\n\nSetup a logger with logging variables.\n\nArguments\n\nL::Logger\nvars::Array{Symbol}: An array of symbols, e.g. of global variables\nscope::Module = Main: Scope in which to evaluate the variables\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.switch!","page":"Usage","title":"Simulate.switch!","text":"switch!(L::Logger, to::Number=0)\n\nSwitch the operating mode of a logger.\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.record!","page":"Usage","title":"Simulate.record!","text":"record!(L::Logger)\n\nrecord the logging variables with the current operating mode.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.clear!","page":"Usage","title":"Simulate.clear!","text":"clear!(L::Logger)\n\nclear the loggers last record and data table.\n\n\n\n\n\n","category":"function"},{"location":"approach/#Approaches-to-modeling-and-simulation-1","page":"Approaches","title":"Approaches to modeling and simulation","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Simulate.jl aims to support four major approaches to modeling and simulation of discrete event systems (DES):","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"event based: events occur in time and trigger actions causing further events ‚Ä¶\nstate based: events cause transitions between  states. State actions cause further events ‚Ä¶\nactivity based: activities occur in time and cause other activities ‚Ä¶\nprocess based: processes wait for and act according to events and their current state ‚Ä¶","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Choi and Kang 1 have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune 2 call those \"the event scheduling scheme\" and the 4th approach \"the process-oriented simulation scheme\" 3. There are communities behind the various views and Simulate.jl wants to be useful for them all.","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Simulate.jl allows arbitrary Julia functions or expressions to be registered as \"events\" on the clock's time line and thus enables the first three approaches. Under a few conditions Julia functions can run as \"processes\" simulating entities in a DES.","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Then there are continuous systems, which are usually modeled by taking an action each time step Œît. We can register expressions or functions to the clock as sampling functions, which then are executed at each clock tick or we can register them as repeating events.  ","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"All approaches fit together: e.g. functions registered as events can communicate with other functions running as processes acting on states and triggering other events or processes to start ‚Ä¶ Functions operating continuously can modify or evaluate conditions and states or trigger events ‚Ä¶ Thus we can model and simulate hybrid systems combining continuous processes and discrete events. All this gives us an expressive framework for simulation.","category":"page"},{"location":"approach/#Event-based-modeling-1","page":"Approaches","title":"Event based modeling","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"A simple server takes something from an input, processes it for some time and puts it out to an output. Here the three actions are seen as events and described in an event graph:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"(Image: event graph)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"In our example we want to have 8 such entities in our system, 4 foos and 4 bars, which communicate with each other via two channels. Therefore we have to define a data structure for the entity:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\nfunction take(en::Server)\n    isempty(en.input) || event!(ùê∂, SimFunction(take, en), :(!isempty(en.input)))\n    en.token = take!(en.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", œÑ(), en.name, en.id, en.token)\n    proc(en)\nend\n\nproc(en) = event!(ùê∂, SimFunction(put, en), after, rand())\n\nfunction put(en)\n    put!(en.output, en.op(en.id, en.token))\n    en.token = nothing\n    take(en)\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8\n    take(Server(i, \"foo\", ch1, ch2, +))\n    take(Server(i+1, \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"julia>\nconditional events are not yet implemented !!","category":"page"},{"location":"approach/#State-based-modeling-1","page":"Approaches","title":"State based modeling","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Our server has three states: Idle, Busy and End (where End does nothing). On an arrival event it resets its internal clock x=0 and determines the service time t_s, moves to Busy, works on its input and puts it out when service time is over. Then it goes back to Idle. A state transition diagram (Mealy model) of the timed automaton would look like:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"(Image: timed automaton)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"We define states and events and implement a Œ¥ transition function with two methods. Thereby we dispatch on states and events. Since we don't implement all combinations of states and events, we may implement a fallback transition.","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"abstract type Q end  # states\nstruct Idle <: Q end\nstruct Busy <: Q end\nabstract type Œ£ end  # events\nstruct Arrive <: Œ£ end\nstruct Leave <: Œ£ end\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  state::Q\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, Idle, nothing)\nend\n\nŒ¥(A::Server, ::Idle, ::Arrive) = (A.state=Busy(); event!(ùê∂,SimFunction(Œ¥,A,A.state,Leave()),after,rand())\nŒ¥(A::Server, ::Busy, ::Leave) = put(A)\nŒ¥(A::Server, q::Q, œÉ::Œ£) = println(stderr, \"$(A.name) $(A.id) undefined transition $q, $œÉ\")\n\nfunction take(A::Server)\n  if isempty(A.input)\n    event!(ùê∂, SimFunction(take, A), !isempty(A.input))\n  else\n    A.token = take!(en.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", œÑ(), A.name, A.id, A.token)\n    Œ¥(A,Idle(),Arrive())\n  end\nend\n\nfunction put(A::Server)\n  put!(A.output, A.op(A.id,A.token))\n  A.state=Idle()\n  take(A))\nend\n\nreset!(ùê∂)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8\n    serve(Server(i, \"foo\", ch1, ch2, +))\n    serve(Server(i+1, \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"julia>\nconditional events are not yet implemented !!","category":"page"},{"location":"approach/#Activity-based-modeling-1","page":"Approaches","title":"Activity based modeling","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Our server's activity is the processing of the token. A timed Petri net would look like:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"(Image: timed petri net)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"The arrive transition puts a token in the Queue. If both places Idle and Queue have tokens, the server takes them, shifts one to Busy and puts out two after a timed transition with delay v_put. Then it is Idle again and the cycle restarts. The serve activity is described by the blue box. Following the Petri net, we should implement a state variable with states Idle and Busy, but we don't need to if we separate the activities in time.","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"mutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\ncond(en) = !isempty(en.input) && en.state == Idle\n\nfunction serve(en::Server)\n    if isempty(en.input)\n      event!(ùê∂, SimFunction(take, en), !isempty(en.input))\n    else\n      en.token = take!(en.input)\n      @printf(\"%5.2f: %s %d took token %d\\n\", œÑ(), en.name, en.id, en.token)\n      event!(ùê∂, (SimFunction(put!, en.output, token), SimFunction(serve, en)), after, rand())\n    end\nend\n\nreset!(ùê∂)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8\n    serve(Server(i, \"foo\", ch1, ch2, +))\n    serve(Server(i+1, \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"julia>\nconditional events are not yet implemented !!","category":"page"},{"location":"approach/#Process-based-modeling-1","page":"Approaches","title":"Process based modeling","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"Here we combine it all in a simple process of take!-delay!-put! running in a loop. This is much like in the activity based scheme. But implementation is simpler because processes can wait or delay and are suspended and reactivated by Julia's scheduler according to background events. We don't need to handle events explicitly here and we don't need a server type since each process contains its own data:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"reset!(ùê∂)\n\nfunction simple(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something, eventually wait for it\n    @printf(\"%5.2f: %s %d took token %d\\n\", œÑ(), name, id, token)\n    d = delay!(rand())           # wait for a given time\n    put!(output, op(token, id))  # put something else out, eventually wait\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 SimProcesses\n    process!(ùê∂, SimProcess(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(ùê∂, SimProcess(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nstart!(ùê∂) # start all registered processes\nput!(ch1, 1) # put first token into channel 1\n\nsleep(0.1) # we give the processes some time to startup\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"and runs like:","category":"page"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"julia> include(\"docs/examples/channels.jl\")\n 0.00: foo 7 took token 1\n 0.25: bar 4 took token 8\n 0.29: foo 3 took token 32\n 0.55: bar 2 took token 35\n 1.21: foo 5 took token 70\n 1.33: bar 8 took token 75\n 1.47: foo 1 took token 600\n 1.57: bar 6 took token 601\n 2.07: foo 7 took token 3606\n 3.00: bar 4 took token 3613\n 3.68: foo 3 took token 14452\n 4.33: bar 2 took token 14455\n 5.22: foo 5 took token 28910\n 6.10: bar 8 took token 28915\n 6.50: foo 1 took token 231320\n 6.57: bar 6 took token 231321\n 7.13: foo 7 took token 1387926\n 8.05: bar 4 took token 1387933\n 8.90: foo 3 took token 5551732\n 9.10: bar 2 took token 5551735\n 9.71: foo 5 took token 11103470\n 9.97: bar 8 took token 11103475\n10.09: foo 1 took token 88827800\n\"run! finished with 22 events, simulation time: 10.0\"","category":"page"},{"location":"approach/#Comparison-1","page":"Approaches","title":"Comparison","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"All four approaches can be expressed in Simulate.jl. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured, which comes in handy for more complicated examples. After all parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.","category":"page"},{"location":"approach/#Combined-approach-1","page":"Approaches","title":"Combined approach","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"(empty)","category":"page"},{"location":"approach/#Hybrid-systems-1","page":"Approaches","title":"Hybrid systems","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"(empty)","category":"page"},{"location":"approach/#References,-Footnotes-1","page":"Approaches","title":"References, Footnotes","text":"","category":"section"},{"location":"approach/#","page":"Approaches","title":"Approaches","text":"<a name=\"ref1\">[1]</a>:  Choi and Kang: Modeling and Simulation of Discrete-Event Systems, Wiley, 2013\n<a name=\"ref2\">[2]</a>:  Cassandras and Lafortune: Introduction to Discrete Event Systems, Springer, 2008, Ch. 10\n<a name=\"ref3\">[3]</a>: to be fair, the 4th approach is called by Choi and Kang \"parallel simulation\".\n<a name=\"ref4\">[4]</a>: since the two separate take and put functions are initiated by setting the state to Idle or Busy, we don't in this case really need the state variable.","category":"page"},{"location":"examples/greeting/#Two-guys-meet-1","page":"Two guys meet","title":"Two guys meet","text":"","category":"section"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If two guys meet, there is standard verbiage, but some uncertainty in how long they need to greet and respond. We can simulate this as an introductory example.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We call the needed modules and define some types and data:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"using Simulate, Printf\n\nstruct Guy\n    name\nend\n\nabstract type Encounter end\nstruct Meet <: Encounter\n    someone\nend\nstruct Greet <: Encounter\n    num\n    from\nend\nstruct Response <: Encounter\n    num\n    from\nend\n\ncomm = (\"Nice to meet you!\", \"How are you?\", \"Have a nice day!\", \"bye bye\")","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We implement the behavior of the \"guys\" as step!-Œ¥-functions of a state machine. For that we use some features of Sim.jl:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"ùê∂ or Tau is the central clock,\nSimFunction prepares a Julia function for later execution,\nevent! schedules it for execution after some time,\nœÑ() gives the central time (T.time).","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"say(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", œÑ(), name, comm[n])\n\nfunction step!(me::Guy, œÉ::Meet)\n    event!(ùê∂, SimFunction(step!, œÉ.someone, Greet(1, me)), after, 2*rand())\n    say(me.name, 1)\nend\n\nfunction step!(me::Guy, œÉ::Greet)\n    if œÉ.num < 3\n        event!(ùê∂, SimFunction(step!, œÉ.from, Response(œÉ.num, me)), after, 2*rand())\n        say(me.name, œÉ.num)\n    else\n        say(me.name, 4)\n    end\nend\n\nfunction step!(me::Guy, œÉ::Response)\n    event!(ùê∂, SimFunction(step!, œÉ.from, Greet(œÉ.num+1, me)), after, 2*rand())\n    say(me.name, œÉ.num+1)\nend","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we define some \"guys\" and a starting event and tell the clock ùê∂ to run for twenty \"seconds\":","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"foo = Guy(\"Foo\")\nbar = Guy(\"Bar\")\n\nevent!(ùê∂, SimFunction(step!, foo, Meet(bar)), at, 10*rand())\nrun!(ùê∂, 20)","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If we source this code, it will run a simulation:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> include(\"docs/examples/greeting.jl\")\n 7.30 s, Foo: Nice to meet you!\n 8.00 s, Bar: Nice to meet you!\n 9.15 s, Foo: How are you?\n10.31 s, Bar: How are you?\n11.55 s, Foo: Have a nice day!\n12.79 s, Bar: bye bye\nFinished: 6 events, simulation time: 20.0","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we reset the clock ùê∂ for further simulations.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> reset!(ùê∂)\nclock reset to t‚ÇÄ=0, sampling rate Œît=0.","category":"page"},{"location":"examples/tabletennis/#Table-tennis-1","page":"Table tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We can model the players as state machines and do a simulation on it.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"using Simulate, Printf\nimport Simulate.init!","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Some functions describe the setup of players, serve and return. Here we use the following features of Sim.jl:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"italic ùê∂ (\\itC+Tab) or Clk is the central clock,\nœÑ() or tau() gives the central time,\nevent! schedules an expression (or a function) for execution after some time on ùê∂s timeline.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ‚â§ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if (rand() ‚â§ p.accuracy) && (p.state == Wait())\n        event!(ùê∂, :(step!($(p.opp), Serve())), after, ts)\n        @printf(\"%.2f: %s serves %s\\n\", œÑ()+ts, p.name, p.opp.name)\n    else\n        event!(ùê∂, :(step!($(p.opp), Miss())), after, ts)\n        @printf(\"%.2f: %s serves and misses %s\\n\", œÑ()+ts, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ‚â§ p.accuracy\n        event!(ùê∂, :(step!($(p.opp), Return())), after, tr)\n        @printf(\"%.2f: %s returns %s\\n\", œÑ()+tr, p.name, p.opp.name)\n    else\n        event!(ùê∂, :(step!($(p.opp), Miss())), after, tr)\n        @printf(\"%.2f: %s returns and misses %s\\n\", œÑ()+tr, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Note: In this case of scheduling an expression we need to interpolate p.opp with $(p.opp) to ensure that our step!-function gets the right player. Instead of scheduling expressions we normally would have scheduled our functions with SimFunction(step!, p.opp, Serve()), which eliminates the need for interpolation.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"The behavior of a player is described by the following step!-Œ¥ transition functions with Œ¥(p, q·µ¶, œÉ) ‚Üí q·µß leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, œÉ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $œÉ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Union{Wait, Unalert}, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%.2f: %s looses ball\\n\", œÑ(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, œÉ::PEvent) = step!(p, p.state, œÉ)","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Next we define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"run!(ùê∂, 30)\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nFinished: 22 events, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we should reset the clock for following simulations:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> reset!(ùê∂)\nclock reset to t‚ÇÄ=0, sampling rate Œît=0.","category":"page"},{"location":"overview/#Discrete-event-simulation-with-Simulate.jl-1","page":"Overview","title":"Discrete event simulation with Simulate.jl","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Simulate.jl evaluates Julia expressions or arbitrary functions at given (virtual) simulation times.\nThus discrete event systems based on state machines can be modeled and simulated.\nVariables can be logged over simulation time and then accessed for","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"analysis or visualization.","category":"page"},{"location":"overview/#The-clock-1","page":"Overview","title":"The clock","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Simulate.jl provides a clock for a simulation time  (a Float64) with an arbitrary unit of time. A unit can be set and times can be given to the clock with Unitful time units and thus are automatically converted.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits): create a new clock with sampling time Œît, start time t0 and a choosen Unitful time unit.\nitalic ùê∂ (\\itC+Tab) or Clk : is the central Clock() variable.\nœÑ(sim::Clock=ùê∂): return the current clock time.\nsample_time!(sim::Clock, Œît::Number): set the clock's sample rate starting from now(sim).\nreset!(sim::Clock, Œît::Number=0; t0::Time=0, hard::Bool=true): reset a clock.\nsync!(sim::Clock, to::Clock=ùê∂): Force a synchronization of two clocks.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"If no Œît ‚â† 0 is given, the simulation doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"overview/#A-note-on-using-time-units-1","page":"Overview","title":"A note on using time units","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Internally Simulate clocks work with a Float64 time and it works per default with Unitful.NoUnits but you can set them to work with Unitful.Time units like ms, s, minute, hr. In this case œÑ(c) returns a time, e.g. 1 s. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"setUnit(sim::Clock, unit::FreeUnits): set a clock unit.\nœÑ(sim::Clock).val: return unitless number for current time.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"At the moment I find it unconvenient to work with units if you trace simulation times in a table or you do plots. It seems easier not to use them as long you need automatic time conversion in your simulation projects.","category":"page"},{"location":"overview/#Functions-and-expressions-as-Events-1","page":"Overview","title":"Functions and expressions as Events","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Julia functions or expressions are scheduled as events on the clock's time line:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"SimFunction(func::Function, arg...; kw...): prepare a function and its arguments for simulation.\nevent!(sim::Clock, ex::Union{Expr,SimFunction}, t::Number) or\nevent!(sim, ex, at, t): schedule a function or an expression for a given simulation time.\nevent!(sim, ex, after, t): schedule a function or an expression for time t after current simulation time.\nevent!(sim, ex, every, Œît): schedule a function an expression for now and every time step Œît until end of simulation.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Events are called later as we step or run through the simulation. They may at runtime create further events and thus cause chains of events to be scheduled and called during simulation.","category":"page"},{"location":"overview/#Sampling-expressions-1","page":"Overview","title":"Sampling expressions","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"If we provide the clock with a time interval Œît, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"sample_time!(sim::Clock, Œît::Number): set the clock's sampling time starting from now (œÑ(sim)).\nsample!(sim::Clock, ex::Union{Expr,SimFunction}): enqueue a function or expression for sampling.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.","category":"page"},{"location":"overview/#Functions-as-processes-1","page":"Overview","title":"Functions as processes","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"If they match certain conditions, functions can be started as processes, which wait for inputs, respond accordingly and create some output.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"SimProcess(id, func, input, output, arg...; kw...): prepare a function func(input::Channel, output::Channel, arg...; kw...) for running as a process in a simulation.\nprocess!(sim::Clock, p::SimProcess): register a SimProcess to a clock,\nstart!(sim::Clock): start all registered SimProcesses,\nstop!(p::SimProcess): stop p,\ndelay!(sim::Clock, t::Number): a process can call for a delay, which creates","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"an event on the clock's timeline and wakes up the process after the given t.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"note: Note\nA function func running as a SimProcess is put in a loop. So it has to give back control by e.g. doing a take!(input) on its input channel or by calling delay! etc., which will yield it. Otherwise it will after start starve everything else!","category":"page"},{"location":"overview/#Running-a-simulation-1","page":"Overview","title":"Running a simulation","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Now, after we have setup a clock, scheduled events or setup sampling, we can step or run through a simulation, stop or resume it.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"run!(sim::Clock, duration::Number): run a simulation for a given duration. Call all ticks and scheduled events in that timeframe.\nincr!(sim::Clock): take one simulation step, call the next tick or event.\nstop!(sim::Clock): stop a simulation\nresume!(sim::Clock): resume a halted simulation.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Now we can evaluate the results.","category":"page"},{"location":"overview/#Logging-1","page":"Overview","title":"Logging","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Logging enables us to trace variables over simulation time and such analyze their behaviour.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"L = Logger(): create a new logger, providing the newest record L.last, a logging table L.df and a switch L.ltype between logging types.\ninit!(L::Logger, sim::Clock=ùê∂):\nsetup!(L::Logger, vars::Array{Symbol}): setup L, providing it with an array of logging variables [:a, :b, :c ...]\nswitch!(L::Logger, to::Number=0): switch between 0: only keep the last record, 1: print, 2: write records to the table\nrecord!(L::Logger): record the logging variables with current simulation time.","category":"page"},{"location":"#Simulate.jl-1","page":"Home","title":"Simulate.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl introduces a clock and allows to schedule Julia expressions and functions as discrete events for later execution on the clock's time line. Expressions or functions can register for continuous sampling and then are executed at each clock tick. Julia functions can also run as processes, which can refer to the clock, respond to events, delay etc. If we run the clock,  events are executed in the scheduled sequence, sampling functions are called continuously at each clock tick and processes are served accordingly.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl is a registered package and is installed with:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add Simulate","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The development (and sometimes not so stable version) can be installed with:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add(\"https://github.com/pbayer/Simulate.jl\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"#Process-based-example-1","page":"Home","title":"Process based example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"using Simulate, Printf\nreset!(ùê∂) # reset the central clock\n\n# a function with Channels input and output as the first\n# two arguments can be registered as a SimProcess\n# the function is put in a loop, so no need to have a loop here\nfunction simple(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something from the input\n    @printf(\"%5.2f: %s %d took token %d\\n\", œÑ(), name, id, token)\n    d = delay!(rand())           # after a delay\n    put!(output, op(token, id))  # put it out with some op applied\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 SimProcesses\n    process!(ùê∂, SimProcess(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(ùê∂, SimProcess(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nstart!(ùê∂)     # start all registered processes\nput!(ch1, 1)  # put first token into channel 1\n\nsleep(0.1)    # give the processes some time to startup\n\nrun!(ùê∂, 10)   # an run for 10 time units","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If we source this program, it runs a simulation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> include(\"docs/examples/channels.jl\")\n 0.00: foo 7 took token 1\n 0.25: bar 4 took token 8\n 0.29: foo 3 took token 32\n 0.55: bar 2 took token 35\n 1.21: foo 5 took token 70\n 1.33: bar 8 took token 75\n 1.47: foo 1 took token 600\n 1.57: bar 6 took token 601\n 2.07: foo 7 took token 3606\n 3.00: bar 4 took token 3613\n 3.68: foo 3 took token 14452\n 4.33: bar 2 took token 14455\n 5.22: foo 5 took token 28910\n 6.10: bar 8 took token 28915\n 6.50: foo 1 took token 231320\n 6.57: bar 6 took token 231321\n 7.13: foo 7 took token 1387926\n 8.05: bar 4 took token 1387933\n 8.90: foo 3 took token 5551732\n 9.10: bar 2 took token 5551735\n 9.71: foo 5 took token 11103470\n 9.97: bar 8 took token 11103475\n10.09: foo 1 took token 88827800\n\"run! finished with 22 events, simulation time: 10.0\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For further examples see docs/examples or docs/notebooks.","category":"page"},{"location":"#Changes-in-v0.2.0-(development)-1","page":"Home","title":"Changes in v0.2.0 (development)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"next: conditional events with event!(sim, ex, cond) and wait!(cond) where cond::Union{SimExpr, Array{SimExpr,1}},\nevent! can be called without the first clock argument, it then goes to ùê∂.\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: ùêÖ for SimFunction and ùêè for SimProcess\nintroduced process-based simulation with SimProcess and process!,\nextensive documentation\nmore examples","category":"page"}]
}
