var documenterSearchIndex = {"docs":
[{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = Sim","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Sim.jl is not yet an registered package and is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using Sim","category":"page"},{"location":"usage/#Modeling-and-simulation-1","page":"Usage","title":"Modeling and simulation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A virtual Clock allows to schedule Julia functions or expressions as timed events or as sampling actions, which occur at predefined clock ticks. When we run the Clock, it fires the events at their scheduled times and executes the sampling actions at each tick.","category":"page"},{"location":"usage/#Silly-example-1","page":"Usage","title":"Silly example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"m = @__MODULE__ # catching the current module is needed for documentation\nusing Printf\ncomm = [\"Hi, nice to meet you!\", \"How are you?\", \"Have a nice day!\"];\ngreet(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", τ(), name, comm[n])\nfunction foo(n) # 1st passerby\n    greet(\"Foo\", n)\n    event!(Τ, :(bar($n)), after, 2*rand(), scope = m)\nend\nfunction bar(n) # 2nd passerby\n    greet(\"Bar\", n)\n    if n < 3\n       event!(Τ, :(foo($n+1)), after, 2*rand(), scope = m)\n    else\n       println(\"bye bye\")\n    end\nend\nevent!(Τ, :(foo(1)), at, 10*rand(), scope = m); # create an event for a start\nrun!(Τ, 20) # and run the simulation","category":"page"},{"location":"usage/#Types-and-constants-1","page":"Usage","title":"Types and constants","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Time\nClock\nTiming\nSimFunction","category":"page"},{"location":"usage/#Sim.Time","page":"Usage","title":"Sim.Time","text":"Time\n\nTime is a number in Sim.jl\n\n\n\n\n\n","category":"type"},{"location":"usage/#Sim.Clock","page":"Usage","title":"Sim.Clock","text":"Clock(Δt::Number=0; t0::Number=0)\n\nCreate a new simulation clock.\n\nArguments\n\nΔt::Number=0: time increment\nt0::Number=0: start time for simulation.\n\nIf no Δt is given, the simulation doesn't tick, but jumps from event to event. Δt can be set later with sample_time!.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Sim.Timing","page":"Usage","title":"Sim.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time\nafter: schedule an event a given time after current time\nevery: schedule an event every given time from now on\nbefore: a timed condition is true before a given time.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Sim.SimFunction","page":"Usage","title":"Sim.SimFunction","text":"SimFunction(func::Function, arg...; kw...)\n\nType for preparing a function as an event to a simulation.\n\nArguments\n\nfunc::Function: function to be executed at a later simulation time\narg...: arguments to the function\nkw...: keyword arguments\n\nBe aware that, if the variables stored in a SimFunction are composite types, they can change until they are evaluated later by func. But that's the nature of simulation.\n\nExample\n\njulia> using Sim\n\njulia> f(a,b,c; d=4, e=5) = a+b+c+d+e  # define a function\nf (generic function with 1 method)\n\njulia> sf = SimFunction(f, 10, 20, 30, d=14, e=15)  # store it as SimFunction\nSimFunction(f, (10, 20, 30), Base.Iterators.Pairs(:d => 14,:e => 15))\n\njulia> sf.func(sf.arg...; sf.kw...)  # and it can be executed later\n89\n\njulia> d = Dict(:a => 1, :b => 2) # now we set up a dictionary\nDict{Symbol,Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> f(t) = t[:a] + t[:b] # and a function adding :a and :b\nf (generic function with 2 methods)\n\njulia> f(d)  # our add function gives 3\n3\n\njulia> ff = SimFunction(f, d)   # we set up a SimFunction\nSimFunction(f, (Dict(:a => 1,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> d[:a] = 10  # later somehow we need to change d\n10\n\njulia> ff  # our SimFunction ff has changed too\nSimFunction(f, (Dict(:a => 10,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> ff.func(ff.arg...; ff.kw...)  # and calling it gives a different result\n12\n\n\n\n\n\n","category":"type"},{"location":"usage/#Central-time-1","page":"Usage","title":"Central time","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Τ","category":"page"},{"location":"usage/#Sim.Τ","page":"Usage","title":"Sim.Τ","text":"Τ\nTau\n\nΤ (\\Tau+Tab), Tau is the central Clock()-variable.\n\nExamples\n\njulia> using Sim\n\njulia> Τ  # central clock\nClock(Sim.Idle(), 0, DataStructures.PriorityQueue{Sim.SimEvent,Float64,Base.Order.ForwardOrdering}(), 0, 0, 0, 0, Sim.Sample[], 0)\njulia> Tau  # alias\nClock(Sim.Idle(), 0, DataStructures.PriorityQueue{Sim.SimEvent,Float64,Base.Order.ForwardOrdering}(), 0, 0, 0, 0, Sim.Sample[], 0)\njulia> Τ.time\n0\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Functions-1","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"τ\nsample_time!\nevent!\nsample!\nincr!\nrun!\nstop!\nresume!\nsync!\nreset!","category":"page"},{"location":"usage/#Sim.τ","page":"Usage","title":"Sim.τ","text":"τ(sim::Clock=Τ)\ntau(sim::Clock=Tau)\n\nReturn the current simulation time (τ=\tau+Tab).\n\nExamples\n\njulia> using Sim\n\njulia> τ() # gives the central time\n0\njulia> tau() # alias, gives the central time\n0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.sample_time!","page":"Usage","title":"Sim.sample_time!","text":"sample_time!(sim::Clock, Δt::Time)\n\nset the clock's sampling time from au(sim).\n\nArguments\n\nsim::Clock\nΔt::Number: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.event!","page":"Usage","title":"Sim.event!","text":"event!(sim::Clock, ex::Union{Expr, SimFunction}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64\nevent!(sim::Clock, ex::Union{Expr, SimFunction}, T::Timing, t::Number; scope::Module=Main)::Float64\n\nSchedule a function or expression for a given simulation time.\n\nArguments\n\nsim::Clock: simulation clock\nex::{Expr, SimFunction}: an expression or SimFunction\nt::Time: simulation time\nscope::Module=Main: scope for the expression to be evaluated\ncycle::Time=0.0: repeat cycle time for the event\nT::Timing: a timing, at, after or every (before behaves like at)\n\nreturns\n\nScheduled simulation time for that event.\n\nMay return a time t > at from repeated applications of nextfloat(at) if there were yet events scheduled for that time.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.sample!","page":"Usage","title":"Sim.sample!","text":"sample!(sim::Clock, ex::Union{Expr, SimFunction}; scope::Module=Main)\n\nenqueue an expression for sampling.\n\nArguments\n\nsim::Clock\nex::Union{Expr, SimFunction}: an expression or function\nscope::Module=Main: optional, a scope for the expression to be evaluated in\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.incr!","page":"Usage","title":"Sim.incr!","text":"incr!(sim::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.run!","page":"Usage","title":"Sim.run!","text":"run!(sim::Clock, duration::Number)\n\nRun a simulation for a given duration.\n\nCall scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.stop!","page":"Usage","title":"Sim.stop!","text":"stop!(sim::Clock)\n\nStop a running simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.resume!","page":"Usage","title":"Sim.resume!","text":"resume!(sim::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.sync!","page":"Usage","title":"Sim.sync!","text":"sync!(sim::Clock, to::Clock=Τ)\n\nForce a synchronization of two clocks. Change all registered times of sim accordingly.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.reset!","page":"Usage","title":"Sim.reset!","text":"reset!(sim::Clock, Δt::Number=0; t0::Time=0, hard::Bool=true)\n\nreset a clock\n\nArguments\n\nsim::Clock\nΔt::Number=0: time increment\nt0::Time=0: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are\n\ndeleted. If hard=false, then only time is reset, event and sampling times are adjusted accordingly.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Logging-1","page":"Usage","title":"Logging","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A Logger allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger's state it can be printed or stored in a table.","category":"page"},{"location":"usage/#Example-1","page":"Usage","title":"Example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sim = Clock(); # create a clock\nl = Logger(); # create a logging variable\ninit!(l, sim); # initialize the logger\n(a, b, c) = 1, 1, 1 # create some variables\nsetup!(l, [:a, :b, :c], scope = m); # register them for logging\nrecord!(l) # record the variables with the current clock time\nl.last # show the last record\nfunction f()  # a function for increasing and recording the variables\n  global a += 1\n  global b = a^2\n  global c = a^3\n  record!(l)\nend\nswitch!(l, 1); # switch logger to printing\nf() # increase and record the variables\nswitch!(l, 2); # switch logger to storing in data table\nfor i in 1:10 # create some events\n    event!(sim, :(f()), i, scope = m)\nend\nrun!(sim, 10) # run a simulation\nl.df # view the recorded values","category":"page"},{"location":"usage/#Types-1","page":"Usage","title":"Types","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Logger","category":"page"},{"location":"usage/#Sim.Logger","page":"Usage","title":"Sim.Logger","text":"Logger()\n\nSetup and return a logging variable.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Functions-2","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"init!\nsetup!\nswitch!\nrecord!\nclear!","category":"page"},{"location":"usage/#Sim.init!","page":"Usage","title":"Sim.init!","text":"init!(sim::Clock)\n\ninitialize a clock.\n\n\n\n\n\ninit!(L::Logger, sim::Clock)\n\nInitialize a Logger.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.setup!","page":"Usage","title":"Sim.setup!","text":"setup!(L::Logger, vars::Array{Symbol})\n\nSetup a logger with logging variables.\n\nArguments\n\nL::Logger\nvars::Array{Symbol}: An array of symbols, e.g. of global variables\nscope::Module = Main: Scope in which to evaluate the variables\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.switch!","page":"Usage","title":"Sim.switch!","text":"switch!(L::Logger, to::Number=0)\n\nSwitch the operating mode of a logger.\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.record!","page":"Usage","title":"Sim.record!","text":"record!(L::Logger)\n\nrecord the logging variables with the current operating mode.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Sim.clear!","page":"Usage","title":"Sim.clear!","text":"clear!(L::Logger)\n\nclear the loggers last record and data table.\n\n\n\n\n\n","category":"function"},{"location":"examples/greeting/#Two-guys-meet-1","page":"Two guys meet","title":"Two guys meet","text":"","category":"section"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If two guys meet, there is some standard verbiage, but some uncertainty in how long they need to greet and respond. We can simulate this as an introductory example.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We call the needed modules and define some types and data:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"using Sim, Printf\n\nstruct Guy\n    name\nend\n\nabstract type Encounter end\nstruct Meet <: Encounter\n    someone\nend\nstruct Greet <: Encounter\n    num\n    from\nend\nstruct Response <: Encounter\n    num\n    from\nend\n\ncomm = (\"Nice to meet you!\", \"How are you?\", \"Have a nice day!\", \"bye bye\")","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We implement the behavior of the \"guys\" as step!-δ-functions of a state machine. For that we use some features of Sim.jl:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Τ or Tau is the central clock,\nSimFunction prepares a Julia function for later execution,\nevent! schedules it for execution after some time,\nτ() gives the central time (T.time).","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"say(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", τ(), name, comm[n])\n\nfunction step!(me::Guy, σ::Meet)\n    event!(Τ, SimFunction(step!, σ.someone, Greet(1, me)), after, 2*rand())\n    say(me.name, 1)\nend\n\nfunction step!(me::Guy, σ::Greet)\n    if σ.num < 3\n        event!(Τ, SimFunction(step!, σ.from, Response(σ.num, me)), after, 2*rand())\n        say(me.name, σ.num)\n    else\n        say(me.name, 4)\n    end\nend\n\nfunction step!(me::Guy, σ::Response)\n    event!(Τ, SimFunction(step!, σ.from, Greet(σ.num+1, me)), after, 2*rand())\n    say(me.name, σ.num+1)\nend","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we define some \"guys\" and a starting event and tell the clock Τ to run for twenty \"seconds\":","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"foo = Guy(\"Foo\")\nbar = Guy(\"Bar\")\n\nevent!(Τ, SimFunction(step!, foo, Meet(bar)), at, 10*rand())\nrun!(Τ, 20)","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If we source this code, it will run a simulation:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> include(\"docs/examples/greeting.jl\")\n 7.30 s, Foo: Nice to meet you!\n 8.00 s, Bar: Nice to meet you!\n 9.15 s, Foo: How are you?\n10.31 s, Bar: How are you?\n11.55 s, Foo: Have a nice day!\n12.79 s, Bar: bye bye\nFinished: 6 events, simulation time: 20.0","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we reset the clock Τ for further simulations.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> reset!(Τ)\nclock reset to t₀=0, sampling rate Δt=0.","category":"page"},{"location":"examples/tabletennis/#Table-tennis-1","page":"Table tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We can model the players as state machines and do a simulation on it.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"using Sim, Printf\nimport Sim.init!","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Some functions describe the setup of players, serve and return. Here we use the following features of Sim.jl:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Τ or Tau is the central clock,\nτ() or tau() gives the central time,\nevent! schedules an expression (or a function) for execution after some time on Τs timeline.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ≤ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if rand() ≤ p.accuracy\n        event!(Τ, :(step!($(p.opp), Serve())), after, ts)\n        @printf(\"%.2f: %s serves %s\\n\", τ()+ts, p.name, p.opp.name)\n    else\n        event!(Τ, :(step!($(p.opp), Miss())), after, ts)\n        @printf(\"%.2f: %s serves and misses %s\\n\", τ()+ts, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ≤ p.accuracy\n        event!(Τ, :(step!($(p.opp), Return())), after, tr)\n        @printf(\"%.2f: %s returns %s\\n\", τ()+tr, p.name, p.opp.name)\n    else\n        event!(Τ, :(step!($(p.opp), Miss())), after, tr)\n        @printf(\"%.2f: %s returns and misses %s\\n\", τ()+tr, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Note: In this case of scheduling an expression we need to interpolate p.opp with $(p.opp) to ensure that our step!-function gets the right player. Instead of scheduling expressions we normally would have scheduled our functions with SimFunction(step!, p.opp, Serve()), which eliminates the need for interpolation.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"The behavior of a player is described by the following step!-δ transition functions with δ(p, qᵦ, σ) → qᵧ leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, σ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $σ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Wait, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%.2f: %s looses ball\\n\", τ(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, σ::PEvent) = step!(p, p.state, σ)","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Next we define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"run!(Τ, 30)\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nFinished: 22 events, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we should reset the clock for following simulations:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> reset!(Τ)\nclock reset to t₀=0, sampling rate Δt=0.","category":"page"},{"location":"examples/examples/#Programs-1","page":"Further examples","title":"Programs","text":"","category":"section"},{"location":"examples/examples/#","page":"Further examples","title":"Further examples","text":"are at https://github.com/pbayer/Sim.jl/tree/master/docs/examples","category":"page"},{"location":"examples/examples/#Notebooks-1","page":"Further examples","title":"Notebooks","text":"","category":"section"},{"location":"examples/examples/#","page":"Further examples","title":"Further examples","text":"tabletennis.ipnb: Simple table tennis simulation.","category":"page"},{"location":"overview/#Discrete-event-simulation-with-Sim.jl-1","page":"Overview","title":"Discrete event simulation with Sim.jl","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Sim.jl evaluates Julia expressions or arbitrary functions at given (virtual) simulation times.\nThus discrete event systems based on state machines can be modeled and simulated.\nVariables can be logged over simulation time and then accessed for","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"analysis or visualization.","category":"page"},{"location":"overview/#The-clock-1","page":"Overview","title":"The clock","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Sim.jl provides a clock for a simulation time  (a Float64) with an arbitrary unit of time.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Clock(Δt::Number=0; t0::Number=0): create a new clock with start time t0 and sample time Δt.\nΤ or Tau : is the central Clock() variable.\nτ(sim::Clock=Τ): return the current clock time.\nsample_time!(sim::Clock, Δt::Number): set the clock's sample rate starting from now(sim).\nreset!(sim::Clock, Δt::Number=0; t0::Time=0, hard::Bool=true): reset a clock.\nsync!(sim::Clock, to::Clock=Τ): Force a synchronization of two clocks.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"If no Δt ≠ 0 is given, the simulation doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"overview/#Functions-and-expressions-as-Events-1","page":"Overview","title":"Functions and expressions as Events","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Julia functions or expressions are scheduled as events on the clock's time line:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"SimFunction(func::Function, arg...; kw...): prepare a function and its arguments for simulation.\nevent!(sim::Clock, ex::Union{Expr,SimFunction}, t::Float64) or\nevent!(sim, ex, at, t): schedule a function or an expression for a given simulation time.\nevent!(sim, ex, after, t): schedule a function or an expression for time t after current simulation time.\nevent!(sim, ex, every, Δt): schedule a function an expression for now and every time step Δt until end of simulation.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Events are called later as we step or run through the simulation. They may at runtime create further events and thus cause chains of events to be scheduled and called during simulation.","category":"page"},{"location":"overview/#Sampling-expressions-1","page":"Overview","title":"Sampling expressions","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"If we provide the clock with a time interval Δt, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"sample!(sim::Clock, ex::Union{Expr,SimFunction}): enqueue a function or expression for sampling.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events which may have been scheduled for the same time.","category":"page"},{"location":"overview/#Running-the-simulation-1","page":"Overview","title":"Running the simulation","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Now, after we have setup a clock, scheduled events or setup sampling, we can step or run through a simulation, stop or resume it.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"run!(sim::Clock, duration::Number): run a simulation for a given duration. Call all ticks and scheduled events in that timeframe.\nincr!(sim::Clock): take one simulation step, call the next tick or event.\nstop!(sim::Clock): stop a simulation\nresume!(sim::Clock): resume a halted simulation.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Now we can evaluate the results.","category":"page"},{"location":"overview/#Logging-1","page":"Overview","title":"Logging","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"Logging enables us to trace variables over simulation time and such analyze their behaviour.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"L = Logger(): create a new logger, providing the newest record L.last, a logging table L.df and a switch L.ltype between logging types.\ninit!(L::Logger, sim::Clock=Τ):\nsetup!(L::Logger, vars::Array{Symbol}): setup L, providing it with an array of logging variables [:a, :b, :c ...]\nswitch!(L::Logger, to::Number=0): switch between 0: only keep the last record, 1: print, 2: write records to the table\nrecord!(L::Logger): record the logging variables with current simulation time.","category":"page"},{"location":"#Sim.jl-1","page":"Home","title":"Sim.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Sim.jl introduces a Clock and allows to schedule and call arbitrary Julia functions or expressions at their scheduled time or at each tick.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Sim.jl is not yet an registered package and is installed with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add(\"https://github.com/pbayer/Sim.jl\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"CurrentModule = Sim","category":"page"},{"location":"internals/#Module-1","page":"Internals","title":"Module","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Sim","category":"page"},{"location":"internals/#Sim.Sim","page":"Internals","title":"Sim.Sim","text":"Sim\n\nA Julia package for discrete event simulation based on state machines.\n\n\n\n\n\n","category":"module"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The module contains two main types: Clock and Logger. Both are implemented as state machines. The implementation functions and types are not exported. The exported functions documented above under Usage are commands to the internal state machines.","category":"page"},{"location":"internals/#State-machines-1","page":"Internals","title":"State machines","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We have some definitions for them to work.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEngine","category":"page"},{"location":"internals/#Sim.SEngine","page":"Internals","title":"Sim.SEngine","text":"supertype for state machines in Sim.jl\n\n\n\n\n\n","category":"type"},{"location":"internals/#States-1","page":"Internals","title":"States","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined states for state machines.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SState\nUndefined\nIdle\nEmpty\nBusy\nHalted","category":"page"},{"location":"internals/#Sim.SState","page":"Internals","title":"Sim.SState","text":"supertype for states\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Undefined","page":"Internals","title":"Sim.Undefined","text":"a state machine is undefined (after creation)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Idle","page":"Internals","title":"Sim.Idle","text":"a state machine is idle\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Empty","page":"Internals","title":"Sim.Empty","text":"a state machine is empty\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Busy","page":"Internals","title":"Sim.Busy","text":"a state machine is busy\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Halted","page":"Internals","title":"Sim.Halted","text":"a state machine is halted\n\n\n\n\n\n","category":"type"},{"location":"internals/#Events-1","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined events.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEvent\nInit\nSetup\nSwitch\nLog\nStep\nRun\nStart\nStop\nResume\nClear","category":"page"},{"location":"internals/#Sim.SEvent","page":"Internals","title":"Sim.SEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Init","page":"Internals","title":"Sim.Init","text":"Init(info): Init event with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Setup","page":"Internals","title":"Sim.Setup","text":"Setup(vars::Array{Symbol,1}, scope::Module): setup a logger with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Switch","page":"Internals","title":"Sim.Switch","text":"Switch(to): switch to some other mode\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Log","page":"Internals","title":"Sim.Log","text":"Log(): record command for logging\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Step","page":"Internals","title":"Sim.Step","text":"Step(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Run","page":"Internals","title":"Sim.Run","text":"Run(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Start","page":"Internals","title":"Sim.Start","text":"Start(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Stop","page":"Internals","title":"Sim.Stop","text":"Stop(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Resume","page":"Internals","title":"Sim.Resume","text":"Resume(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Clear","page":"Internals","title":"Sim.Clear","text":"Clear(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Transition-functions-1","page":"Internals","title":"Transition functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In state machines transitions occur depending on states and events. The different transitions are described through different methods of the step!-function.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"step!","category":"page"},{"location":"internals/#Sim.step!","page":"Internals","title":"Sim.step!","text":"step!(A::SEngine, q::SState, σ::SEvent)\n\nDefault transition for clock and logger.\n\nThis is called if no otherwise defined transition occurs.\n\nArguments\n\nA::SEngine: state machine for which a transition is called\nq::SState:  state of the state machine\nσ::SEvent:  event, triggering the transition\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, ::Init)\n\ninitialize a clock.\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, σ::Union{Step,Run})\n\nif uninitialized, initialize and then Step or Run.\n\n\n\n\n\nstep!(sim::Clock, ::Union{Idle,Busy,Halted}, ::Step)\n\nstep forward to next tick or scheduled event.\n\nAt a tick evaluate all sampling expressions, or, if an event is encountered evaluate the event expression.\n\n\n\n\n\nstep!(sim::Clock, ::Idle, σ::Run)\n\nRun a simulation for a given duration.\n\nThe duration is given with Run(duration). Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\nstep!(sim::Clock, ::Busy, ::Stop)\n\nStop the clock.\n\n\n\n\n\nstep!(sim::Clock, ::Halted, ::Resume)\n\nResume a halted clock.\n\n\n\n\n\nstep!(sim::Clock, q::SState, σ::SEvent)\n\ncatch all step!-function.\n\n\n\n\n\nstep!(A::Logger, ::Undefined, σ::Init)\n\nInitialize a logger.\n\n\n\n\n\nstep!(A::Logger, ::Empty, σ::Setup)\n\nSetup a logger with logging variables. They are given by Setup(vars, scope).\n\n\n\n\n\nstep!(A::Logger, ::Idle, ::Clear)\n\nClear the last record and the data table of a logger.\n\n\n\n\n\nstep!(A::Logger, ::Idle, σ::Log)\n\nLogging event.\n\n\n\n\n\nstep!(A::Logger, ::Idle, σ::Switch)\n\nSwitch the operating mode of a logger by Switch(to).\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"internals/#Other-internal-types-and-functions-1","page":"Internals","title":"Other internal types and functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SimEvent\nSample\nsimExec\nnextevent\nnextevtime","category":"page"},{"location":"internals/#Sim.SimEvent","page":"Internals","title":"Sim.SimEvent","text":"SimEvent(expr::Expr, scope::Module, t::Time, Δt::Time)\n\nCreate a simulation event: an expression to be executed at event time.\n\nArguments\n\nexpr::Expr: expression to be evaluated at event time\nscope::Module: evaluation scope\nt::Float64: event time\nΔt::Float64: repeat rate with which the event gets repeated\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.Sample","page":"Internals","title":"Sim.Sample","text":"Sample(ex::Union{Expr, SimFunction}, scope::Module)\n\nCreate a sampling expression.\n\nArguments\n\nex::{Expr, SimFunction}: expression or function to be called at sample time\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Sim.simExec","page":"Internals","title":"Sim.simExec","text":"simExec(ex::Union{Expr,SimFunction}, m::Module=Main)\n\nevaluate an expression or execute a SimFunction.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sim.nextevent","page":"Internals","title":"Sim.nextevent","text":"nextevent(sim::Clock)\n\nReturn the next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sim.nextevtime","page":"Internals","title":"Sim.nextevtime","text":"nextevtime(sim::Clock)\n\nReturn the time of next scheduled event.\n\n\n\n\n\n","category":"function"}]
}
