var documenterSearchIndex = {"docs":
[{"location":"intro/#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Get an overview and learn the basics.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides 1) a clock with a virtual simulation time and 2) the ability to schedule Julia functions and expressions as events on the clock's timeline or 3) run them as processes synchronizing with the clock. The clock can 4) invoke sampling functions or expressions continuously at a given rate.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nSimulate.jl doesn't have a special concept for shared resources since this can be expressed in native Julia via tokens in a Channel.","category":"page"},{"location":"intro/#A-first-example-1","page":"Getting started","title":"A first example","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"A simple server takes something (a resource) from its input and puts it out modified after some time. We implement the server's activity in a function, create input and output channels and some \"foo\" and \"bar\" processes interacting on them:  ","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"using Simulate, Printf, Random\n\nfunction simple(c::Clock, input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something from the input\n    now!(c, fun(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(c), name, id, token)))\n    d = delay!(c, rand())        # after a delay\n    put!(output, op(token, id))  # put it out with some op applied\nend\n\nclk = Clock()      # create a clock\nRandom.seed!(123)  # seed the random number generator\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 processes\n    process!(clk, Prc(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(clk, Prc(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nput!(ch1, 1)    # put first token into channel 1\nyield()         # let the first task take it\nrun!(clk, 10)   # and run for 10 time units","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"We then run it:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> include(\"docs/examples/channels.jl\")\n 0.00: foo 1 took token 1\n 0.77: bar 2 took token 2\n 1.71: foo 3 took token 4\n 2.38: bar 4 took token 7\n 2.78: foo 5 took token 28\n ...\n ...\n 7.91: bar 2 took token 631017\n 8.36: foo 3 took token 1262034\n 8.94: bar 4 took token 1262037\n 9.20: foo 5 took token 5048148\n 9.91: bar 6 took token 5048153\n\"run! finished with 43 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#Types-and-functions-1","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"ùê∂, reset!, now!, delay!, process!, Prc, run!","category":"page"},{"location":"intro/#Four-building-blocks-1","page":"Getting started","title":"Four building blocks","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides 4 major building blocks for modeling and simulation of discrete event systems:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"the logical clock gives the simulation time,\nevents are Julia functions or expressions   executing at given simulation times or under given conditions,\nprocesses are functions running as tasks and synchronizing with the clock by delaying for a time or waiting for conditions,\ncontinuous sampling is done by invoking given expressions or functions at a given rate on the time line.","category":"page"},{"location":"intro/#the_clock-1","page":"Getting started","title":"The clock","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"The clock is central to any model and simulation, since it establishes the timeline. It does not only provide the time, but contains also a time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Œît. Each simulation can have its own clock.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> c = Clock()                           # create a new clock\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tick() = println(tau(c), \": tick!\")   # define a function printing the clock's time\ntick (generic function with 1 method)\n\njulia> event!(c, fun(tick), every, 1)         # schedule a repeat event on the clock\n0.0\n\njulia> run!(c, 10)                           # run the clock for 10 time units\n0.0: tick!\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 11 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If you work with only one simulation at a time, you normally use the central clock ùê∂ (\\\\itùê∂+tab):","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nYou definitely need different clock variables if you run multiple simulations on parallel threads. In such cases each simulation should have its own clock.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> tick() = println(tau(), \": tick!\")         # the tick function now uses central time tau()\ntick (generic function with 1 method)\n\njulia> sample_time!(1)                            # set the sampling rate on the central clock to 1\n1.0\n\njulia> periodic!( fun(tick) );                       # set tick as a sampling function\n\njulia> ùê∂                                          # ùê∂ now has one sampling entry and the sample rate set\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Œît=1.0 , prc:0\n  scheduled ev:0, cev:0, sampl:1\n\njulia> run!(ùê∂, 5)                                 # run ùê∂ for 5 time units\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 5.0\"\n\njulia> run!(ùê∂, 5)                                 # run it again\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 10.0\"\n\njulia> reset!(ùê∂)                                  # reset the clock\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If Œît = 0, the clock doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nClocks work with a Float64 time and with Unitful.NoUnits but you can set them to work with Unitful.Time units like ms, s, minute, hr. In this case tau returns a time, e.g. 1 s. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.setUnit!(sim::Clock, unit::FreeUnits): set a clock unit.\ntau(sim::Clock).val: return a unitless number for current time.At the moment I don't find it practical to work with units if for example I collect simulation events or variables with their time in a table or do plots. It seems easier not to use them as long you don't need automatic time conversion in your simulation projects.","category":"page"},{"location":"intro/#Types-and-functions-2","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Clock, ùê∂, tau, sample_time!, periodic!, run!, reset!, incr!, sync!, stop!, resume!,  ","category":"page"},{"location":"intro/#event_scheme-1","page":"Getting started","title":"Events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Julia functions or expressions are scheduled as events on the clock's time line. In order to not be invoked immediately,","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"event functions must be stored in a closure or in a fun and\nevent expressions must be quoted with :().","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Event functions in a fun can get 1) values, variables or 2) symbols, expressions or function closures or other funs as arguments. The 2nd case arguments are evaluated not till event time before they are passed to the event function.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Several functions and expressions can be scheduled as events combined in a tuple.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nEvaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"intro/#Timed-events-1","page":"Getting started","title":"Timed events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Timed events with event! schedule functions and expressions to execute at a given time:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"ev1 = :(println(tau(), \": I'm a quoted expression\"))\nev2 = fun(() -> println(tau(), \": I'm a fun\"))\nev3 = fun(println, fun(tau), \": now a is \", :a)  # various arguments to a fun\n\na = 1\nevent!(ev1, at, 2)                             # schedule events at 2, 3, 4, 6, 8\nevent!(ev3, at, 3)\nevent!(:(a += 5), at, 4)\nevent!(ev3, at, 6)\nevent!(ev1, after, 8)                          # schedule an event after 8\nevent!(ev2, every, 5)                          # schedule an event every 5","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)                             # run\n0.0: I'm a fun\n2.0: I'm a quoted expression\n3.0: now a is 1\n5.0: I'm a fun\n6.0: now a is 6\n8.0: I'm a quoted expression\n10.0: I'm a fun\n\"run! finished with 8 clock events, 0 sample steps, simulation time: 10.0\"\n\njulia> event!((ev1, ev2), after, 2)            # schedule both ev1 and ev2 as one event\n12.0\n\njulia> run!(ùê∂, 5)                              # run\n12.0: I'm a quoted expression\n12.0: I'm a fun\n15.0: I'm a fun\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 15.0\"","category":"page"},{"location":"intro/#Conditional-events-1","page":"Getting started","title":"Conditional events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Conditional events  with (event! execute under given conditions. Conditions can be formulated as logical expressions or functions or combinations of them.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"reset!(ùê∂)                                       # reset the clock\ny = 0                                           # create a variable y\nperiodic!( fun(() -> global y = tau()/2) );        # a sampling function\nevent!( fun(()->println(tau(),\": now y ‚â• œÄ\") ), (@val :y :‚â• œÄ) ) # a conditional event","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)                              # run\n6.28999999999991: now y ‚â• œÄ\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> 2œÄ                                       # exact value\n6.283185307179586","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"reset!(ùê∂)\nperiodic!( fun(()-> global y=sin(@tau)) );         # sample a sine function on y\nevent!(fun(()->println(tau(),\": now y ‚â• 1/2\")), ((@val :y :‚â• 1/2),(@tau :‚â• 5))) # two conditions","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)\n6.809999999999899: now y ‚â• 1/2\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> asin(0.5) + 2œÄ                           # exact value\n6.806784082777885","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"The example shows: (1) the sample rate has some uncertainty in detecting events and (2) conditional events are triggered only once. If there is no sample rate set, a conditional event sets one up and deletes it again after it becomes true.","category":"page"},{"location":"intro/#Types-and-functions-3","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"tau, fun, event!, run!, reset!, periodic!","category":"page"},{"location":"intro/#process_scheme-1","page":"Getting started","title":"Processes","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Functions can be started as asynchronous tasks or coroutines, which can coordinate with the clock and events by delaying for some time or waiting for conditions, taking inputs from events or other tasks, triggering events or starting other tasks ‚Ä¶","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"From a modeling or simulation standpoint we call such tasks processes, because they can represent some ongoing activity in nature. Tasks seen as processes are a powerful modeling device, but you need to take care that","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"they give back control to the clock and other processes by calling delays or conditional waits or requesting resources (and thus implicitly waiting for them to become available) and\nthey transfer critical operations to the clock in order to not get out of sync with simulation time.","category":"page"},{"location":"intro/#Create-and-start-a-process-1","page":"Getting started","title":"Create and start a process","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Prc prepares a function for running as a process and assignes it an id.  Then process! registers it to the clock and starts it as a process in a loop. You can define how many loops the function should persist, but the default is Inf. You can create as many instances of a function as processes as you like.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function doit(c::Clock, n)  # function doit takes a clock as 1st argument\n    i = 1\n    while i ‚â§ n\n        delay!(c, rand()*2)                     # delay for some time\n        now!(c, fun(println, @sprintf(\"%5.2f: finished %d\", tau(), i)))  # print\n        i += 1\n    end\nend\n\nRandom.seed!(1234);        \nreset!(ùê∂)                                       # reset the central clock\nprocess!(Prc(1, doit, 5), 1)                    # create, register and start doit(5) as a process, id=1, runs only once","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 5)                               # run for 5 time units\n 1.18: finished 1\n 2.72: finished 2\n 3.85: finished 3\n 4.77: finished 4\n\"run! finished with 8 clock events, 0 sample steps, simulation time: 5.0\"\n\njulia> run!(ùê∂, 2)                               # it is not yet finished, run 2 more\n 6.36: finished 5\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 7.0\"\n\n\njulia> run!(ùê∂, 3)                               # doit(5) is done with 5, nothing happens anymore\n\"run! finished with 0 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#Delay,-wait,-take-and-put-1","page":"Getting started","title":"Delay, wait, take and put","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"In order to synchronize with the clock, a process can","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"get the simulation time tau(),\ndelay!, which suspends it until after the given time t or\nwait! for a condition. This creates a conditional event! which reactivates the process when the conditions become true.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Processes can also interact directly e.g. via channels with take! and put!. This also may suspend them until there is something to take from a channel or until they are allowed to put something into it.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function watchdog(c::Clock, name)\n    delay!(c, until, 6 + rand())                    # delay until\n    now!(c, fun(println, @sprintf(\"%5.2f %s: yawn!, bark!, yawn!\", tau(), name)))\n    wait!(c, ((@val :hunger :‚â• 7),(@tau :‚â• 6.5)))   # conditional wait\n    while 5 ‚â§ hunger ‚â§ 10\n        now!(c, fun(println, @sprintf(\"%5.2f %s: %s\", tau(), name, repeat(\"wow \", Int(trunc(hunger))))))\n        delay!(c, rand()/2)                         # simple delay\n        if scuff\n            now!(c, fun(println, @sprintf(\"%5.2f %s: smack smack smack\", tau(), name)))\n            global hunger = 2\n            global scuff = false\n        end\n    end\n    delay!(c, rand())                               # simple delay\n    now!(c, fun(println, @sprintf(\"%5.2f %s: snore ... snore ... snore\", tau(), name)))\nend\n\nhunger = 0\nscuff = false\nreset!(ùê∂)\nRandom.seed!(1122)\n\nperiodic!(fun(()-> global hunger += rand()), 0.5)   # a sampling function: increasing hunger\nevent!(fun(()-> global scuff = true ), 7+rand())  # an event: scuff after 7 am\nprocess!(Prc(1, watchdog, \"Snoopy\"), 1)           # create, register and run Snoopy","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)\n 6.24 Snoopy: yawn!, bark!, yawn!\n 6.50 Snoopy: wow wow wow wow wow wow wow wow\n 6.98 Snoopy: wow wow wow wow wow wow wow wow wow\n 7.37 Snoopy: smack smack smack\n 7.38 Snoopy: snore ... snore ... snore\n\"run! finished with 10 clock events, 20 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nyou must not use or invoke operations like delay!, wait!, take! or put! outside of tasks and inside the Main process, because they will suspend it.","category":"page"},{"location":"intro/#IO-operations-1","page":"Getting started","title":"IO-operations","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Tasks must transfer critical IO operations to the clock with a now! call. When tasks invoke IO-operations like printing, reading or writing from or to files, directly, they give control back to the Julia scheduler. While the IO-operation continues the clock may advance with time and the task has got out of sync with simulation time. Processes therefore should enclose their IO-operations in a now! call. This will transfer them for execution to the clock, which must finish them before proceeding any further.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function bad(c::Clock)                         # bad: IO-operation DIY\n    delay!(c, rand()*2)\n    @printf(\"%5.2f: hi, here I am\\n\", tau())\nend\nRandom.seed!(1234);\nreset!(ùê∂)                                      # reset the clock\nprocess!(Prc(1, bad), 5)                       # setup a process with 5 cycles","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)                             # it runs only once !!!\n 1.18: hi, here I am\n\"run! finished with 1 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function better(c::Clock)                      # better: let the clock doit for you\n    delay!(c, rand()*2)\n    now!(c, fun(println, @sprintf(\"%5.2f: hi, I am fine\", tau())))\nend\nRandom.seed!(1234);\nreset!(ùê∂)                                      # reset the clock\nprocess!(Prc(1, better), 5)                    # setup a process with 5 cycles","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(ùê∂, 10)                             # it runs all 5 cycles\n 1.18: hi, I am fine\n 2.72: hi, I am fine\n 3.85: hi, I am fine\n 4.77: hi, I am fine\n 6.36: hi, I am fine\n\"run! finished with 10 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#Types-and-functions-4","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Prc, process!, delay!, wait!, now!, fun, run!, ùê∂, reset!, periodic!, event!","category":"page"},{"location":"intro/#continuous_sampling-1","page":"Getting started","title":"Continuous sampling","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Continuous sampling allows to bring continuous processes or real world data into a simulation or can be used for visualization or logging and collecting statistics.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If you provide the clock with a time interval Œît, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"sample_time!(Œît): set the clock's sample rate starting from now.\nperiodic!(expr): register a function or expression or a tuple of them for sampling. If no sample rate is set, set it implicitly.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nConditions set by conditional event! or by wait! are also evaluated with the sampling rate. But the conditional event disappears after the conditions are met and the sample rate is then canceled if no sampling functions are registered.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If no sample rate is set, the clock jumps from event to event.","category":"page"},{"location":"intro/#Running-a-simulation-1","page":"Getting started","title":"Running a simulation","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"After you have setup the clock, scheduled events, setup sampling or started processes ‚Äì as you have seen ‚Äì you can step or run through a simulation, stop or resume it.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"run!(clk::Clock, duration::Number): run a simulation for a given duration. Call all scheduled events and sampling actions in that timeframe.\nincr!(clk::Clock): take one simulation step, call the next tick or event.\nstop!(clk::Clock): stop a simulation\nresume!(clk::Clock): resume a halted simulation.","category":"page"},{"location":"usage/#User-guide-1","page":"User guide","title":"User guide","text":"","category":"section"},{"location":"usage/#Installation-1","page":"User guide","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"CurrentModule = Simulate","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Simulate.jl runs on Julia versions ‚â• v\"1.0\". Multithreading requires Julia ‚â• v\"1.3\".","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Simulate\nversion","category":"page"},{"location":"usage/#Simulate.Simulate","page":"User guide","title":"Simulate.Simulate","text":"Simulate\n\nA Julia package for discrete event simulation.\n\nThe current stable, registered version is installed with\n\npkg> add Simulate\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/Simulate.jl\")\n\n\n\n\n\n","category":"module"},{"location":"usage/#Simulate.version","page":"User guide","title":"Simulate.version","text":"version\n\nGives the package version:\n\njulia> using Simulate\n\njulia> Simulate.version\nv\"0.3.0\"\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Clocks-1","page":"User guide","title":"Clocks","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"A clock in Simulate.jl is an active object residing in a thread and registers function calls or expressions as events, schedules them at a given time or under a given condition and executes them at their time or if conditions are met.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clock and ActiveClocks have virtual (simulation) time. A Clock can control and synchronizes with ActiveClocks on other threads. It can be started and run for a given time.\nRTClocks have real (system) time and operate independently from each other and other clocks. They run continuously at given clock ticks and execute scheduled events if their time becomes due.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clock\nActiveClock\nRTClock","category":"page"},{"location":"usage/#Simulate.Clock","page":"User guide","title":"Simulate.Clock","text":"Clock(Œît::T=0; t0::U=0, unit::FreeUnits=NoUnits) where {T<:Number,U<:Number}\n\nCreate a new simulation clock.\n\nArguments\n\nŒît::T=0: time increment. If no Œît is given, the simulation doesn't tick,   but jumps from event to event. Œît can be set later with sample_time!.\nt0::U=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. t0=60s.\n\nFields\n\nid::Int: thread on which the clock is running,\nstate::ClockState: clock state,\ntime::Float64: clock time,\nunit::FreeUnits: time unit,\nend_time::Float64: end time for simulation,\nŒît::Float64: sampling time, timestep between ticks,\nac::Vector{ClockChannel}: active clocks running on parallel threads,\nsc::Schedule: the clock schedule (events, cond events and sampling),\nprocesses::Dict{Any, Prc}: registered Prces,\ntn::Float64: next timestep,\ntev::Float64: next event time,\nevcount::Int: event counter,\nscount::Int: sample counter\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()                 # create a unitless clock (standard)\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 minute, Œît=0.01667 minute, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s)               # create a clock with implicit unit setting\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 s, Œît=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(t0=60s)           # another example of implicit unit setting\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Œît=0.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> c = Clock(1s, t0=1hr)       # if given times with different units, Œît takes precedence\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=3600.0 s, Œît=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.ActiveClock","page":"User guide","title":"Simulate.ActiveClock","text":"ActiveClock(clock::Clock, master::Ref{Clock},\n            cmd::Channel{ClockEvent}, ans::Channel{ClockEvent})\n\nA thread specific clock which can be operated via a channel.\n\nFields\n\nclock::Clock: the thread specific clock,\nmaster::Ref{Clock}: a pointer to the master clock (on thread 1),\ncmd::Channel{ClockEvent}: the command channel from master,\nans::Channel{ClockEvent}: the response channel to master.\nid::Int: the id in master's ac array,\nthread::Int: the thread, the active clock runs on.\n\nnote: Note\n\n\nYou should not setup an ActiveClock explicitly. Rather this is done implicitly by fork!ing a Clock to other available threads or directly with PClock. It then can be accessed via pclock as in the following example.\n\nExample\n\njulia> using Simulate\n\njulia> clk = Clock()\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> fork!(clk)\n\njulia> clk    #  ‚¨á you got 3 parallel active clocks\nClock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\njulia> clk = PClock()\nClock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.01 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> pclock(clk, 1)    # get access to the 1st active clock (on thread 2)\nActive clock 1 on thrd 2: state=Simulate.Idle(), t=0.0 , Œît=0.01 , prc:0\n   scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.RTClock","page":"User guide","title":"Simulate.RTClock","text":"RTClock{T <: ClockEvent} <: AbstractClock\n\nReal time clocks use system time for time keeping and are controlled over a channel. They are independent from each other and other clocks and run asynchronously as tasks on arbitrary threads. Multiple real time clocks can be setup with arbitrary frequencies to do different things.\n\nFields\n\nclock::Clock:\ncmd::Channel{T}:\nback::Channel{T}:\nid::Int:\nthread::Int:\nt0::Float64:\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Clocks have the following substructures:","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Schedule\nClockChannel","category":"page"},{"location":"usage/#Simulate.Schedule","page":"User guide","title":"Simulate.Schedule","text":"Schedule()\n\nA Schedule contains events, conditional events and sampling functions to be executed or evaluated on the clock's time line.\n\nFields\n\nevents::PriorityQueue{DiscreteEvent,Float64}: scheduled events,\ncevents::Array{DiscreteCond,1}: conditional events to evaluate at each tick,\nsamples::Array{Sample,1}: sampling expressions to evaluate at each tick,\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.ClockChannel","page":"User guide","title":"Simulate.ClockChannel","text":"ClockChannel\n\nProvide a channel to an active clock or a real time clock.\n\nFields\n\nref::Ref{Task}: a pointer to an active clock,\nch::Channel: a communication channel to an active clock,\nid::Int: the thread id of the active clock.\ndone::Bool: flag indicating if the active clock has completed its cycle.\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"User guide","title":"User guide","text":"You can set time units and query the current clock time. There is a default clock ùê∂, which can be used for experimental work. RTC can be used to setup and control real time Clocks.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"setUnit!\ntau\nùê∂\nRTC","category":"page"},{"location":"usage/#Simulate.setUnit!","page":"User guide","title":"Simulate.setUnit!","text":"setUnit!(clk::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nclk::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60)     # setup a new clock with t0=60\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> tau(c) # current time is 60.0 NoUnits\n60.0\n\njulia> setUnit!(c, s)       # set clock unit to Unitful.s\n60.0 s\n\njulia> tau(c) # current time is now 60.0 s\n60.0 s\n\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\n\njulia> tau(c)               # current time is now 1.0 minute\n1.0 minute\n\njulia> isa(tau(c), Time)\ntrue\n\njulia> uconvert(s, tau(c))  # ... which can be converted to other time units\n60.0 s\n\njulia> tau(c).val           # it has a value of 1.0\n1.0\n\njulia> c.time               # internal clock time is set to 1.0 (a Float64)\n1.0\n\njulia> c.unit               # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.tau","page":"User guide","title":"Simulate.tau","text":"tau(clk::Clock=ùê∂)\n\nReturn the current simulation time.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> tau() # gives the central time\n0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.ùê∂","page":"User guide","title":"Simulate.ùê∂","text":"ùê∂\n\nùê∂ (ùê∂ = \\itC+tab) is the default simulation clock. If you do one simulation at a time, you can use it for time keeping.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\n\njulia> ùê∂  # default clock\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Simulate.RTC","page":"User guide","title":"Simulate.RTC","text":"RTC::Vector{ClockChannel}\n\nReal time clocks are registered to RTC and can be accessed and operated through it.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#","page":"User guide","title":"User guide","text":"You can create a clock with parallel active clocks on all available threads or fork existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel clocks and diagnose them.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"PClock\nfork!\npclock\ncollapse!\ndiagnose","category":"page"},{"location":"usage/#Simulate.PClock","page":"User guide","title":"Simulate.PClock","text":"PClock(Œît::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T<:Number,U<:Number}\n\nSetup a clock with parallel clocks on all available threads.\n\nArguments\n\nŒît::T=0.01: time increment. For parallel clocks Œît has to be > 0.   If given Œît ‚â§ 0 it is set to 0.01.\nt0::U=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. t0=60s.\n\nnote: Note\nProcesses on multiple threads are possible in Julia ‚â• 1.3 and with JULIA_NUM_THREADS > 1.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.fork!","page":"User guide","title":"Simulate.fork!","text":"fork!(master::Clock)\n\nEstablish copies of a clock on all parallel threads and operate them as active clocks under control of the master clock.\n\nArguments\n\nmaster::Clock: the master clock, must be on thread 1\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.pclock","page":"User guide","title":"Simulate.pclock","text":"pclock(clk::Clock, id::Int ) :: AbstractClock\npclock(ac::ActiveClock, id::Int ) :: AbstractClock\n\nGet a parallel clock to a given clock.\n\nArguments\n\nmaster::Clock: a master clock or\nac::ActiveClock: an active clock,\nid::Int=threadid(): thread id, defaults to the caller's current thread.\n\nReturns\n\nthe master Clock if id==0,\na parallel ActiveClock else\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.collapse!","page":"User guide","title":"Simulate.collapse!","text":"collapse!(master::Clock)\n\nTransfer the schedules of the parallel clocks to master and them stop them.\n\nnote: Note\nIf there are processes on other threads registered to parallel clocks, make sure that they aren't needed anymore before calling collapse. They are not transferred to and cannot be controlled by master.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.diagnose","page":"User guide","title":"Simulate.diagnose","text":"diagnose(clk::Clock, id::Int)\n\nReturn the stacktrace from a parallel clock.\n\nArguments\n\nclk::Clock: a master clock,\nid::Int: the id of a parallel clock.\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"User guide","title":"User guide","text":"note: Note\n","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Directly accessing the clock substructure of parallel ActiveClocks is possible but not recommended since it breaks parallel operation. The right way is to pass event!s to the ActiveClock-variable. The communication then happens over the channel to the ActiveClock as it should be.","category":"page"},{"location":"usage/#Events-1","page":"User guide","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Julia expressions and functions can be scheduled as events on the clock's timeline and are triggered at a given simulation time or under conditions which may become true during simulation.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Functions and expressions can be scheduled for execution","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"at given clock times and\nunder specified conditions.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"AbstractEvent\nAction\nDiscreteEvent\nDiscreteCond\nTiming\nfun\nevent!","category":"page"},{"location":"usage/#Simulate.AbstractEvent","page":"User guide","title":"Simulate.AbstractEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.Action","page":"User guide","title":"Simulate.Action","text":"Action\n\nAn action is either  a Function or an Expr or a Tuple of them. It can be scheduled in an event for later execution.\n\nwarning: Evaluating expressions is slow\n‚Ä¶ and should be avoided in time critical parts of applications. You will get a one time warning if you use them. They can be replaced easily by funs or function closures.\n\nnote: Expressions `Expr` ‚Ä¶\n‚Ä¶ are evaluated at global scope in Module Main only. Other modules using Simulate.jl cannot use expressions in events and have to use functions. This is for the end user only.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Simulate.DiscreteEvent","page":"User guide","title":"Simulate.DiscreteEvent","text":"DiscreteEvent{T<:Action} <: AbstractEvent\n\nA discrete event is an Action to be executed at an event time.\n\nArguments, fields\n\nex::T: a function or an expression or a tuple of them,\nt::Float64: event time,\nŒît::Float64: repeat rate with for repeating events.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.DiscreteCond","page":"User guide","title":"Simulate.DiscreteCond","text":"DiscreteCond{S<:Action, T<:Action} <: AbstractEvent\n\nA condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments, fields\n\ncond::S: a conditional function or an expression or a tuple of them   (conditions must evaluate to Bool),\nex::T: a function or an expression or a tuple of them to be executed   if conditions are met,\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.Timing","page":"User guide","title":"Simulate.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.fun","page":"User guide","title":"Simulate.fun","text":"fun(f::Function, args...; kwargs...)\n\nReturn a closure of a function f and its arguments for later execution.\n\nArguments\n\nThe arguments args... and keyword arguments kwargs... to fun are passed to f at execution but may change their values between beeing captured in fun and fs later execution. If f needs their current values at execution time there are two possibilities:\n\nfun can take symbols, expressions, funs or function closures at the  place of values or variable arguments. They are evaluated just before  being passed to f. There is one exception: if f is an event!, its  arguments are passed on unevaluated.\nA mutable type argument (Array, struct ...) is always current. You can  also change its content from within a function.\n\nwarning: Evaluating symbols and expressions is slow\n‚Ä¶ and should be avoided in time critical parts of applications. You will get a one time warning if you use that feature. They can be replaced easily by funs or function closures. See the Performance section in the documentation and the subsequent examples.\n\nnote: Symbols and expressions\n‚Ä¶ are evaluated at global scope in Module Main only. Other modules using Simulate.jl cannot use this feature and have to use functions.\n\nReturns\n\nA function closure of f(args..., kwargs...), which can be evaluated without arguments.\n\nExamples\n\njulia> using Simulate\n\njulia> g(x; y=1) = x+y\ng (generic function with 1 method)\n\njulia> x = 1\n1\n\njulia> gg = fun(g, :x, y=2);   # we pass x as a symbol to fun\n\njulia> x += 1   # a becomes 2\n2\n\njulia> gg()     # at execution g gets a current x and gives a warning\n‚îå Warning: Evaluating expressions is slow, use functions instead\n[...]\n4\n\njulia> hh = fun(g, fun(()->x), y=3);   # reference x with an anonymous fun\n\njulia> x += 1   # x becomes 3\n3\n\njulia> hh()     # at execution g gets again a current x\n6\n\njulia> ii = fun(g, ()->x, y=4);  # reference x with an anonymous function\n\njulia> x += 1   # x becomes 4\n4\n\njulia> ii()     # ok, g gets an updated x\n8\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.event!","page":"User guide","title":"Simulate.event!","text":"event!([clk::CL], ex::A, t::U; cycle::V=0.0,\n        cid::Int=clk.id, spawn=false, sync::Bool=false) where {CL<:AbstractClock,A<:Action,U<:Number,V<:Number}\nevent!([clk::CL], ex::A, T::Timing, t::U;\n        cid::Int=clk.id, spawn=false, sync::Bool=false) where {CL<:AbstractClock,A<:Action,U<:Number}\n\nSchedule an event for a given simulation time.\n\nArguments\n\nclk::AbstractClock: it not supplied, the event is scheduled to ùê∂,\nex<:Action: an expression or function or a tuple of them,\nT::Timing: a timing, one of at, after or every,\nt::U: simulation time, if t < clk.time set t = clk.time,\n\nKeyword arguments\n\ncycle::Float64=0.0: repeat cycle time for an event,\ncid::Int=clk.id: if cid ‚â† clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads,\nsync::Bool=false: if true, force a synchronization of all parallel clocks   before executing the event.\n\nreturns\n\nScheduled internal simulation time (unitless) for that event. May return a time > t from repeated applications of nextfloat(t) if there are events scheduled for t.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\n\njulia> event!(ùê∂, fun(myfunc, 1, 2), 1) # a 1st event to 1\n\njulia> event!(ùê∂, fun(myfunc, 2, 3), 1) #  a 2nd event to the same time\n\njulia> event!(ùê∂, fun(myfunc, 3, 4), 1s)\nWarning: clock has no time unit, ignoring units\n\njulia> setUnit!(ùê∂, s)\n0.0 s\n\njulia> event!(ùê∂, fun(myfunc, 4, 5), 1minute)\n\njulia> event!(fun(myfunc, 5, 6), after, 1hr)\n\n\n\n\n\n\nevent!(clk::T, ex::A, cond::C;\n       cid::Int=clk.id, spawn=false) where {T<:AbstractClock,A<:Action,C<:Action}\n\nSchedule a conditional event.\n\nIt is executed immediately if the conditions are met, else the condition is checked at each clock tick Œît. A conditional event is triggered only once. After that it is removed from the clock. If no sampling rate Œît is setup, a default sampling rate is setup depending on the scale of the remaining simulation time\n\nArguments\n\nclk::AbstractClock: if no clock is supplied, the event is scheduled to ùê∂,\nex::Union{SimExpr, Tuple{SimExpr}}: an expression or function or a tuple of them,\ncond::Union{SimExpr, Tuple{SimExpr}}: a condition is an expression or function   or a tuple of them. It is true only if all expressions or funs   therein return true,\ncid::Int=clk.id: if cid ‚â† clk.id, assign the event to the parallel clock   with id == cid. This overrides spawn,\nspawn::Bool=false: if true, spawn the event at other available threads.\n\nExamples\n\njulia> using Simulate\n\njulia> c = Clock()   # create a new clock\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> event!(c, fun((x)->println(tau(x), \": now I'm triggered\"), c), fun(>=, fun(tau, c), 5))\n\n# julia> c              # a conditional event turns sampling on  ‚¨á\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.01 , prc:0\n  scheduled ev:0, cev:1, sampl:0\n\njulia> run!(c, 10)   # sampling is not exact, so it takes 501 sample steps to fire the event\n5.009999999999938: now I'm triggered\n\"run! finished with 0 clock events, 501 sample steps, simulation time: 10.0\"\n\njulia> c   # after the event sampling is again switched off ‚¨á\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=10.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Functions and expressions can be given to events on their own or in tuples, even mixed:","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"function events()\n    event!(:(i += 1), after, 10)  # one expression\n    event!(fun(f, 1, 2, 3, diff=pi), every, 1)  # one fun\n    event!((:(i += 1), fun(g, j)), [:(tau() ‚â• 50), fun(isready, input), :(a ‚â§ 10)]) # two funs under three conditions\nend","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"All given functions or expressions are then called or evaluated at a given simulation time or when during simulation the given conditions become true.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"warning: Warning\nEvaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. See Performance. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"note: Note\nSince conditions often are not met exactly you should prefer inequalities like <, ‚â§, ‚â•, > to equality == in order to get sure that a fulfilled condition can be detected, e.g. :(tau() ‚â• 100) is preferable to :(tau() == 100).","category":"page"},{"location":"usage/#Continuous-sampling-1","page":"User guide","title":"Continuous sampling","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Functions or expressions can register for sampling and are then executed \"continuously\" at each clock increment Œît.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Sample\nsample_time!\nperiodic!","category":"page"},{"location":"usage/#Simulate.Sample","page":"User guide","title":"Simulate.Sample","text":"Sample{T<:Action} <: AbstractEvent\n\nSampling actions are executed at sampling time.\n\nArguments, fields\n\nex<:Action: an Action to be executed at sample time.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.sample_time!","page":"User guide","title":"Simulate.sample_time!","text":"sample_time!([clk::Clock], Œît::N) where {N<:Number}\n\nset the clock's sample rate starting from now (tau(clk)).\n\nArguments\n\nclk::Clock: if not supplied, set the sample rate on ùê∂,\nŒît::N: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.periodic!","page":"User guide","title":"Simulate.periodic!","text":"periodic!([clk::Clock], ex::T, Œît::U=clk.Œît; spawn=false) where {T<:Action,U<:Number}\nperiodic!(ac::ActiveClock, ex::T, Œît::U=ac.clock.Œît; kw...) where {T<:Action,U<:Number}\n\nRegister a function or expression for periodic execution at the clock`s sample rate.\n\nArguments\n\nclk::Clock, ac::ActiveClock: if not supplied, it samples on ùê∂,\nex<:Action: an expression or function or a tuple of them,\nŒît::U=clk.Œît: set the clock's sampling rate, if no Œît is given, it takes   the current sampling rate, if that is 0, it calculates one,\n\n\n\n\n\n","category":"function"},{"location":"usage/#Processes-1","page":"User guide","title":"Processes","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Julia functions can be registered and run as processes. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Prc\nClockException\nprocess!\ninterrupt!\nstop!(::Prc, ::ClockEvent)","category":"page"},{"location":"usage/#Simulate.Prc","page":"User guide","title":"Simulate.Prc","text":"Prc( id, f::Function, arg...; kw...)\n\nPrepare a function to run as a process in a simulation.\n\nArguments, fields\n\nid: some unique identification for registration,\ntask::Union{Task,Nothing}: a task structure,\nclk::Union{AbstractClock,Nothing}: clock where the process is registered,\nstate::ClockState: process state,\nf::Function: a function f(clk, arg...; kw...), must take clk as its   first argument,\narg...: further arguments to f\nkw...: keyword arguments to f\n\nnote: Note\nA function started as a Prc most often runs in a loop. It has to give back control by e.g. doing a take!(input) or by calling delay! etc., which will yield it. Otherwise it will starve everything else!\n\nwarn: Warn\nThat f nust take clk as first argument is a breaking change in v0.3!\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.ClockException","page":"User guide","title":"Simulate.ClockException","text":"ClockException(ev::ClockEvent, value=nothing)\n\nDefine a ClockException, which can be thrown to processes.\n\nArguments, fields\n\nev::ClockEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.process!","page":"User guide","title":"Simulate.process!","text":"process!([clk::Clock], p::Prc, cycles=Inf; spawn::Bool=false)\n\nRegister a Prc to a clock, start it as an asynchronous process and return the id it was registered with. It can then be found under clk.processes[id].\n\nArguments\n\nc::AbstractClock: Clock or ActiveClock, if not provided, the process runs   under ùê∂,\np::Prc: it contains a function and its arguments,\ncycles::T=Inf: number of cycles the process should run,\nspawn::Bool=false: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.\n\nnote: Note\nspawning a process is possible only with parallel clocks setup with PClock or fork!.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.interrupt!","page":"User guide","title":"Simulate.interrupt!","text":"interrupt!(p::Prc, ev::ClockEvent, value=nothing)\n\nInterrupt a Prc by throwing a ClockException to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}","page":"User guide","title":"Simulate.stop!","text":"Stop a Prc\n\n\n\n\n\n","category":"method"},{"location":"usage/#Delay-and-wait-‚Ä¶-1","page":"User guide","title":"Delay and wait ‚Ä¶","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Processes do not need to handle their events explicitly, but can call delay! or wait! or take! and put! ‚Ä¶ on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"delay!\nwait!","category":"page"},{"location":"usage/#Simulate.delay!","page":"User guide","title":"Simulate.delay!","text":"delay!(clk::Clock, t::T) where {T<:Number}\n\nDelay a process for a time interval t on the clock clk. Suspend the calling process until being reactivated by the clock at the appropriate time.\n\nArguments\n\nclk::Clock: if not provided, the delay goes to ùê∂.\nt::T: the time interval for the delay.\n\n\n\n\n\ndelay!(clk::Clock, T::Timing, t::N) where {N<:Number}\n\nUsed for delaying a process until a given time t.\n\nArguments\n\nclk::Clock: if no clock is given, the delay goes to ùê∂,\nT::Timing: only until is accepted,\nt::N: delay until time t if t > clk.time, else give a warning.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.wait!","page":"User guide","title":"Simulate.wait!","text":"wait!(clk::Clock, cond::A) where {A<:Action}\n\nWait on a clock for a condition to become true. Suspend the calling process until the given condition is true.\n\nArguments\n\nclk::Clock: if no clock is supplied, the delay goes to ùê∂,\ncond::A: a condition is an expression or function   or an array or tuple of them. It is true only if all expressions or functions   therein return true,\n\n\n\n\n\n","category":"function"},{"location":"usage/#Now-1","page":"User guide","title":"Now","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"Processes in a simulation want their IO-operations to finish before the clock proceeds. Therefore they must enclose those operations in a now! call.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"now!","category":"page"},{"location":"usage/#Simulate.now!","page":"User guide","title":"Simulate.now!","text":"now!(clk::Clock, ex::A) where {A<:Action}\n\nTell the clock to execute an operation. Thus it cannot proceed before the op is finished.\n\nnote: Note\nThis is needed for IO-operations of tasks. IO-operations yield the task to the scheduler and the scheduler may invoke the clock before giving control back to the task. In that case the clock will proceed and the task has gone out of sync with the clock. Use now! to avoid this situation!\n\nArguments\n\nclk::Clock,\nop::A: operation to execute.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Running-simulations-1","page":"User guide","title":"Running simulations","text":"","category":"section"},{"location":"usage/#","page":"User guide","title":"User guide","text":"If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are simulated ‚Ä¶ We can also step through a simulation, stop, resume or reset it.","category":"page"},{"location":"usage/#","page":"User guide","title":"User guide","text":"reset!\nincr!\nrun!\nonthread\nstop!(::Clock)\nresume!\nsync!","category":"page"},{"location":"usage/#Simulate.reset!","page":"User guide","title":"Simulate.reset!","text":"reset!(clk::Clock, Œît::T=0; t0::U=0, hard::Bool=true, unit=NoUnits) where {T<:Number, U<:Number}\n\nreset a clock\n\nArguments\n\nclk::Clock\nŒît::T=0: time increment\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Œît::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Œît=1.0 s, prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> reset!(c)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\n\njulia> c\nClock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.incr!","page":"User guide","title":"Simulate.incr!","text":"incr!(clk::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.run!","page":"User guide","title":"Simulate.run!","text":"run!(clk::Clock, duration::N) where {N<:Number}\n\nRun a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.onthread","page":"User guide","title":"Simulate.onthread","text":"onthread(f::F, id::Int) where {F<:Function}\n\nExecute a function f on thread id.\n\nSingle-threaded simulations involving processes speed up a lot when they are run on a thread other than 1. Thus they must not compete against background tasks.\n\nExamples, usage\n\njulia> using Simulate, .Threads\n\njulia> onthread(threadid, 2)\n2\n\njulia> onthread(3) do; threadid(); end\n3\n\njulia> onthread(4) do\n           threadid()\n       end\n4\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{Clock}","page":"User guide","title":"Simulate.stop!","text":"stop!(clk::Clock)\n\nStop a running simulation.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.resume!","page":"User guide","title":"Simulate.resume!","text":"resume!(clk::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sync!","page":"User guide","title":"Simulate.sync!","text":"sync!(clk::Clock, to::Clock=ùê∂)\n\nForce a synchronization of two clocks. Change all registered times of clk accordingly. Convert or force clk.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"history/#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history/#v0.2.0-1","page":"Version history","title":"v0.2.0","text":"","category":"section"},{"location":"history/#","page":"Version history","title":"Version history","text":"This is the first version fully supporting three modeling schemes: events, processes and sampling.","category":"page"},{"location":"history/#","page":"Version history","title":"Version history","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!,\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to ùê∂,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"history/#v0.1.0-1","page":"Version history","title":"v0.1.0","text":"","category":"section"},{"location":"history/#","page":"Version history","title":"Version history","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions,\nintroduced a central clock variable ùê∂,\nClock state machine with init!, run!, incr!, stop!, resume!,\nLogger and logging functions,\nfirst documentation,\nfirst examples,\nCI and development setup.","category":"page"},{"location":"troubleshooting/#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Problems-1","page":"Troubleshooting","title":"Problems","text":"","category":"section"},{"location":"troubleshooting/#Process-startup-1","page":"Troubleshooting","title":"Process startup","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Under some environments (e.g. Jupyter) it may happen, that the processes have not started completely before the clock runs. In such cases it may help to put a little sleep, e.g. sleep!(0.1) between process!(‚Ä¶) and run!(‚Ä¶) to ensure that all started processes have enqueued for clock events.","category":"page"},{"location":"troubleshooting/#Clock-information-1","page":"Troubleshooting","title":"Clock information","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Normally for clocks pretty printing is enabled. For diagnostic purposes you can switch pretty printing off and on:","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> clk = Clock()\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0\n\njulia> Simulate._show_default[1] = true;\n\njulia> clk\nClock(0, Simulate.Undefined(), 0.0, , 0.0, Simulate.AC[], Simulate.Schedule(DataStructures.PriorityQueue{Simulate.DiscreteEvent,Float64,Base.Order.ForwardOrdering}(), Simulate.DiscreteCond[], Simulate.Sample[]), Dict{Any,Prc}(), 0.0, 0.0, 0.0, 0, 0)\n\njulia> Simulate._show_default[1] = false;\n\njulia> clk\nClock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0\n  scheduled ev:0, cev:0, sampl:0","category":"page"},{"location":"troubleshooting/#A-process-fails-1","page":"Troubleshooting","title":"A process fails","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"If c is your clock, you get the list of all running processes with c.processes. You  then look at the failed process with c.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> ùê∂.processes\nDict{Any,Prc} with 2 entries:\n  2 => Prc(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{‚Ä¶\n  1 => Prc(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel‚Ä¶\njulia> ùê∂.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\n[....]","category":"page"},{"location":"troubleshooting/#Report-1","page":"Troubleshooting","title":"Report","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Otherwise please report your problem and open an issue or commit your solution to the repo.  ","category":"page"},{"location":"news/#News-in-v0.3.0-1","page":"News","title":"News in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"CurrentModule = Simulate","category":"page"},{"location":"news/#","page":"News","title":"News","text":"v0.3.0 is a significant improvement over 0.2.0 with a name change, multithreading, resource handling and a streamlined documentation.","category":"page"},{"location":"news/#Breaking-name-changes-1","page":"News","title":"Breaking name changes","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"following the advice on discourse and in issue #13 Simulate.jl   gets renamed to DiscreteEvents.jl. Github maintains and forwards the links.\nthere are further renamings to make the API more consistent:\nSimfunction ‚Üí fun, SF is no longer defined,\nSimProcess ‚Üí Prc, SP is no longer defined,\nSimEvent ‚Üí DiscreteEvent,\nSimCond ‚Üí DiscreteCond,\nsample! ‚Üí periodic!, was a name collision with Distributions.jl.","category":"page"},{"location":"news/#Streamlined-documentation-1","page":"News","title":"Streamlined documentation","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"the documentation has been reduced to minimal introductory examples and API documentation,\neverything else (further examples, notebooks, explanations, benchmarks) has been moved to a companion site: DiscreteEventsCompanion](https://github.com/pbayer/DiscreteEventsCompanion.jl).","category":"page"},{"location":"news/#New-functionality-in-v0.3.0-1","page":"News","title":"New functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Action is introduced as synonym for Union{Function,Expr,Tuple},\nthereby in addition to funs, you can now schedule arbitrary function closures as events,  \nperiodic! takes now an Action as argument,\nArguments to fun can now be symbols, expressions or other funs or function closures. They get evaluated at event time before being passed to the event function,\nSimulate.version gives now the package version,\nSimulate.jl is now much faster due to optimizations,\nonthread allows simulations with processes to run much faster on threads other than 1.","category":"page"},{"location":"news/#Multithreading-(still-in-the-making)-1","page":"News","title":"Multithreading (still in the making)","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"The data structure of Clock has been changed, it now has a field ac providing channels to parallel clocks,  \nPClock sets up a clock with parallel active clocks on each available thread,\nwith pclock all parallel clocks can be accessed and referenced,\nprocess! can now start tasks on parallel threads,\nevent! can now schedule events for execution on parallel threads,\nperiodic! can now register sampling functions or expressions to parallel clocks,\nif setup with parallel clocks, Clock becomes the master to drive them and synchronize with them at each Œît timestep,","category":"page"},{"location":"news/#Other-breaking-changes-in-v0.3.0-1","page":"News","title":"Other breaking changes in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"œÑ as an alias for tau is no longer defined.\nThe macros @tau, @val, @SF, @SP are no longer defined.\nLogging functions have been removed (they were not useful enough).\nA function f given to Prc must now take a Clock-variable as its first argument.\nThe first ::Clock-argument to delay! and wait! and now! can no  longer be omitted. Since the task function has now a Clock-variable available (see above), it must provide it to delay!, wait! and now.\nevent! no longer accepts a Vector as argument.\nClk as alias of ùê∂ is no longer provided.\nevent! now returns nothing.\nevent! and periodic! now doesn't take anymore the scope as an argument. Symbols or expressions given to them or included in funs are only evaluated in Main scope: this feature therefore can be used only by end users but not by any packages using Simulate.jl.","category":"page"},{"location":"news/#Deprecated-functionality-in-v0.3.0-1","page":"News","title":"Deprecated functionality in v0.3.0","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Evaluating expressions or symbols at global scope is much slower than using functions and gives now a one time warning. This functionality may be removed entirely in a future version. (Please write an issue if you want to keep it.)","category":"page"},{"location":"news/#Earlier-releases-1","page":"News","title":"Earlier releases","text":"","category":"section"},{"location":"news/#","page":"News","title":"News","text":"Release notes: A look at earlier releases.","category":"page"},{"location":"#Simulate.jl-1","page":"Home","title":"Simulate.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl provides three schemes for modeling and simulating discrete event systems (DES): 1) event scheduling, 2) interacting processes and 3) continuous sampling. It introduces a clock and allows to schedule arbitrary  functions or expressions as events, processes or sampling operations on the clock's timeline. It provides simplicity and flexibility in building models and performance in simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Development documentation\nThe development documentation is not yet updated. Many examples do not reflect the latest changes in the API and run only on v0.2.0! See the news for a list of changes in the API.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Getting started: Get an overview and learn the basics.\nUsage: Get detailed informations about types, functions and macros in Simulate.jl.\nTroubleshooting: If something doesn't work as expected.","category":"page"},{"location":"#Companion-1","page":"Home","title":"Companion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"There is a companion site DiscreteEventsCompanion with notebooks, further docs, examples and benchmarks.","category":"page"},{"location":"#Development-1","page":"Home","title":"Development","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl is a new package and still in active development. Please use, test and help  evolve it. Its GitHub repository is at https://github.com/pbayer/Simulate.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"}]
}
