var documenterSearchIndex = {"docs":
[{"location":"history/#Version-history-1","page":"History","title":"Version history","text":"","category":"section"},{"location":"history/#v0.2.0-(development)-1","page":"History","title":"v0.2.0 (development)","text":"","category":"section"},{"location":"history/#","page":"History","title":"History","text":"now! for encapsulating IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!(cond),\nconditional events with event!(sim, ex, cond),\neverything can be called without the first clock argument, it then goes to ùê∂,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!\nextensive documentation,\nmore examples,","category":"page"},{"location":"history/#v0.1.0-1","page":"History","title":"v0.1.0","text":"","category":"section"},{"location":"history/#","page":"History","title":"History","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions.\nintroduced a central clock variable ùê∂\nClock state machine with init!, run!, incr!, stop!, resume!\nLogger and logging functions\nfirst documentation\nfirst examples\nCI and development setup","category":"page"},{"location":"examples/examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"The examples are intended to show, how Simulate.jl can be used and how the different approaches to modeling and simulation can be effectively combined.","category":"page"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Pages = [\"greeting.md\", \"singleserver.md\", \"tabletennis.md\"]","category":"page"},{"location":"examples/examples/#Notebooks-1","page":"Examples","title":"Notebooks","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"greeting.ipynb: a first illustration\ntabletennis.ipynb: a simple table tennis simulation.\nsingleserver.ipynb: single server modeling, simulation and analysis.\npostoffice.ipynb: process based simulation of a post office,\ndicegame.ipynb: process based simulation of Goldratt's dice game - must yet be adopted to Simulate!","category":"page"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Jupyter-notebooks are here in the repo","category":"page"},{"location":"examples/examples/#Programs-1","page":"Examples","title":"Programs","text":"","category":"section"},{"location":"examples/examples/#","page":"Examples","title":"Examples","text":"Julia programs/.jl-files are here in the repo.","category":"page"},{"location":"intro/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Simulate.jl provides 4 major building blocks for modeling and simulation of discrete event systems:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"a clock provides a virtual simulation time,\nevents are expressions or functions scheduled for execution at given times or conditions,\nprocesses are functions, that run asynchronously and can wait for a time or condition,\na mechanism for continuous sampling.","category":"page"},{"location":"intro/#The-clock-1","page":"Introduction","title":"The clock","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"The clock is central to any model and simulation, since it establishes the timeline. It provides not only the time, but contains also the time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Œît.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> using Simulate\n\njulia> c = Clock()                           ### create a new clock\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> tick() = println(tau(c), \": tick!\")   ### define a function printing the clock's time\ntick (generic function with 1 method)\njulia> event!(c, SF(tick), every, 1)         ### schedule a repeat event on the clock\n0.0\njulia> run!(c, 10)                           ### run the clock for 10 time units\n0.0: tick!\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 11 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Usually you can simply use the central clock Clk alias ùê∂ (\\itùê∂+tab):","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> tick() = println(tau(), \": tick!\")         ### the tick function now uses the central time tau()\ntick (generic function with 1 method)\njulia> sample_time!(1)                            ### set the sampling rate on the central clock to 1\n1.0\njulia> sample!( SF(tick) );                       ### set tick as a sampling function\n\njulia> ùê∂                                          ### now ùê∂ has one sampling entry and the sample rate set\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 1, sample rate Œît=1.0\njulia> run!(ùê∂, 5)                                 ### run for 5 time units\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 5.0\"\njulia> run!(ùê∂, 5)                                 ### run again\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 10.0\"\njulia> reset!(ùê∂)                                  ### reset the clock\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"If Œît = 0, the clock doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"note: Note\nClocks work with a Float64 time and with Unitful.NoUnits but you can set them to work with Unitful.Time units like ms, s, minute, hr. In this case tau(c) returns a time, e.g. 1 s. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.setUnit(sim::Clock, unit::FreeUnits): set a clock unit.\ntau(sim::Clock).val: return unitless number for current time.At the moment I find it unconvenient to work with units if you trace simulation times in a table or you do plots. It seems easier not to use them as long you need automatic time conversion in your simulation projects.","category":"page"},{"location":"intro/#Events-1","page":"Introduction","title":"Events","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Julia functions or expressions are scheduled as events on the clock's time line. In order to not be invoked immediately,","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"expressions must be quoted with :() and\nfunctions must be enclosed inside a SimFunction, alias SF","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Quoted expressions and SimFunctions can be given to events mixed in a tuple or array. The following illustration uses timed events:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> ev1 = :(println(tau(), \": I'm a quoted expression\"))\n:(println(tau(), \": I'm a quoted expression\"))\njulia> ev2 = SF(() -> println(tau(), \": I'm a SimFunction\"))\nSimFunction(getfield( Symbol(\"##1#2\"))(), (), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\njulia> event!(ev1, at, 2)                      ### schedule an event at 2\n2.0\njulia> event!(ev1, after, 8)                   ### schedule an event after 8\n8.0\njulia> event!(ev2, every, 5)                   ### schedule an event every 5\n0.0\njulia> run!(ùê∂, 10)                             ### run\n0.0: I'm a SimFunction\n2.0: I'm a quoted expression\n5.0: I'm a SimFunction\n8.0: I'm a quoted expression\n10.0: I'm a SimFunction\n\"run! finished with 5 clock events, 0 sample steps, simulation time: 10.0\"\njulia> event!((ev1, ev2), after, 2)            ### schedule both ev1 and ev2 as event\n12.0\njulia> run!(ùê∂, 5)                              ### run\n12.0: I'm a quoted expression\n12.0: I'm a SimFunction\n15.0: I'm a SimFunction\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 15.0\"","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Conditional events execute under given conditions. Conditions can be formulated by using the @tau macro questioning the simulation time, the @valmacro questioning a variable or any other logical expression or function or combinations of them.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"julia> reset!(ùê∂)                                ### reset the clock\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> y = 0                                    ### create a variable\n0\njulia> sample!( SF(() -> global y = tau()/2) ); ### a sampling function\n\njulia> ùê∂                                        ### the sample rate Œît=0.01 was set implicitly\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 1, sample rate Œît=0.01\njulia> event!( SF(()->println(tau(),\": now y ‚â• œÄ\") ), (@val :y :‚â• œÄ) ) ### a conditional event\n0.0\njulia> run!(ùê∂, 10)                              ### run\n6.28999999999991: now y ‚â• œÄ\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\njulia> 2œÄ                                       ### exact value\n6.283185307179586\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> sample!( SF(()-> global y=sin(@tau)) );  ### create a sine function\n\njulia> event!(SF(()->println(tau(),\": now y ‚â• 1/2\")), ((@val :y :‚â• 1/2),(@tau :‚â• 5))) ### two conditions\n0.0\njulia> run!(ùê∂, 10)\n6.809999999999899: now y ‚â• 1/2\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\njulia> asin(0.5) + 2œÄ                           ### exact value\n6.806784082777885","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"It can be seen: (1) the sample rate has some uncertainty in detecting events and (2) conditional events are triggered only once.","category":"page"},{"location":"intro/#Processes-1","page":"Introduction","title":"Processes","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Functions can be started as asynchronous processes or coroutines, which aside from doing something useful can coordinate with the clock and other events by delaying for some time or waiting for conditions, taking inputs from events or other processes, triggering events or starting other processes ‚Ä¶","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Processes are a powerful modeling device, but you need to take care that","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"they give back control to the clock and other processes by calling delays or conditional waits or requesting resources (and thus implicitly waiting for them to become available) and\nthey keep synchronized with the clock by locking the clock until critical operations are finished.","category":"page"},{"location":"intro/#Create-and-start-a-process-1","page":"Introduction","title":"Create and start a process","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"The function gets enclosed in a SimProcess, alias SP with its own id assigned.  process! registers it to the clock and starts it as a process in a loop. You can define how many loops the function should take, but the default is Inf. You can create as many instances of a function as processes as you like.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"intro/#Delay,-wait,-take-and-put-1","page":"Introduction","title":"Delay, wait, take and put","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"In order to synchronize with the clock, a process can get the simulation time tau(), call for a delay!, which suspends it, creates an event on the clock's timeline and wakes up the process after the given time t. A conditional wait! goes also to the clock and gets treated in the same way: when the conditions become true, the clock gives back control to the process.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Processes can also interact directly e.g. via Julia's channels with take! and put!. This also may suspend them until there is something to take or until they can put something in a channel. In simulations they must take care that they keep synchronized with the clock.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"intro/#Lock-and-unlock-the-clock-1","page":"Introduction","title":"Lock and unlock the clock","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"When a process does IO-operations like printing, reading or writing from or to files, it gives control back to the Julia scheduler. Then, before the operation gets completed, the clock may proceed further. In order to avoid this situation, processes should encapsulate  critical operations in a now! call. This will tell the clock that there are some operations to complete and then unlock it again.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"intro/#Continuous-sampling-1","page":"Introduction","title":"Continuous sampling","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"If we provide the clock with a time interval Œît, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"sample_time!(sim::Clock, Œît::Number): set the clock's sampling time starting from now (tau(sim)).\nsample!(sim::Clock, ex::Union{Expr,SimFunction}): enqueue a function or expression for sampling.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.","category":"page"},{"location":"intro/#Running-a-simulation-1","page":"Introduction","title":"Running a simulation","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Now, after we have setup a clock, scheduled events or setup sampling, we can step or run through a simulation, stop or resume it.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"run!(sim::Clock, duration::Number): run a simulation for a given duration. Call all ticks and scheduled events in that timeframe.\nincr!(sim::Clock): take one simulation step, call the next tick or event.\nstop!(sim::Clock): stop a simulation\nresume!(sim::Clock): resume a halted simulation.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Now we can evaluate the results.","category":"page"},{"location":"intro/#Logging-1","page":"Introduction","title":"Logging","text":"","category":"section"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"Logging enables us to trace variables over simulation time and such analyze their behaviour.","category":"page"},{"location":"intro/#","page":"Introduction","title":"Introduction","text":"L = Logger(): create a new logger, providing the newest record L.last, a logging table L.df and a switch L.ltype between logging types.\ninit!(L::Logger, sim::Clock=ùê∂):\nsetup!(L::Logger, vars::Array{Symbol}): setup L, providing it with an array of logging variables [:a, :b, :c ...]\nswitch!(L::Logger, to::Number=0): switch between 0: only keep the last record, 1: print, 2: write records to the table\nrecord!(L::Logger): record the logging variables with current simulation time.","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"CurrentModule = Simulate","category":"page"},{"location":"internals/#Module-1","page":"Internals","title":"Module","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Simulate","category":"page"},{"location":"internals/#Simulate.Simulate","page":"Internals","title":"Simulate.Simulate","text":"Simulate\n\nA Julia package for discrete event simulation based on state machines.\n\n\n\n\n\n","category":"module"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The module contains two main types: Clock and Logger. Both are implemented as state machines. The implementation functions and types are not exported. The exported functions documented above under Usage are commands to the internal state machines.","category":"page"},{"location":"internals/#State-machines-1","page":"Internals","title":"State machines","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We have some definitions for them to work.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEngine","category":"page"},{"location":"internals/#Simulate.SEngine","page":"Internals","title":"Simulate.SEngine","text":"supertype for state machines in Sim.jl\n\n\n\n\n\n","category":"type"},{"location":"internals/#States-1","page":"Internals","title":"States","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined states for state machines.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SState\nUndefined\nIdle\nEmpty\nBusy\nHalted","category":"page"},{"location":"internals/#Simulate.SState","page":"Internals","title":"Simulate.SState","text":"supertype for states\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Undefined","page":"Internals","title":"Simulate.Undefined","text":"a state machine is undefined (after creation)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Idle","page":"Internals","title":"Simulate.Idle","text":"a state machine is idle\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Empty","page":"Internals","title":"Simulate.Empty","text":"a state machine is empty\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Busy","page":"Internals","title":"Simulate.Busy","text":"a state machine is busy\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Halted","page":"Internals","title":"Simulate.Halted","text":"a state machine is halted\n\n\n\n\n\n","category":"type"},{"location":"internals/#Events-1","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined events.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEvent\nInit\nSetup\nSwitch\nLog\nStep\nRun\nStart\nStop\nResume\nClear","category":"page"},{"location":"internals/#Simulate.SEvent","page":"Internals","title":"Simulate.SEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Init","page":"Internals","title":"Simulate.Init","text":"Init(info): Init event with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Setup","page":"Internals","title":"Simulate.Setup","text":"Setup(vars::Array{Symbol,1}, scope::Module): setup a logger with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Switch","page":"Internals","title":"Simulate.Switch","text":"Switch(to): switch to some other mode\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Log","page":"Internals","title":"Simulate.Log","text":"Log(): record command for logging\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Step","page":"Internals","title":"Simulate.Step","text":"Step(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Run","page":"Internals","title":"Simulate.Run","text":"Run(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Start","page":"Internals","title":"Simulate.Start","text":"Start(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Stop","page":"Internals","title":"Simulate.Stop","text":"Stop(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Resume","page":"Internals","title":"Simulate.Resume","text":"Resume(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Clear","page":"Internals","title":"Simulate.Clear","text":"Clear(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Transition-functions-1","page":"Internals","title":"Transition functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In state machines transitions occur depending on states and events. The different transitions are described through different methods of the step!-function.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"step!","category":"page"},{"location":"internals/#Simulate.step!","page":"Internals","title":"Simulate.step!","text":"step!(A::SEngine, q::SState, œÉ::SEvent)\n\nDefault transition for clock and logger.\n\nThis is called if no otherwise defined transition occurs.\n\nArguments\n\nA::SEngine: state machine for which a transition is called\nq::SState:  state of the state machine\nœÉ::SEvent:  event, triggering the transition\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, ::Init)\n\ninitialize a clock.\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, œÉ::Union{Step,Run})\n\nif uninitialized, initialize and then Step or Run.\n\n\n\n\n\nstep!(sim::Clock, ::Union{Idle,Busy,Halted}, ::Step)\n\nstep forward to next tick or scheduled event.\n\nAt a tick evaluate (1) all sampling expressions, (2) all conditional events, then (3) if an event is encountered, evaluate the event expression.\n\nThe internal clock times sim.tev and sim.tsa must always be set to be at least sim.time.\n\n\n\n\n\nstep!(sim::Clock, ::Idle, œÉ::Run)\n\nRun a simulation for a given duration.\n\nThe duration is given with Run(duration). Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\nstep!(sim::Clock, ::Busy, ::Stop)\n\nStop the clock.\n\n\n\n\n\nstep!(sim::Clock, ::Halted, ::Resume)\n\nResume a halted clock.\n\n\n\n\n\nstep!(sim::Clock, q::SState, œÉ::SEvent)\n\ncatch all step!-function.\n\n\n\n\n\nstop a SimProcess\n\n\n\n\n\nstep!(A::Logger, ::Undefined, œÉ::Init)\n\nInitialize a logger.\n\n\n\n\n\nstep!(A::Logger, ::Empty, œÉ::Setup)\n\nSetup a logger with logging variables. They are given by Setup(vars, scope).\n\n\n\n\n\nstep!(A::Logger, ::Idle, ::Clear)\n\nClear the last record and the data table of a logger.\n\n\n\n\n\nstep!(A::Logger, ::Idle, œÉ::Log)\n\nLogging event.\n\n\n\n\n\nstep!(A::Logger, ::Idle, œÉ::Switch)\n\nSwitch the operating mode of a logger by Switch(to).\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"internals/#Other-internal-types-and-functions-1","page":"Internals","title":"Other internal types and functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SimEvent\nSimCond\nSample\nsconvert\nsimExec\nnextevent\nnextevtime\nchecktime\nsetTimes\nstartup!\nloop\nscale","category":"page"},{"location":"internals/#Simulate.SimEvent","page":"Internals","title":"Simulate.SimEvent","text":"SimEvent(ex::Array{SimExpr, 1}, scope::Module, t::Float64, Œît::Float64)\n\nCreate a simulation event: a SimExpr or an array of SimExpr to be executed at event time.\n\nArguments\n\nex::Array{SimExpr, 1}: an array of SimExpr to be evaluated at event time,\nscope::Module: evaluation scope,\nt::Float64: event time,\nŒît::Float64: repeat rate with which the event gets repeated.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.SimCond","page":"Internals","title":"Simulate.SimCond","text":"SimCond(cond::Array{SimExpr, 1}, ex::Array{SimExpr, 1}, scope::Module)\n\ncreate a condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments\n\ncond::Array{SimExpr, 1}: Expr or SFs to be evaluated as conditions\nex::Array{SimExpr, 1}: Expr or SFs to be evaluated if conditions are all true\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Sample","page":"Internals","title":"Simulate.Sample","text":"Sample(ex::SimExpr, scope::Module)\n\nCreate a sampling expression.\n\nArguments\n\nex::SimExpr: expression or SimFunction to be called at sample time\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.sconvert","page":"Internals","title":"Simulate.sconvert","text":"sconvert(ex::Union{SimExpr,Array,Tuple})::Array{SimExpr,1}\n\nconvert a SimExpr or an array or a tuple of it to an Array{SimExpr,1}\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.simExec","page":"Internals","title":"Simulate.simExec","text":"simExec(ex::Union{SimExpr, Array{SimExpr,1}}, m::Module=Main)\n\nevaluate the event expressions or SimFunctions.\n\nReturn\n\nthe evaluated value or a tuple of evaluated values\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevent","page":"Internals","title":"Simulate.nextevent","text":"nextevent(sim::Clock)\n\nReturn the next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevtime","page":"Internals","title":"Simulate.nextevtime","text":"nextevtime(sim::Clock)\n\nReturn the internal time (unitless) of next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.checktime","page":"Internals","title":"Simulate.checktime","text":"checktime(sim::Clock, t::Number)::Float64\n\ncheck t given according to clock settings and return value\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.setTimes","page":"Internals","title":"Simulate.setTimes","text":"setTimes(sim::Clock)\n\nset clock times for next event or sampling action. The internal clock times sim.tev and sim.tsa must always be set to be at least sim.time.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.startup!","page":"Internals","title":"Simulate.startup!","text":"startup!(p::SimProcess)\n\nStart a SimProcess as a task in a loop.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.loop","page":"Internals","title":"Simulate.loop","text":"loop(p::SimProcess, start::Channel, cycles::Number)\n\nPut a SimProcess in a loop, which can be broken by a SimException.\n\nArguments\n\np::SimProcess:\nstart::Channel:\ncycles=Inf:\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.scale","page":"Internals","title":"Simulate.scale","text":"calculate the scale form a given number\n\n\n\n\n\n","category":"function"},{"location":"troubleshooting/#Troubleshooting-1","page":"Troubeshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#A-SimProcess-fails-1","page":"Troubeshooting","title":"A SimProcess fails","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubeshooting","title":"Troubeshooting","text":"You can check, if that is the case: if ùê∂ is your clock, you get the list of all running processes with ùê∂.processes. Than you can look at the failed process with ùê∂.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/#","page":"Troubeshooting","title":"Troubeshooting","text":"julia> ùê∂.processes\nDict{Any,SimProcess} with 2 entries:\n  2 => SimProcess(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{‚Ä¶\n  1 => SimProcess(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel‚Ä¶\njulia> ùê∂.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\nClosest candidates are:\n  round(::Float64, ::RoundingMode{:Nearest}) at float.jl:370\n  round(::Float64, ::RoundingMode{:Up}) at float.jl:368\n  round(::Float64, ::RoundingMode{:Down}) at float.jl:366\n  ...\nlogevent(::Int64, ::Channel{Any}, ::String, ::Int64) at ./In[6]:12\npeople(::Channel{Any}, ::Channel{Any}, ::Float64) at ./In[17]:8\nloop(::SimProcess) at /Users/paul/.julia/packages/Simulate/BOeZP/src/process.jl:37\n(::getfield(Simulate, Symbol(\"##19#20\")){SimProcess})() at ./task.jl:268","category":"page"},{"location":"examples/singleserver/#Single-server-1","page":"Single server","title":"Single server","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: single server)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Initially there are no jobs in the queue Q and the machine M is idle.\nJobs arrive with an inter-arrival-time t_aand are added to Q.\nIf M is idle, it loads a job, changes to busy and executes the job with service time t_s.\nAfter that it changes to idle and, if Q is not empty, it loads the next job.","category":"page"},{"location":"examples/singleserver/#Implementing-it-1","page":"Single server","title":"Implementing it","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use this simple example for illustration of how it can be modeled, simulated and analyzed using Sim.jl. First we have to import the necessary modules:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"using Simulate, Random, Distributions, DataFrames, Plots, LaTeXStrings\npyplot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We have to define some data structures, variables and a function for collecting stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"abstract type MState end\n\nstruct Idle <: MState end\nstruct Busy <: MState end\n\nmutable struct Job\n    no::Int64\n    ts::Float64\n    t1::Float64\n    t2::Float64\n    t3::Float64\nend\n\nmutable struct Machine\n    state::MState\n    job\nend\n\nQ = Job[]   # input queue\nS = Job[]   # stock\nM = Machine(Idle(), 0)\ndf = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\ncount = 1\nprinting = true\n\nstats() = push!(df, (tau(), length(Q), M.state == Busy() ? 1 : 0, length(S)))","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can model our system activity-based und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use the arrival-function for modeling arrival rate t_a with an Erlang and service time t_s with a Normal distribution. We determine the capacity of the server with a c variable such that c  1 gives us overcapacity and c = 1 means that mean service time equals mean arrival rate bart_s = bart_a.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function arrive(Œº, œÉ, c)\n    @assert Œº ‚â• 1 \"Œº must be ‚â• 1\"\n    ts = rand(Normal(Œº, œÉ))/c\n    job = Job(count, ts, tau(), 0, 0)\n    global count += 1\n    push!(Q, job)\n    ta = rand(Erlang())*Œº\n    event!(ùê∂, SimFunction(arrive, Œº, œÉ, c), after, ta)  # we schedule the next arrival\n    printing ? println(tau(), \": job $(job.no) has arrived\") : nothing # tau() is the current time\n    if M.state == Idle()\n        load()\n    else\n        stats()\n    end\nend\n\nfunction load()\n    M.state = Busy()\n    M.job = popfirst!(Q)\n    M.job.t2 = tau()\n    event!(ùê∂, SimFunction(unload), after, M.job.ts)  # we schedule the unload\n    printing ? println(tau(), \": job $(M.job.no) has been loaded\") : nothing\n    stats()\nend\n\nfunction unload()\n    M.state = Idle()\n    M.job.t3 = tau()\n    push!(S, M.job)\n    printing ? println(tau(), \": job $(M.job.no) has been finished\") : nothing\n    stats()\n    M.job = 0\n    if !isempty(Q)\n        load()\n    end\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We want to collect stats() at a sample rate of 0.1:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"sample_time!(ùê∂, 0.1)  # we determine the sample rate\nSim.sample!(ùê∂, SimFunction(stats));  # we register stats() as sampling function","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and mu = 5, sigma = 15 and c = 1 and let our system run for 30 minutes (let's assume our time unit be minutes):","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Random.seed!(2019)\narrive(5, 1/5, 1)  # we schedule the first event\nrun!(ùê∂, 30)        # and run the simulation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This will give us as output:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"0: job 1 has arrived\n0: job 1 has been loaded\n4.947453062901819: job 1 has been finished\n8.515206032139384: job 2 has arrived\n8.515206032139384: job 2 has been loaded\n8.56975795472613: job 3 has arrived\n8.666481204359087: job 4 has arrived\n10.338522593089287: job 5 has arrived\n11.021099411385869: job 6 has arrived\n13.267881315092211: job 7 has arrived\n13.703372376147774: job 2 has been finished\n13.703372376147774: job 3 has been loaded\n18.726550601155594: job 3 has been finished\n18.726550601155594: job 4 has been loaded\n19.55941423914075: job 8 has arrived\n19.58302738045451: job 9 has arrived\n20.543366077813385: job 10 has arrived\n22.752994020639125: job 11 has arrived\n23.563550850400553: job 4 has been finished\n23.563550850400553: job 5 has been loaded\n23.960464112286694: job 12 has arrived\n26.84742108339802: job 13 has arrived\n28.18186102251928: job 5 has been finished\n28.18186102251928: job 6 has been loaded\n\"run! finished with 17 events, simulation time: 30.0\"","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Using our collected data, we can plot the simulation model trajectory:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function trajectory_plot()\n    p1 = plot(df.time, df.buffer, ylabel=\"buffer\", fill=(0,0.1,:blue))\n    p2 = plot(df.time, df.machine, ylabel=\"machine\", fill=(0,0.1,:blue))\n    p3 = plot(df.time, df.finished, xlabel=\"time [min]\", ylabel=\"stock\", fill=(0,0.1,:blue))\n    plot(p1,p2,p3, layout=(3,1), legend=false)\nend\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 1)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 \"minutes\".","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"printing = false\nrun!(ùê∂, 970)        # we continue the simulation\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren't very instructive, so let's compare lead time W and number of jobs in the system L = textbuffer_size + textmachine_load:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function WvsL() # get more instructive info from simulation run\n    t = [j.t1 for j ‚àà S]\n    W = [j.t3 - j.t1 for j ‚àà S]\n    ts = [j.t3 - j.t2 for j ‚àà S]\n    subs = [i ‚àà t for i ‚àà df.time]\n    L = (df.buffer + df.machine)[subs]\n    l = df.machine[subs]\n    DataFrame(time=t, load=l, W=W, L=L, ts=ts)\nend\nd = WvsL()\nplot(d.time, d.W, label=\"W [min]\", xlabel=\"time [min]\", lw=2, legend=:topleft, title=\"L and W over time\")\nplot!(d.time, d.L, label=\"L [jobs]\", lw=2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: L and W over time)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Lead time W and unfinished jobs L are clearly increasing, the system is not stationary and gets jammed over time. Let's collect some stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"collect_stats() =\n    (Lm = mean(d.L), Wm = mean(d.W), Œ∑ = mean(df.machine), tsm = mean(d.ts))\ncollect_stats()\n(Lm = 16.21105527638191, Wm = 78.8196419189297, Œ∑ = 0.9778719397363466, tsm = 5.003771234356064)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Server load of overlineŒ∑  98 is great, but the mean queue length overlineL of 16 and mean lead time overlineW  79 min are way too long for a service time of t_s  5 min. So let's analyze the dependency of mean queue length overlineL on server capacity c. For that we can manipulate the server capacity in the arrival function and collect the results in a table:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], Œ∑=Float64[], tsm=Float64[])\nfor c ‚àà collect(0.97:0.01:1.7)\n    global Q = Job[]   # input queue\n    global S = Job[]   # stock\n    global M = Machine(Idle(), 0)\n    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\n    global count = 1\n\n    reset!(ùê∂)                            # reset ùê∂\n    sample_time!(ùê∂, 1)                   # set sample rate to 1\n    Sim.sample!(ùê∂, SimFunction(stats))   # register the stats() function for sampling\n\n    Random.seed!(2019)\n    arrive(5, 1/5, c)\n    run!(ùê∂, 1000)                        # run another simulation for 1000 \"min\"\n    global d = WvsL()\n    s = collect_stats()\n    push!(df1, (c, s.Lm, s.Wm, s.Œ∑, s.tsm))\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can look at it in a scatter plot:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.c, df1.Wm, title=L\"\\overline{W}\"*\" and \"*L\"\\overline{L}\"*\" over server capacity\",\n    xlabel=\"server capacity\", marker = (:o, 3, 0.4, :blue), label=L\"\\overline{W}\"*\" [min]\")\nscatter!(df1.c, df1.Lm, marker = (:x, 4), label=L\"\\overline{L}\"*\" [jobs]\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: W and L over server capacity)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We need to increase server capacity much in order to avoid long queues and waiting times.","category":"page"},{"location":"examples/singleserver/#How-about-Little's-law?-1","page":"Single server","title":"How about Little's law?","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"overlineW and overlineL seem to be proportional. This is stated by Little's law:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"beginequation\nL = lambdatimes W\nendequation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"for stationary systems with lambda = arrival rate. In our case lambda = t_a = 5. Let's look at it:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.Lm, df1.Wm, xlabel=L\"\\overline{L}\"*\" [jobs]\", ylabel=L\"\\overline{W}\"*\" [min]\",\n    marker = (:o, 4, 0.4, :blue), label=\"data\", title=\"Little's law\", legend=:topleft)\nplot!(df1.Lm, df1.Lm*5, label=\"theory \"*L\"(\\overline{L}\\times 5)\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: Little's law)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little's law seems not to be a bad one. In order to analyze stability and stationarity and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with Simulate.jl ...","category":"page"},{"location":"examples/singleserver/#-1","page":"Single server","title":"üòÑ","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"pb, 2019-11-01","category":"page"},{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#Installation-1","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = Simulate","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The current stable, registered version of Simulate.jl is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add Simulate","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The development version is installed with:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/Simulate.jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using Simulate","category":"page"},{"location":"usage/#The-clock-1","page":"Usage","title":"The clock","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Clock","category":"page"},{"location":"usage/#Simulate.Clock","page":"Usage","title":"Simulate.Clock","text":"Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)\n\nCreate a new simulation clock.\n\nArguments\n\nŒît::Number=0: time increment. If no Œît is given, the simulation doesn't tick,   but jumps from event to event. Œît can be set later with sample_time!.\nt0::Number=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. t0=60s.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> init!(c)\nSimulate.Idle()\njulia> c = Clock(1s, unit=minute)\nClock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.016666666666666666\njulia> c = Clock(1s)\nClock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0\njulia> c = Clock(t0=60s)\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> c = Clock(1s, t0=1hr)\nClock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The central clock  is ùê∂. You can set time units and query the current simulation time.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"ùê∂\nsetUnit!\ntau(::Clock)\n@tau(::Clock)","category":"page"},{"location":"usage/#Simulate.ùê∂","page":"Usage","title":"Simulate.ùê∂","text":"ùê∂\nClk\n\nùê∂ (ùê∂ = \\itC+tab) or Clk is the central simulation clock. Since most simulations work with one time, they should use ùê∂ for time keeping.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> ùê∂  # central clock\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> Clk  # alias\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> ùê∂.time\n0.0\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Simulate.setUnit!","page":"Usage","title":"Simulate.setUnit!","text":"setUnit!(sim::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nsim::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60) # setup a new clock with t0=60\nClock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\njulia> tau(c) # current time is 60.0 NoUnits\n60.0\njulia> setUnit!(c, s)  # set clock unit to Unitful.s\n60.0 s\njulia> tau(c) # current time is now 60.0 s\n60.0 s\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\njulia> tau(c) # current time is now 1.0 minute\n1.0 minute\njulia> typeof(tau(c))  # tau(c) now returns a time Quantity ...\nQuantity{Float64,ùêì,Unitful.FreeUnits{(minute,),ùêì,nothing}}\njulia> isa(tau(c), Time)\ntrue\njulia> uconvert(s, tau(c)) # ... which can be converted to other time units\n60.0 s\njulia> tau(c).val  # it has a value of 1.0\n1.0\njulia> c.time  # internal clock time is set to 1.0 (is a Float64)\n1.0\njulia> c.unit  # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.tau-Tuple{Clock}","page":"Usage","title":"Simulate.tau","text":"tau(sim::Clock=ùê∂)\nœÑ(sim::Clock=ùê∂)\n\nReturn the current simulation time (œÑ = \\tau+tab).\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> tau() # gives the central time\n0.0\njulia> œÑ() # alias, gives the central time\n0.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.@tau-Tuple{Clock}","page":"Usage","title":"Simulate.@tau","text":"@tau(sim::Clock)\n@tau sim\n@tau()\n@tau\n\nreturn the current simulation time.\n\nArguments\n\nsim::Clock: if no clock argument is given, it returns ùê∂'s time.\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Events-1","page":"Usage","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Events are scheduled on the clock's timeline and are triggered at a given simulation time or under conditions which may become true during simulation.","category":"page"},{"location":"usage/#Expressions-and-functions-as-events-and-conditions-1","page":"Usage","title":"Expressions and functions as events and conditions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Julia expressions and functions can be scheduled as events.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Timing\nSimFunction\n@SF\nSimExpr","category":"page"},{"location":"usage/#Simulate.Timing","page":"Usage","title":"Simulate.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.SimFunction","page":"Usage","title":"Simulate.SimFunction","text":"SimFunction(func::Function, arg...; kw...)\nSF(func::Function, arg...; kw...)\n\nPrepare a function for being called as an event in a simulation.\n\nArguments\n\nfunc::Function: function to be executed at a later simulation time\narg...: arguments to the function\nkw...: keyword arguments\n\nnote: Note\nBe aware that, if the variables stored in a SimFunction are composite types, they can change until they are evaluated later by func. But that's the nature of simulation.\n\nExample\n\njulia> using Simulate\n\njulia> f(a,b,c; d=4, e=5) = a+b+c+d+e  # define a function\nf (generic function with 1 method)\n\njulia> sf = SimFunction(f, 10, 20, 30, d=14, e=15)  # store it as SimFunction\nSimFunction(f, (10, 20, 30), Base.Iterators.Pairs(:d => 14,:e => 15))\n\njulia> sf.func(sf.arg...; sf.kw...)  # and it can be executed later\n89\n\njulia> d = Dict(:a => 1, :b => 2) # now we set up a dictionary\nDict{Symbol,Int64} with 2 entries:\n  :a => 1\n  :b => 2\n\njulia> f(t) = t[:a] + t[:b] # and a function adding :a and :b\nf (generic function with 2 methods)\n\njulia> f(d)  # our add function gives 3\n3\n\njulia> ff = SimFunction(f, d)   # we set up a SimFunction\nSimFunction(f, (Dict(:a => 1,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> d[:a] = 10  # later somehow we need to change d\n10\n\njulia> ff  # our SimFunction ff has changed too\nSimFunction(f, (Dict(:a => 10,:b => 2),), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\n\njulia> ff.func(ff.arg...; ff.kw...)  # and calling it gives a different result\n12\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.@SF","page":"Usage","title":"Simulate.@SF","text":"@SF(f::Symbol, arg...)\n@SF f arg...\n\ncreate a SimFunction from arguments f, arg...\n\nArguments\n\nf::Symbol: a function given as a symbol, e.g. :f if f() is your function,\narg...: further arguments to your function\n\nnote: Note\nkeyword arguments don't work with this macro, use SF instead.\nif you give @SF as argument(s) to a function, you must enclose it/them  in parentheses ( @SF ... ) or ( (@SF ...), (@SF ...) )\n\nExamples\n\njulia> using Simulate\n\njulia> @SF :sin pi\nSimFunction(sin, (œÄ,), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\njulia> a = 1\n1\njulia> incra() = global a += 1             # create a simple increment function\nincra (generic function with 1 method)\njulia> event!((@SF :incra), after, 3)      # schedule an increment after 3 time units\n3.0\njulia> a\n1\njulia> run!(ùê∂, 5)\n\"run! finished with 1 clock events, 0 sample steps, simulation time: 5.0\"\njulia> a\n2\njulia> event!((@SF :incra), (@tau :>= 8))  # schedule a conditional increment\n5.0\njulia> run!(ùê∂, 5)\n\"run! finished with 0 clock events, 500 sample steps, simulation time: 10.0\"\njulia> a\n3\njulia> event!(((@SF :incra), (@SF :incra)), ((@tau :>= 12), (@val :a :<= 3)))\n10.0\njulia> run!(ùê∂, 5)\n\"run! finished with 0 clock events, 500 sample steps, simulation time: 15.0\"\njulia> a\n5\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.SimExpr","page":"Usage","title":"Simulate.SimExpr","text":"SimExpr = Union{Expr, SimFunction}\n\nA type which is either a SimFunction or any Julia expression Expr.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimFunctions and expressions can be given to events on their own or in arrays or tuples, even mixed:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"function events()\n    event!(:(i += 1), after, 10)  # one expression\n    event!(SF(f, 1, 2, 3, diff=pi), every, 1)  # one SimFunction\n    event!((:(i += 1), SF(g, j)), [:(tau() ‚â• 50), SF(isready, input), :(a ‚â§ 10)]) # two SimExpr under three conditions\nend","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"All given expressions or functions are then evaluated at a given simulation time or when during simulation the given conditions become true.","category":"page"},{"location":"usage/#Timed-events-1","page":"Usage","title":"Timed events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimFunctions and expressions can be scheduled for execution at given clock times.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Number)","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64\nevent!(ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)\n\nSchedule an event for a given simulation time.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to ùê∂,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\nt::Float64 or t::Time: simulation time,\nscope::Module=Main: scope for the expressions to be evaluated\ncycle::Float64=0.0: repeat cycle time for an event\n\nreturns\n\nScheduled internal simulation time (unitless) for that event. May return a time > t from repeated applications of nextfloat(t) if there are events scheduled for t.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\njulia> event!(ùê∂, SimFunction(myfunc, 1, 2), 1) # a 1st event\n1.0\njulia> event!(ùê∂, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time\n1.0000000000000002\njulia> event!(ùê∂, SimFunction(myfunc, 3, 4), 1s)\nWarning: clock has no time unit, ignoring units\n1.0000000000000004\njulia> setUnit!(ùê∂, s)\n0.0 s\njulia> event!(ùê∂, SimFunction(myfunc, 4, 5), 1minute)\n60.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"As a convenience the Timing can be also choosen using at, after or every t.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Timing, ::Number)","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)::Float64\nevent!(ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)\n\nSchedule a timed event, that is an event with a timing.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to ùê∂,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\nT::Timing: a timing, at, after or every (before behaves like at),\nt::Float64 or t::Time: simulation time,\nscope::Module=Main: scope for the expressions to be evaluated\n\nreturns\n\nScheduled internal simulation time (unitless) for that event.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> setUnit!(ùê∂, s)\n0.0 s\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\njulia> event!(ùê∂, SimFunction(myfunc, 5, 6), after, 1hr)\n3600.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#Conditional-events-1","page":"Usage","title":"Conditional events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"They are evaluated at each clock tick (like sampling functions) and are fired when all conditions are met.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Union{SimExpr, Array, Tuple})","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main):\nevent!(ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\n\nSchedule a conditional event.\n\nIt is executed immediately if the conditions are met, else the condition is checked at each clock tick Œît. After a conditional event is triggered, it is removed from the clock. If no sampling rate Œît is setup, a default sampling rate is setup depending on the scale of the remaining simulation time Œît = scale(t_r)100 or 001 if t_r = 0.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to ùê∂,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\ncond::{SimExpr, Array, Tuple}: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.\nscope::Module=Main: scope for the expressions to be evaluated\ncycle::Float64=0.0: repeat cycle time for an event\n\nreturns\n\ncurrent simulation time tau(sim).\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"note: Note\nSince conditions often are not met exactly you should prefer inequalities like <, ‚â§, ‚â•, > to equality == in order to get sure that a fulfilled condition can be detected, e.g. (tau()  100) is preferable to (tau() == 100).","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"There are some helper functions and macros for defining conditions. It is usually more convenient to use the macros since the generate the necessary SimFunctions directly:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"tau(::Clock, ::Symbol, ::Union{Number,Symbol})\n@tau(::Any, ::Symbol, ::Union{Number, QuoteNode})\nval\n@val","category":"page"},{"location":"usage/#Simulate.tau-Tuple{Clock,Symbol,Union{Number, Symbol}}","page":"Usage","title":"Simulate.tau","text":"tau(sim::Clock, check::Symbol, x::Union{Number,Symbol}; m::Module=Main)\ntau(check::Symbol, x::Union{Number,Symbol}; m::Module=Main)\n\nCompare the current simulation time against a number or a variable.\n\nArguments\n\nsim::Clock: clock variable, if not given, it is ùê∂.\ncheck::Symbol: a comparison operator as a symbol like :>,\nx::Union{Number,Symbol}: a number or a symbolic variable like :a,\nm::Module=Main: the evaluation scope, if a symbolic variable is given.\n\nExamples\n\njulia> using Simulate\n\njulia> tau(:>=, 1)\nfalse\njulia> tau(:<, 1)\ntrue\njulia> a = 1\n1\njulia> tau(:<=, :a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.@tau-Tuple{Any,Symbol,Union{Number, QuoteNode}}","page":"Usage","title":"Simulate.@tau","text":"@tau(sim::Clock, check::Symbol, val)\n@tau sim check val\n@tau(check::Symbol, val)\n@tau check val\n\ncreate a SimFunction comparing current simulation time with a given value or variable.\n\nArguments\n\nsim::Clock: if no clock is given, it compares with ùê∂'s time,\ncheck::Symbol: the check operator must be given as a symbol e.g. :<,\nval::Union{Number, QuoteNode}: a value or a symbolic variable,\n\nnote: Note\nIf you give @tau as argument(s) to a function, you must enclose it/them in parentheses ( @tau ... ) or ( (@tau ...), (@tau ...) )!\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> s = @tau :‚â• 100\nSimFunction(Simulate.tau, (:‚â•, 100, Main), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\njulia> Simulate.simExec(s)\nfalse\njulia> Simulate.simExec(@tau < 100)                ### wrong !!\nERROR: syntax: \"<\" is not a unary operator\njulia> Simulate.simExec(@tau :< 100)               ### correct\ntrue\njulia> a = 1\n1\njulia> Simulate.simExec(@tau :< :a)\ntrue\njulia> event!(SF(()->global a+=1), (@tau :>= 3))   ### create a conditional event\n0.0\njulia> a\n1\njulia> run!(ùê∂, 5)                                  ### run\n\"run! finished with 0 clock events, 500 sample steps, simulation time: 5.0\"\njulia> a\n2\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.val","page":"Usage","title":"Simulate.val","text":"val(a::Union{Number, Symbol}, check::Symbol, x::Union{Number, Symbol}, m::Module=Main)\n\nCompare two variables or numbers.\n\nExamples\n\njulia> using Simulate\n\njulia> m = @__MODULE__;  # necessary for doctest\n\njulia> val(1, :<=, 2)\ntrue\njulia> a = 1\n1\njulia> val(:a, :<=, 2, m)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.@val","page":"Usage","title":"Simulate.@val","text":"@val(a, check::QuoteNode, x)\n@val a check b\n\nCreate a Simfunction comparing two values a and b or two symbolic variables :a and :b. The comparison operator must be given symbolically, e.g. :‚â§.\n\nArguments\n\n`a, b::: a number, expression or symbol\ncheck::QuoteNode: a comparison operator as a symbol like :‚â§\n, m::Module=Main: a module scope for evaluation of given symbolic variables\n\nnote: Note\nIf you give @val as argument(s) to a function, you must enclose it/them in parentheses ( @val ... ) or e.g. ( (@tau ...), (@val ...) )!\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(ùê∂)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> @val 1 :‚â§ 2\nSimFunction(Simulate.val, (1, :‚â§, 2, Main), Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}())\njulia> Simulate.simExec(@val 1 :‚â§ 2)\ntrue\njulia> a = 1\n1\njulia> Simulate.simExec(@val :a :‚â§ 2)\ntrue\njulia> event!(SF(()->global a+=1), ((@tau :>= 3), (@val :a :<= 3))) ### a conditional event\n0.0\njulia> run!(ùê∂, 5)\n\"run! finished with 0 clock events, 500 sample steps, simulation time: 5.0\"\njulia> a\n2\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Processes-1","page":"Usage","title":"Processes","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Julia functions can be registered and run as processes if they have an input and an output channel as their first two arguments. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimProcess\n@SP\nSimException\nprocess!\ninterrupt!\nstop!(::SimProcess, ::SEvent)","category":"page"},{"location":"usage/#Simulate.SimProcess","page":"Usage","title":"Simulate.SimProcess","text":"SimProcess( id, func::Function, arg...; kw...)\nSP(id, func::Function, arg...; kw...)\n\nPrepare a function to run as a process in a simulation.\n\nArguments\n\nid: some unique identification, it should get registered with\nfunc::Function: a function f(arg...; kw...)\narg...: further arguments to f\nkw...: keyword arguments to f\n\nnote: Note\nA function as a SimProcess most often runs in a loop. It has to give back control by e.g. doing a take!(input) or by calling delay! etc., which will yield it. Otherwise it will starve everything else!\n\nExamples\n\njulia> using Simulate\n\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.@SP","page":"Usage","title":"Simulate.@SP","text":"@SP(id, f::Symbol, input::Channel, output::Channel, arg...)\n@SP id f input output arg...\n\ncreate a SimProcess from arguments f, arg...\n\nnote: Note\nkeyword arguments don't work with this macro, use SP instead.\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.SimException","page":"Usage","title":"Simulate.SimException","text":"SimException(ev::SEvent, value=nothing)\n\nDefine a SimException, which can be thrown to processes.\n\nParameters\n\nev::SEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.process!","page":"Usage","title":"Simulate.process!","text":"process!(sim::Clock, p::SimProcess, cycles=Inf)\nprocess!(p::SimProcess, cycles=Inf)\n\nRegister a SimProcess to a clock, start it as an asynchronous process and return the id it was registered with. It can then be found under sim.processes[id].\n\nArguments\n\nsim::Clock: clock, if no clock is given, it runs under ùê∂,\np::SimProcess\ncycles::Number=Inf: number of cycles, the process should run.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.interrupt!","page":"Usage","title":"Simulate.interrupt!","text":"interrupt!(p::SimProcess, ev::SEvent, value=nothing)\n\nInterrupt a SimProcess by throwing a SimException to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}","page":"Usage","title":"Simulate.stop!","text":"Stop a SimProcess\n\n\n\n\n\n","category":"method"},{"location":"usage/#Delay-and-wait-‚Ä¶-1","page":"Usage","title":"Delay and wait ‚Ä¶","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Processes must not handle their events explicitly, but can call delay! or wait! or take! and put! ‚Ä¶ on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"delay!\nwait!","category":"page"},{"location":"usage/#Simulate.delay!","page":"Usage","title":"Simulate.delay!","text":"delay!(sim::Clock, t::Number)\ndelay!(t::Number)\n\nDelay a process for a time interval t on the clock sim. Suspend the calling process until being reactivated by the clock at the appropriate time.\n\nArguments\n\nsim::Clock: clock, if no clock is given, the delay goes to ùê∂.\nt::Number: the time interval for the delay.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.wait!","page":"Usage","title":"Simulate.wait!","text":"wait!(sim::Clock, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\nwait!(cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\n\nWait on a clock for a condition to become true. Suspend the calling process until the given condition is true.\n\nArguments\n\nsim::Clock: clock, if no clock is given, the delay goes to ùê∂.\ncond::Union{SimExpr, Array, Tuple}: a condition is an expression or SimFunction   or an array or tuple of them. It is true if all expressions or SimFunctions   therein return true.\nscope::Module=Main: evaluation scope for given expressions\n\n\n\n\n\n","category":"function"},{"location":"usage/#Now-1","page":"Usage","title":"Now","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"If processes want IO-operations to finish before letting the clock proceed, they can enclose those operations in a now! call.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"now!","category":"page"},{"location":"usage/#Simulate.now!","page":"Usage","title":"Simulate.now!","text":"now!(sim::Clock, ex::Union{SimExpr, Array, Tuple})\nnow!(ex::Union{SimExpr, Array, Tuple})\n\nLock the clock, execute the given expression, then unlock the clock again.\n\nArguments\n\nsim::Clock:\nex::Union{SimExpr, Array, Tuple}:\n\n\n\n\n\n","category":"function"},{"location":"usage/#Continuous-sampling-1","page":"Usage","title":"Continuous sampling","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Functions or expressions can register for sampling and are then executed \"continuously\" at each clock increment Œît.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sample_time!\nsample!","category":"page"},{"location":"usage/#Simulate.sample_time!","page":"Usage","title":"Simulate.sample_time!","text":"sample_time!(sim::Clock, Œît::Number)\nsample_time!(Œît::Number)\n\nset the clock's sample rate starting from now (tau(sim)).\n\nArguments\n\nsim::Clock: if no clock is given, set the sample rate on ùê∂,\nŒît::Number: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sample!","page":"Usage","title":"Simulate.sample!","text":"sample!(sim::Clock, ex::Union{Expr, SimFunction}; scope::Module=Main)\nsample!(ex::Union{Expr, SimFunction}; scope::Module=Main)\n\nenqueue an expression for sampling.\n\nArguments\n\nsim::Clock: if no clock is given, it samples on ùê∂,\nex::Union{Expr, SimFunction}: an expression or function,\nŒît::Number=sim.Œît: set the clock's sampling rate, if no Œît is given, it takes   the current sampling rate, if that is 0, it calculates one,\nscope::Module=Main: optional, an evaluation scope for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Running-simulations-1","page":"Usage","title":"Running simulations","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed ‚Ä¶ Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"reset!\nincr!\nrun!\nstop!(::Clock)\nresume!\nsync!","category":"page"},{"location":"usage/#Simulate.reset!","page":"Usage","title":"Simulate.reset!","text":"reset!(sim::Clock, Œît::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)\n\nreset a clock\n\nArguments\n\nsim::Clock\nŒît::Number=0: time increment\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Œît::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0\njulia> reset!(c)\n\"clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.\"\njulia> c\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.incr!","page":"Usage","title":"Simulate.incr!","text":"incr!(sim::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.run!","page":"Usage","title":"Simulate.run!","text":"run!(sim::Clock, duration::Number)\n\nRun a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{Clock}","page":"Usage","title":"Simulate.stop!","text":"stop!(sim::Clock)\n\nStop a running simulation.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.resume!","page":"Usage","title":"Simulate.resume!","text":"resume!(sim::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sync!","page":"Usage","title":"Simulate.sync!","text":"sync!(sim::Clock, to::Clock=ùê∂)\n\nForce a synchronization of two clocks. Change all registered times of sim accordingly. Convert or force sim.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Logging-1","page":"Usage","title":"Logging","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A Logger allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger's state it can be printed or stored in a table.","category":"page"},{"location":"usage/#Example-1","page":"Usage","title":"Example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sim = Clock(); # create a clock\nl = Logger(); # create a logging variable\ninit!(l, sim); # initialize the logger\n(a, b, c) = 1, 1, 1 # create some variables\nsetup!(l, [:a, :b, :c], scope = m); # register them for logging\nrecord!(l) # record the variables with the current clock time\nl.last # show the last record\nfunction f()  # a function for increasing and recording the variables\n  global a += 1\n  global b = a^2\n  global c = a^3\n  record!(l)\nend\nswitch!(l, 1); # switch logger to printing\nf() # increase and record the variables\nswitch!(l, 2); # switch logger to storing in data table\nfor i in 1:10 # create some events\n    event!(sim, :(f()), i, scope = m)\nend\nrun!(sim, 10) # run a simulation\nl.df # view the recorded values","category":"page"},{"location":"usage/#Types-1","page":"Usage","title":"Types","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Logger","category":"page"},{"location":"usage/#Simulate.Logger","page":"Usage","title":"Simulate.Logger","text":"Logger()\n\nSetup and return a logging variable.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Functions-1","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"init!\nsetup!\nswitch!\nrecord!\nclear!","category":"page"},{"location":"usage/#Simulate.init!","page":"Usage","title":"Simulate.init!","text":"init!(sim::Clock)\n\ninitialize a clock.\n\n\n\n\n\ninit!(L::Logger, sim::Clock)\n\nInitialize a Logger.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.setup!","page":"Usage","title":"Simulate.setup!","text":"setup!(L::Logger, vars::Array{Symbol})\n\nSetup a logger with logging variables.\n\nArguments\n\nL::Logger\nvars::Array{Symbol}: An array of symbols, e.g. of global variables\nscope::Module = Main: Scope in which to evaluate the variables\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.switch!","page":"Usage","title":"Simulate.switch!","text":"switch!(L::Logger, to::Number=0)\n\nSwitch the operating mode of a logger.\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.record!","page":"Usage","title":"Simulate.record!","text":"record!(L::Logger)\n\nrecord the logging variables with the current operating mode.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.clear!","page":"Usage","title":"Simulate.clear!","text":"clear!(L::Logger)\n\nclear the loggers last record and data table.\n\n\n\n\n\n","category":"function"},{"location":"approach/#Approaches-to-modeling-and-simulation-1","page":"Modeling approaches","title":"Approaches to modeling and simulation","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Simulate.jl supports different approaches to modeling and simulation of discrete event systems (DES). It provides three major schemes:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"an event-scheduling scheme,\na process-oriented scheme and\ncontinuous sampling.","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"With them different modeling strategies can be applied. We look at how a simple problem can be expressed differently through various modeling approaches:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Simple problem:<br> A server takes something from an input, processes it for some time and puts it out to an output. We have 8 servers in our system, 4 foos and 4 bars, which communicate with each other via two channels.","category":"page"},{"location":"approach/#Event-based-modeling-1","page":"Modeling approaches","title":"Event based modeling","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"In this view events occur in time and trigger further events. Here the three server actions are seen as events and can be described in an event graph:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"(Image: event graph)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"We define a data structure for the server, provide functions for the three actions, create channels and servers and start:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\nfunction take(S::Server)\n    if isready(S.input)\n        S.token = take!(S.input)\n        @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n        event!(SF(put, S), after, rand())         # call put after some time\n    else\n        event!(SF(take, S), SF(isready, S.input)) # call again if input is ready\n    end\nend\n\nfunction put(S::Server)\n    put!(S.output, S.op(S.id, S.token))\n    S.token = nothing\n    take(S)\nend\n\nreset!(ùê∂)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    take(Server(s[i], \"foo\", ch1, ch2, +))\n    take(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"julia> include(\"docs/examples/channels1.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n 2.55: foo 7 took token 750\n 3.02: bar 5 took token 757\n 3.30: foo 4 took token 3785\n 3.75: bar 6 took token 3789\n 4.34: foo 1 took token 22734\n 4.60: bar 8 took token 22735\n 5.31: foo 2 took token 181880\n 5.61: bar 3 took token 181882\n 5.90: foo 7 took token 545646\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#State-based-modeling-1","page":"Modeling approaches","title":"State based modeling","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Here our server has three states: Idle, Busy and End (where End does nothing). On an arrival event it resets its internal clock x=0 and determines the service time t_s, moves to Busy, works on its input and puts it out when service time is over. Then it goes back to Idle. A state transition diagram (Mealy model) of the timed automaton would look like:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"(Image: timed automaton)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Again we have a data structure for the server (containing a state). We define states and events and implement a Œ¥ transition function with two methods. Thereby we dispatch on states and events. Since we don't implement all combinations of states and events, we may implement a fallback transition.","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"using Simulate, Printf, Random\n\nabstract type Q end  # states\nstruct Idle <: Q end\nstruct Busy <: Q end\nabstract type Œ£ end  # events\nstruct Arrive <: Œ£ end\nstruct Leave <: Œ£ end\n\nmutable struct Server\n    id::Int64\n    name::AbstractString\n    input::Channel\n    output::Channel\n    op     # operation to take\n    state::Q\n    token  # current token\n\n    Server(id, name, input, output, op) = new(id, name, input, output, op, Idle(), nothing)\nend\n\narrive(A) = event!(SF(Œ¥, A, A.state, Arrive()), SF(isready, A.input))\n\nfunction Œ¥(A::Server, ::Idle, ::Arrive)\n    A.token = take!(A.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), A.name, A.id, A.token)\n    A.state=Busy()\n    event!(SF(Œ¥, A, A.state, Leave()), after, rand())\nend\n\nfunction Œ¥(A::Server, ::Busy, ::Leave)\n    put!(A.output, A.op(A.id,A.token))\n    A.state=Idle()\n    arrive(A)\nend\n\nŒ¥(A::Server, q::Q, œÉ::Œ£) =               # fallback transition\n        println(stderr, \"$(A.name) $(A.id) undefined transition $q, $œÉ\")\n\nreset!(ùê∂)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"julia> include(\"docs/examples/channels2.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n 2.55: foo 7 took token 750\n 3.02: bar 5 took token 757\n 3.30: foo 4 took token 3785\n 3.75: bar 6 took token 3789\n 4.34: foo 1 took token 22734\n 4.60: bar 8 took token 22735\n 5.31: foo 2 took token 181880\n 5.61: bar 3 took token 181882\n 5.90: foo 7 took token 545646\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#Activity-based-modeling-1","page":"Modeling approaches","title":"Activity based modeling","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Our server's activity is the processing of the token. A timed Petri net would look like:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"(Image: timed petri net)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"The arrive transition puts a token in the Queue. If both places Idle and Queue have tokens, the server takes them, shifts one to Busy and puts out two after a timed transition with delay v_put. Then it is Idle again and the cycle restarts.","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"The server's activity is described by the blue box. Following the Petri net, we should implement a state variable with states Idle and Busy, but we don't need to if we separate the activities in time. We need a data structure for the server and define a function for the activity:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\narrive(S::Server) = event!(SF(serve, S), SF(isready, S.input))\n\nfunction serve(S::Server)\n    S.token = take!(S.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n    event!((SF(put!, S.output, S.op(S.id, S.token)), SF(arrive, S)), after, rand())\nend\n\nreset!(ùê∂)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"When running, this gives us as output:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"julia> include(\"docs/examples/channels3.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n 2.55: foo 7 took token 750\n 3.02: bar 5 took token 757\n 3.30: foo 4 took token 3785\n 3.75: bar 6 took token 3789\n 4.34: foo 1 took token 22734\n 4.60: bar 8 took token 22735\n 5.31: foo 2 took token 181880\n 5.61: bar 3 took token 181882\n 5.90: foo 7 took token 545646\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#Process-based-modeling-1","page":"Modeling approaches","title":"Process based modeling","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Here we combine it all in a simple function of take!-delay!-put! like in the activity based example, but running in a loop of a process. Processes can wait or delay and are suspended and reactivated by Julia's scheduler according to background events. There is no need to handle events explicitly and no need for a server type since a process keeps its own data. But processes must look to their timing and therefore they must enclose the IO-operation in a now! call:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"reset!(ùê∂)\n\nfunction simple(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something, eventually wait for it\n    now!(SF(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(), name, id, token)))\n    d = delay!(rand())           # wait for a given time\n    put!(output, op(token, id))  # put something else out, eventually wait\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 SimProcesses\n    process!(ùê∂, SimProcess(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(ùê∂, SimProcess(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(ùê∂, 10)","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"and runs like:","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"julia> include(\"docs/examples/channels4.jl\")\n 0.00: foo 7 took token 1\n 0.77: bar 4 took token 8\n 1.71: foo 3 took token 32\n 2.38: bar 2 took token 35\n 2.78: foo 5 took token 70\n 3.09: bar 8 took token 75\n 3.75: foo 1 took token 600\n 4.34: bar 6 took token 601\n 4.39: foo 7 took token 3606\n 4.66: bar 4 took token 3613\n 4.77: foo 3 took token 14452\n 4.93: bar 2 took token 14455\n 5.41: foo 5 took token 28910\n 6.27: bar 8 took token 28915\n 6.89: foo 1 took token 231320\n 7.18: bar 6 took token 231321\n 7.64: foo 7 took token 1387926\n 7.91: bar 4 took token 1387933\n 8.36: foo 3 took token 5551732\n 8.94: bar 2 took token 5551735\n 9.20: foo 5 took token 11103470\n 9.91: bar 8 took token 11103475\n\"run! finished with 21 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#Comparison-1","page":"Modeling approaches","title":"Comparison","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"The output of the last example is different from the first three approaches because we did not need to shuffle and the shuffling of the processes is done by the scheduler. So if the output depends very much on the sequence of events and you need to have reproducible results, explicitly controlling for the events like in the first three examples is preferable. If you are more interested in statistical evaluation - which is often the case -, the 4th approach is also appropriate.","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"All four approaches can be expressed in Simulate.jl. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured and controllable , which comes in handy for more complicated examples. After all, parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.","category":"page"},{"location":"approach/#Combined-approach-1","page":"Modeling approaches","title":"Combined approach","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"Physical systems can be modeled as continuous systems (nature does not jump), discrete systems (nature jumps here!) or hybrid systems (nature jumps sometimes).","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"While continuous systems are the domain of differential equations, discrete and hybrid systems may be modeled easier with Simulate.jl by combining the event-scheduling, the process-based and the continuous-sampling schemes.","category":"page"},{"location":"approach/#A-hybrid-system-1","page":"Modeling approaches","title":"A hybrid system","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"(empty)","category":"page"},{"location":"approach/#Theories-1","page":"Modeling approaches","title":"Theories","text":"","category":"section"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"There are some theories about the different approaches (1) event based, (2) state based, (3) activity based and (4) process based. Choi and Kang [1] have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune [2] call those \"the event scheduling scheme\" and the 4th approach \"the process-oriented simulation scheme\" [3]. There are communities behind the various views and Simulate.jl wants to be useful for them all.","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"[1]: Choi and Kang: Modeling and Simulation of Discrete-Event Systems, Wiley, 2013","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"[2]: Cassandras and Lafortune: Introduction to Discrete Event Systems, Springer, 2008, Ch. 10","category":"page"},{"location":"approach/#","page":"Modeling approaches","title":"Modeling approaches","text":"[3]: to be fair, the 4th approach is called by Choi and Kang \"parallel simulation\".","category":"page"},{"location":"examples/greeting/#Two-guys-meet-1","page":"Two guys meet","title":"Two guys meet","text":"","category":"section"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If two guys meet, there is standard verbiage, but some uncertainty in how long they need to greet and respond. We can simulate this as an introductory example.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We call the needed modules and define some types and data:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"using Simulate, Printf\n\nstruct Guy\n    name\nend\n\nabstract type Encounter end\nstruct Meet <: Encounter\n    someone\nend\nstruct Greet <: Encounter\n    num\n    from\nend\nstruct Response <: Encounter\n    num\n    from\nend\n\ncomm = (\"Nice to meet you!\", \"How are you?\", \"Have a nice day!\", \"bye bye\")","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We implement the behavior of the \"guys\" as step!-Œ¥-functions of a state machine. For that we use some features of Sim.jl:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"ùê∂ or Clk is the central clock,\nSimFunction prepares a Julia function for later execution,\nevent! schedules it for execution after some time,\ntau() gives the central time (Clk.time).","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"say(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", tau(), name, comm[n])\n\nfunction step!(me::Guy, œÉ::Meet)\n    event!(ùê∂, SimFunction(step!, œÉ.someone, Greet(1, me)), after, 2*rand())\n    say(me.name, 1)\nend\n\nfunction step!(me::Guy, œÉ::Greet)\n    if œÉ.num < 3\n        event!(ùê∂, SimFunction(step!, œÉ.from, Response(œÉ.num, me)), after, 2*rand())\n        say(me.name, œÉ.num)\n    else\n        say(me.name, 4)\n    end\nend\n\nfunction step!(me::Guy, œÉ::Response)\n    event!(ùê∂, SimFunction(step!, œÉ.from, Greet(œÉ.num+1, me)), after, 2*rand())\n    say(me.name, œÉ.num+1)\nend","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we define some \"guys\" and a starting event and tell the clock ùê∂ to run for twenty \"seconds\":","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"foo = Guy(\"Foo\")\nbar = Guy(\"Bar\")\n\nevent!(ùê∂, SimFunction(step!, foo, Meet(bar)), at, 10*rand())\nrun!(ùê∂, 20)","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If we source this code, it will run a simulation:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> include(\"docs/examples/greeting.jl\")\n 7.30 s, Foo: Nice to meet you!\n 8.00 s, Bar: Nice to meet you!\n 9.15 s, Foo: How are you?\n10.31 s, Bar: How are you?\n11.55 s, Foo: Have a nice day!\n12.79 s, Bar: bye bye\nFinished: 6 events, simulation time: 20.0","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we reset the clock ùê∂ for further simulations.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> reset!(ùê∂)\nclock reset to t‚ÇÄ=0, sampling rate Œît=0.","category":"page"},{"location":"examples/tabletennis/#Table-tennis-1","page":"Table tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We can model the players as state machines and do a simulation on it.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"using Simulate, Printf\nimport Simulate.init!","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Some functions describe the setup of players, serve and return. Here we use the following features of Sim.jl:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"italic ùê∂ (\\itC+Tab) or Clk is the central clock,\ntau() or œÑ() gives the central time,\nevent! schedules an expression (or a function) for execution after some time on ùê∂s timeline.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ‚â§ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if (rand() ‚â§ p.accuracy) && (p.state == Wait())\n        event!(ùê∂, :(step!($(p.opp), Serve())), after, ts)\n        @printf(\"%.2f: %s serves %s\\n\", œÑ()+ts, p.name, p.opp.name)\n    else\n        event!(ùê∂, :(step!($(p.opp), Miss())), after, ts)\n        @printf(\"%.2f: %s serves and misses %s\\n\", tau()+ts, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ‚â§ p.accuracy\n        event!(ùê∂, :(step!($(p.opp), Return())), after, tr)\n        @printf(\"%.2f: %s returns %s\\n\", tau()+tr, p.name, p.opp.name)\n    else\n        event!(ùê∂, :(step!($(p.opp), Miss())), after, tr)\n        @printf(\"%.2f: %s returns and misses %s\\n\", tau()+tr, p.name, p.opp.name)\n    end\n    if rand() ‚â• p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Note: In this case of scheduling an expression we need to interpolate p.opp with $(p.opp) to ensure that our step!-function gets the right player. Instead of scheduling expressions we normally would have scheduled our functions with SimFunction(step!, p.opp, Serve()), which eliminates the need for interpolation.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"The behavior of a player is described by the following step!-Œ¥ transition functions with Œ¥(p, q·µ¶, œÉ) ‚Üí q·µß leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, œÉ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $œÉ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Union{Wait, Unalert}, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%.2f: %s looses ball\\n\", tau(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, œÉ::PEvent) = step!(p, p.state, œÉ)","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Next we define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"run!(ùê∂, 30)\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nFinished: 22 events, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we should reset the clock for following simulations:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> reset!(ùê∂)\nclock reset to t‚ÇÄ=0, sampling rate Œît=0.","category":"page"},{"location":"#Simulate.jl-1","page":"Home","title":"Simulate.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl supports different approaches to modeling and simulation of discrete event systems (DES). It provides three major schemes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"event-scheduling scheme,\nprocess-oriented scheme and\ncontinuous sampling.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With them different modeling strategies can be applied.","category":"page"},{"location":"#A-first-example-1","page":"Home","title":"A first example","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A server takes something from its input and puts it out modified after some time. We implement that in a function, create input and output channels and some \"foo\" and \"bar\" processes operating reciprocally on the channels:  ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Simulate, Printf\nreset!(ùê∂) # reset the central clock\n\n# describe the activity of the server\nfunction serve(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something from the input\n    now!(SF(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(), name, id, token)))\n    delay!(rand())               # after a delay\n    put!(output, op(token, id))  # put it out with some op applied\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create, register and start 8 SimProcesses (alias SP)\n    process!(SP(i, serve, ch1, ch2, \"foo\", i, +))\n    process!(SP(i+1, serve, ch2, ch1, \"bar\", i+1, *))\nend\n\nput!(ch1, 1)  # put first token into channel 1\n\nrun!(ùê∂, 10)   # and run for 10 time units","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If we source this program, it runs a simulation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> include(\"docs/examples/channels.jl\")\n 0.00: foo 7 took token 1\n 0.25: bar 4 took token 8\n 0.29: foo 3 took token 32\n 0.55: bar 2 took token 35\n 1.21: foo 5 took token 70\n 1.33: bar 8 took token 75\n...\n...\n 8.90: foo 3 took token 5551732\n 9.10: bar 2 took token 5551735\n 9.71: foo 5 took token 11103470\n 9.97: bar 8 took token 11103475\n10.09: foo 1 took token 88827800\n\"run! finished with 22 clock events, simulation time: 10.0\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"#Changes-in-v0.2.0-(development)-1","page":"Home","title":"Changes in v0.2.0 (development)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"now! for encapsulating IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!(cond),\nconditional events with event!(sim, ex, cond),\neverything can be called without the first clock argument, it then goes to ùê∂,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!\nextensive documentation,\nmore examples,","category":"page"}]
}
