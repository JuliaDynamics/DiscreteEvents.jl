var documenterSearchIndex = {"docs":
[{"location":"history/#Version-history-1","page":"Release notes","title":"Version history","text":"","category":"section"},{"location":"history/#v0.2.0-1","page":"Release notes","title":"v0.2.0","text":"","category":"section"},{"location":"history/#","page":"Release notes","title":"Release notes","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!(cond),\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to 𝐶,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"history/#v0.1.0-1","page":"Release notes","title":"v0.1.0","text":"","category":"section"},{"location":"history/#","page":"Release notes","title":"Release notes","text":"first registration 2019-11-04\nevent-/activity-/state-based simulation with SimFunction and event! based on Julia functions and expressions,\nintroduced a central clock variable 𝐶,\nClock state machine with init!, run!, incr!, stop!, resume!,\nLogger and logging functions,\nfirst documentation,\nfirst examples,\nCI and development setup.","category":"page"},{"location":"examples/examples/#Overview-1","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/examples/#","page":"Overview","title":"Overview","text":"The examples are intended to show how Simulate.jl can be used and how different approaches to modeling and simulation can be employed and combined with it.","category":"page"},{"location":"examples/examples/#","page":"Overview","title":"Overview","text":"Two guys meet: an introductory example,\nTable tennis: a state-based simulation,\nSingle server: an activity-based simulation of a single server,\nPost office: a process-based simulation of a post-office,\nGoldratt's dice game: a simulation of assembly lines, illustrating what can be done with multiple simulations and parameter variation on parallel threads,\nHouse heating: a simulation of a hybrid system, combining all three schemes: events, continuous sampling and processes.","category":"page"},{"location":"examples/examples/#Working-with-the-examples-1","page":"Overview","title":"Working with the examples","text":"","category":"section"},{"location":"examples/examples/#","page":"Overview","title":"Overview","text":"If you would like to play with the examples:","category":"page"},{"location":"examples/examples/#","page":"Overview","title":"Overview","text":"Jupyter notebooks are here in the repo\nJulia programs/.jl-files are here in the repo.","category":"page"},{"location":"intro/#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Get an overview and learn the basics.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides a clock with a virtual simulation time and the ability to schedule Julia functions and expressions as events on the clock's timeline or run them as processes synchronizing with the clock. The clock can invoke registered functions or expressions continuously with a given sample rate.","category":"page"},{"location":"intro/#A-first-example-1","page":"Getting started","title":"A first example","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"A server takes something from its input and puts it out modified after some time. We implement the server's activity in a function, create input and output channels and some \"foo\" and \"bar\" processes interacting on them:  ","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"using Simulate, Printf, Random\nreset!(𝐶) # reset the central clock\n\n# describe the activity of the server\nfunction serve(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something from the input\n    now!(SF(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(), name, id, token)))\n    delay!(rand())               # after a delay\n    put!(output, op(token, id))  # put it out with some op applied\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create, register and start 8 SimProcesses (alias SP)\n    process!(SP(i, serve, ch1, ch2, \"foo\", i, +))\n    process!(SP(i+1, serve, ch2, ch1, \"bar\", i+1, *))\nend\n\nput!(ch1, 1)  # put first token into channel 1","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)   # run for 10 time units\n 0.00: foo 7 took token 1\n 0.25: bar 4 took token 8\n 0.29: foo 3 took token 32\n 0.55: bar 2 took token 35\n 1.21: foo 5 took token 70\n 1.33: bar 8 took token 75\n...\n...\n 8.90: foo 3 took token 5551732\n 9.10: bar 2 took token 5551735\n 9.71: foo 5 took token 11103470\n 9.97: bar 8 took token 11103475\n10.09: foo 1 took token 88827800\n\"run! finished with 22 clock events, simulation time: 10.0\"","category":"page"},{"location":"intro/#Types-and-functions-1","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"𝐶, reset!, now!, delay!, process!, SP, run!","category":"page"},{"location":"intro/#Four-building-blocks-1","page":"Getting started","title":"Four building blocks","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Simulate.jl provides 4 major building blocks for modeling and simulation of discrete event systems:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"the clock gives a virtual simulation time,\nevents are Julia expressions or functions executing at given times or under given conditions,\nprocesses are functions running as tasks and synchronizing with the clock by delaying for a time or waiting for conditions,\ncontinuous sampling is done by invoking given expressions or functions at a given rate on the time line.","category":"page"},{"location":"intro/#the_clock-1","page":"Getting started","title":"The clock","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"The clock is central to any model and simulation, since it establishes the timeline. It does not only provide the time, but contains also the time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Δt. Each simulation can have its own clock.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> c = Clock()                           ### create a new clock\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> tick() = println(tau(c), \": tick!\")   ### define a function printing the clock's time\ntick (generic function with 1 method)\n\njulia> event!(c, SF(tick), every, 1)         ### schedule a repeat event on the clock\n0.0\n\njulia> run!(c, 10)                           ### run the clock for 10 time units\n0.0: tick!\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 11 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If you work with only one simulation at a time, you normally use the central clock 𝐶 (\\it𝐶+tab), alias Clk:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nYou definitely need different clock variables if you run multiple simulations on parallel threads. In such cases each simulation should have its own clock. Please look at the dicegame example for that.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> tick() = println(tau(), \": tick!\")         ### the tick function now uses central time tau()\ntick (generic function with 1 method)\n\njulia> sample_time!(1)                            ### set the sampling rate on the central clock to 1\n1.0\n\njulia> sample!( SF(tick) );                       ### set tick as a sampling function\n\njulia> 𝐶                                          ### 𝐶 now has one sampling entry and the sample rate set\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 1, sample rate Δt=1.0\n\njulia> run!(𝐶, 5)                                 ### run 𝐶 for 5 time units\n1.0: tick!\n2.0: tick!\n3.0: tick!\n4.0: tick!\n5.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 5.0\"\n\njulia> run!(𝐶, 5)                                 ### run it again\n6.0: tick!\n7.0: tick!\n8.0: tick!\n9.0: tick!\n10.0: tick!\n\"run! finished with 0 clock events, 5 sample steps, simulation time: 10.0\"\n\njulia> reset!(𝐶)                                  ### reset the clock\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If Δt = 0, the clock doesn't tick with a fixed interval, but jumps from event to event.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nClocks work with a Float64 time and with Unitful.NoUnits but you can set them to work with Unitful.Time units like ms, s, minute, hr. In this case tau returns a time, e.g. 1 s. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.setUnit!(sim::Clock, unit::FreeUnits): set a clock unit.\ntau(sim::Clock).val: return a unitless number for current time.At the moment I don't find it practical to work with units if for example I collect simulation events or variables with their time in a table or do plots. It seems easier not to use them as long you don't need automatic time conversion in your simulation projects.","category":"page"},{"location":"intro/#Types-and-functions-2","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Clock, 𝐶, tau, sample_time!, sample!, run!, reset!, incr!, sync!, stop!, resume!,  ","category":"page"},{"location":"intro/#event_scheme-1","page":"Getting started","title":"Events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Julia functions or expressions are scheduled as events on the clock's time line. In order to not be invoked immediately,","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"expressions must be quoted with :() and\nfunctions must be enclosed inside a SimFunction, alias SF","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Quoted expressions and SimFunctions can be given to events mixed in a tuple or array.","category":"page"},{"location":"intro/#Timed-events-1","page":"Getting started","title":"Timed events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Timed events with event! schedule functions and expressions to execute at a given time:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"ev1 = :(println(tau(), \": I'm a quoted expression\"))\nev2 = SF(() -> println(tau(), \": I'm a SimFunction\"))\n\nevent!(ev1, at, 2)                             ### schedule an event at 2\nevent!(ev1, after, 8)                          ### schedule an event after 8\nevent!(ev2, every, 5)                          ### schedule an event every 5","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                             ### run\n0.0: I'm a SimFunction\n2.0: I'm a quoted expression\n5.0: I'm a SimFunction\n8.0: I'm a quoted expression\n10.0: I'm a SimFunction\n\"run! finished with 5 clock events, 0 sample steps, simulation time: 10.0\"\n\njulia> event!((ev1, ev2), after, 2)            ### schedule both ev1 and ev2 as event\n12.0\n\njulia> run!(𝐶, 5)                              ### run\n12.0: I'm a quoted expression\n12.0: I'm a SimFunction\n15.0: I'm a SimFunction\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 15.0\"","category":"page"},{"location":"intro/#Conditional-events-1","page":"Getting started","title":"Conditional events","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Conditional events  with (event!) execute under given conditions. Conditions can be formulated by using the @tau macro questioning the simulation time, the @val macro questioning a variable or any other logical expression or function or combinations of them.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"reset!(𝐶)                                       ### reset the clock\ny = 0                                           ### create a variable y\nsample!( SF(() -> global y = tau()/2) );        ### a sampling function\nevent!( SF(()->println(tau(),\": now y ≥ π\") ), (@val :y :≥ π) ) ### a conditional event","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                              ### run\n6.28999999999991: now y ≥ π\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> 2π                                       ### exact value\n6.283185307179586","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"reset!(𝐶)\nsample!( SF(()-> global y=sin(@tau)) );         ### sample a sine function on y\nevent!(SF(()->println(tau(),\": now y ≥ 1/2\")), ((@val :y :≥ 1/2),(@tau :≥ 5))) ### two conditions","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)\n6.809999999999899: now y ≥ 1/2\n\"run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0\"\n\njulia> asin(0.5) + 2π                           ### exact value\n6.806784082777885","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"It can be seen: (1) the sample rate has some uncertainty in detecting events and (2) conditional events are triggered only once. If there is no sample rate set, a conditional event sets one up and deletes it again after it becomes true.","category":"page"},{"location":"intro/#Types-and-functions-3","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"tau, SimFunction, SF, event!, run!, reset!, sample!, @val, @tau","category":"page"},{"location":"intro/#process_scheme-1","page":"Getting started","title":"Processes","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Functions can be started as asynchronous tasks or coroutines, which can coordinate with the clock and events by delaying for some time or waiting for conditions, taking inputs from events or other tasks, triggering events or starting other tasks …","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"From a modeling or simulation standpoint we call such tasks processes, because they can represent some ongoing activity in nature. Tasks seen as processes are a powerful modeling device, but you need to take care that","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"they give back control to the clock and other such processes by calling delays or conditional waits or requesting resources (and thus implicitly waiting for them to become available) and\nthey get not out of sync with simulation time by transferring critical operations to the clock.","category":"page"},{"location":"intro/#Create-and-start-a-process-1","page":"Getting started","title":"Create and start a process","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"SimProcess, alias SP prepares a function for running as a process and assignes it an id.  Then process! registers it to the clock and starts it as a process in a loop. You can define how many loops the function should persist, but the default is Inf. You can create as many instances of a function as processes as you like.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function doit(n)                                ### create a function doit\n    i = 1\n    while i ≤ n\n        delay!(rand()*2)                        ### delay for some time\n        now!(SF(println, @sprintf(\"%5.2f: finished %d\", tau(), i)))  ### print\n        i += 1\n    end\nend\n\nRandom.seed!(1234);        \nreset!(𝐶)                                       ### reset the central clock\nprocess!(SP(1, doit, 5), 1)                     ### create, register and start doit(5) as a process, id=1, runs only once","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 5)                               ### run for 5 time units\n 1.18: finished 1\n 2.72: finished 2\n 3.85: finished 3\n 4.77: finished 4\n\"run! finished with 8 clock events, 0 sample steps, simulation time: 5.0\"\n\njulia> run!(𝐶, 2)                               ### it is not yet finished, run 2 more\n 6.36: finished 5\n\"run! finished with 2 clock events, 0 sample steps, simulation time: 7.0\"\n\n\njulia> run!(𝐶, 3)                               ### doit(5) is done with 5, nothing happens anymore\n\"run! finished with 0 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#Delay,-wait,-take-and-put-1","page":"Getting started","title":"Delay, wait, take and put","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"In order to synchronize with the clock, a process can","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"get the simulation time tau(),\ndelay!, which suspends it until after the given time t or\nwait! for a condition. This creates a conditional event! which reactivates the process when the conditions become true.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Processes can also interact directly e.g. via channels with take! and put!. This also may suspend them until there is something to take from a channel or until they are allowed to put something into it. In simulations they must take care that they keep synchronized with the clock.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function watchdog(name)\n    delay!(until, 6 + rand())                    ### delay until\n    now!(SF(println, @sprintf(\"%5.2f %s: yawn!, bark!, yawn!\", tau(), name)))\n    wait!(((@val :hunger :≥ 7),(@tau :≥ 6.5)))   ### conditional wait\n    while 5 ≤ hunger ≤ 10\n        now!(SF(println, @sprintf(\"%5.2f %s: %s\", tau(), name, repeat(\"wow \", Int(trunc(hunger))))))\n        delay!(rand()/2)                         ### simple delay\n        if scuff\n            now!(SF(println, @sprintf(\"%5.2f %s: smack smack smack\", tau(), name)))\n            global hunger = 2\n            global scuff = false\n        end\n    end\n    delay!(rand())                               ### simple delay\n    now!(SF(println, @sprintf(\"%5.2f %s: snore ... snore ... snore\", tau(), name)))\nend\n\nhunger = 0\nscuff = false\nreset!(𝐶)\nRandom.seed!(1122)\n\nsample!(SF(()-> global hunger += rand()), 0.5)   ### a sampling function: increasing hunger\nevent!(SF(()-> global scuff = true ), 7+rand())  ### an event: scuff after 7 am\nprocess!(SP(1, watchdog, \"Snoopy\"), 1)            ### create, register and run Snoopy","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)\n 6.24 Snoopy: yawn!, bark!, yawn!\n 6.50 Snoopy: wow wow wow wow wow wow wow wow\n 6.98 Snoopy: wow wow wow wow wow wow wow wow wow\n 7.37 Snoopy: smack smack smack\n 7.38 Snoopy: snore ... snore ... snore\n\"run! finished with 10 clock events, 20 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"warning: Warning\nyou must not use or invoke operations like delay!, wait!, take! or put! outside of tasks and inside the Main process, because they will suspend it.","category":"page"},{"location":"intro/#IO-operations-1","page":"Getting started","title":"IO-operations","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If they invoke IO-operations like printing, reading or writing from or to files, tasks give control back to the Julia scheduler. In this case the clock may proceed further before the operation has been completed and the task has got out of sync with simulation time. Processes therefore should enclose IO-operations in a now! call. This will transfer them for execution to the clock, which must finish them before proceeding any further.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function bad()                                   ### bad: IO-operation DIY\n    delay!(rand()*2)\n    @printf(\"%5.2f: hi, here I am\\n\", tau())\nend\nRandom.seed!(1234);\nreset!(𝐶)                                        ### reset the clock\nprocess!(SP(1, bad), 5)                          ### setup a process with 5 cycles","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                               ### it runs only once !!!\n 1.18: hi, here I am\n\"run! finished with 1 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"function better()                                ### better: let the clock doit for you\n    delay!(rand()*2)\n    now!(SF(println, @sprintf(\"%5.2f: hi, I am fine\", tau())))\nend\nRandom.seed!(1234);\nreset!(𝐶)                                        ### reset the clock\nprocess!(SP(1, better), 5)                       ### setup a process with 5 cycles","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"julia> run!(𝐶, 10)                               ### it runs all 5 cycles\n 1.18: hi, I am fine\n 2.72: hi, I am fine\n 3.85: hi, I am fine\n 4.77: hi, I am fine\n 6.36: hi, I am fine\n\"run! finished with 10 clock events, 0 sample steps, simulation time: 10.0\"","category":"page"},{"location":"intro/#Types-and-functions-4","page":"Getting started","title":"Types and functions","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"SimProcess, SP, process!, delay!, wait!, now!, SF, run!, 𝐶, reset!, sample!, event!","category":"page"},{"location":"intro/#continuous_sampling-1","page":"Getting started","title":"Continuous sampling","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Continuous sampling allows to bring continuous processes or real world data into a simulation or can be used for visualization or logging and collecting statistics.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If you provide the clock with a time interval Δt, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"sample_time!(Δt): set the clock's sample rate starting from now.\nsample!(expr): register a function or expression for sampling. If no sample rate is set, set it implicitly.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"note: Note\nConditions set by conditional event! or by wait! are also evaluated with the sampling rate. But the conditional event disappears after the conditions are met and the sample rate is then canceled if no sampling functions are registered.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"If no sample rate is set, the clock jumps from event to event.","category":"page"},{"location":"intro/#Running-a-simulation-1","page":"Getting started","title":"Running a simulation","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"After you have setup the clock, scheduled events, setup sampling or started processes – as you have seen – you can step or run through a simulation, stop or resume it.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"run!(sim::Clock, duration::Number): run a simulation for a given duration. Call all scheduled events and sampling actions in that timeframe.\nincr!(sim::Clock): take one simulation step, call the next tick or event.\nstop!(sim::Clock): stop a simulation\nresume!(sim::Clock): resume a halted simulation.","category":"page"},{"location":"intro/#Logging-1","page":"Getting started","title":"Logging","text":"","category":"section"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"Logging enables us to trace variables over simulation time and then analyze their behaviour.","category":"page"},{"location":"intro/#","page":"Getting started","title":"Getting started","text":"L = Logger(): create a new logger, providing the newest record L.last, a logging table L.df and a switch L.ltype between logging types.\ninit!(L::Logger, sim::Clock=𝐶):\nsetup!(L::Logger, vars::Array{Symbol}): setup L, providing it with an array of logging variables [:a, :b, :c ...]\nswitch!(L::Logger, to::Number=0): switch between 0: only keep the last record, 1: print, 2: write records to the table\nrecord!(L::Logger): record the logging variables with current simulation time.","category":"page"},{"location":"examples/postoffice/postoffice/#A-Post-Office-1","page":"A Post Office","title":"A Post Office","text":"","category":"section"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Let us begin with an everyday story: there is a small post office with one clerk serving the arriving customers. Customers have differing wishes leading to different serving times, from 1 - 5 minutes. We have to add a little variation to serving times counting for variation in customer habits and clerk performance. The arrival rate of customers is about 18 per hour, every 3.33 minutes or 3 minutes, 20 seconds on average. Our post office is small and customer patience is limited, so queue length is limited to 5 customers.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"We have provided 10% extra capacity, so our expectation is that there should not be too many customers discouraged for long waiting times or for full queues.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"(Image: post office)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Let's do a process-based simulation using Simulate. We need","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"a source: all the people, providing an unlimited supply for customers,\ncustomers with their demands and their limited patience,\na queue and\nour good old clerk.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"First we must load the needed modules, describe a customer and define some needed helper functions.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"using Simulate, Random, Distributions, DataFrames\n\nmutable struct Customer\n    id::Int64\n    arrival::Float64\n    request::Int64\n\n    Customer(n::Int64, arrival::Float64) = new(n, arrival, rand(DiscreteUniform(1, 5)))\nend\n\nfull(q::Channel) = length(q.data) >= q.sz_max\nlogevent(nr, queue::Channel, info::AbstractString, wt::Number) =\n    push!(df, (round(τ(), digits=2), nr, length(queue.data), info, wt))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"logevent (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Then we define functions for our processes: people and clerk.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"function people(output::Channel, β::Float64)\n    i = 1\n    while true\n        Δt = rand(Exponential(β))\n        delay!(Δt)\n        if !full(output)\n            put!(output, Customer(i, τ()))\n            logevent(i, output, \"enqueues\", 0)\n         else\n            logevent(i, output, \"leaves - queue is full!\", -1)\n        end\n        i += 1\n    end\nend\n\nfunction clerk(input::Channel)\n    cust = take!(input)\n    Δt = cust.request + randn()*0.2\n    logevent(cust.id, input, \"now being served\", τ() - cust.arrival)\n    delay!(Δt)\n    logevent(cust.id, input, \"leaves\", τ() - cust.arrival)\nend","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"clerk (generic function with 1 method)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Then we have to create out data, register and startup the processes:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"reset!(𝐶)  # for repeated runs it is easier if we reset our central clock here\nRandom.seed!(2019)  # seed random number generator for reproducibility\nqueue = Channel(5)  # thus we determine the max size of the queue\n\ndf = DataFrame(time=Float64[], cust=Int[], qlen=Int64[], status=String[], wtime=Float64[])\n\nprocess!(𝐶, SimProcess(1, people, queue, 3.333)) # register the functions as processes\nprocess!(𝐶, SimProcess(2, clerk, queue))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"2","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Then we can simply run the simulation. We assume our time unit being minutes, so we run for 600 units:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"println(run!(𝐶, 600))\nprintln(\"``(length(queue.data)) customers yet in queue\")","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"run! finished with 338 clock events, 0 sample steps, simulation time: 600.0\n0 customers yet in queue","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Our table has registered it all:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"df","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"no time cust qlen status wtime\n1 1.2 1 1 enqueues 0.0\n2 1.2 1 0 now being served 0.0\n3 5.46 2 1 enqueues 0.0\n4 5.5 3 2 enqueues 0.0\n5 6.19 1 2 leaves 4.99532\n6 6.19 2 1 now being served 0.737497\n7 7.99 4 2 enqueues 0.0\n8 8.81 2 2 leaves 3.35581\n9 8.81 3 1 now being served 3.30971\n10 12.33 5 2 enqueues 0.0\n11 12.98 3 2 leaves 7.4733\n12 12.98 4 1 now being served 4.98585\n13 13.73 4 1 leaves 5.74268\n14 13.73 5 0 now being served 1.39837\n15 15.72 6 1 enqueues 0.0\n16 17.12 7 2 enqueues 0.0\n17 17.73 5 2 leaves 5.3967\n18 17.73 6 1 now being served 2.00988\n19 20.0 8 2 enqueues 0.0\n20 20.76 9 3 enqueues 0.0\n21 23.26 6 3 leaves 7.53774\n22 23.26 7 2 now being served 6.13554\n23 25.43 10 3 enqueues 0.0\n24 26.0 11 4 enqueues 0.0\n25 26.35 7 4 leaves 9.22525\n26 26.35 8 3 now being served 6.34474\n27 27.49 12 4 enqueues 0.0\n28 27.64 8 4 leaves 7.63665\n29 27.64 9 3 now being served 6.88549\n30 29.06 13 4 enqueues 0.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"last(df, 5)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"no time cust qlen status wtime\n1 589.1 171 1 enqueues 0.0\n2 589.1 171 0 now being served 0.0\n3 593.77 171 0 leaves 4.67801\n4 598.01 172 1 enqueues 0.0\n5 598.01 172 0 now being served 0.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"describe(df[df[!, :wtime] .> 0, :wtime])","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Summary Stats:\nLength:         302\nMissing Count:  0\nMean:           7.486712\nMinimum:        0.009196\n1st Quartile:   3.866847\nMedian:         6.409644\n3rd Quartile:   10.541481\nMaximum:        23.268310\nType:           Float64","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"In 600 minutes simulation time, we registered 172 customers and 505 status changes. The mean and median waiting times were around 7 minutes.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"by(df, :status, df -> size(df, 1))","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"no status x1\n1 enqueues 167\n2 now being served 167\n3 leaves 166\n4 leaves - queue is full! 5","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Of the 172 customers, 167 of them participated in the whole process and were served, but 5 left beforehand because the queue was full:","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"df[df.wtime .< 0,:]","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"no time cust qlen status wtime\n1 45.32 19 5 leaves - queue is full! -1.0\n2 249.11 66 5 leaves - queue is full! -1.0\n3 270.04 74 5 leaves - queue is full! -1.0\n4 380.39 106 5 leaves - queue is full! -1.0\n5 382.02 107 5 leaves - queue is full! -1.0","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"using PyPlot\nstep(df.time, df.wtime)\nstep(df.time, df.qlen)\naxhline(y=0, color=\"k\")\ngrid()\nxlabel(\"time [min]\")\nylabel(\"wait time [min], queue length\")\ntitle(\"Waiting Time in the Post Office\")\nlegend([\"wait_time\", \"queue_len\"]);","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"(Image: png)","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Many customers had waiting times of more than 10, 15 up to even more than 20 minutes. The negative waiting times were the 5 customers, which left because the queue was full.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"So many customers will remain angry. If this is the situation all days, our post office will have an evil reputation. What should we do?","category":"page"},{"location":"examples/postoffice/postoffice/#Conclusion-1","page":"A Post Office","title":"Conclusion","text":"","category":"section"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Even if our process runs within predetermined bounds (queue length, customer wishes …), it seems to fluctuate wildly and to produce unpredicted effects. We see here the effects of variation in arrivals, in demands and in serving time on system performance. In this case 10% extra capacity is not enough to provide enough buffer for variation and for customer service – even if our post clerk is the most willing person.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"Even for such a simple everyday system, we cannot say beforehand – without reality check – which throughput, waiting times, mean queue length, capacity utilization or customer satisfaction will emerge. Even more so for more complicated systems in production, service, projects and supply chains with multiple dependencies.","category":"page"},{"location":"examples/postoffice/postoffice/#","page":"A Post Office","title":"A Post Office","text":"If we had known the situation beforehand, we could have provided standby for our clerk or install an automatic stamp dispenser for cutting the short tasks … We should have done a simulation …","category":"page"},{"location":"examples/house_heating/house_heating/#House-heating-1","page":"House heating","title":"House heating","text":"","category":"section"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat is a basic example of this:","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"Heating changes between two states: On and Off.\nA room cools dotQ_c Jh at a certain rate proportional to the difference between room temperature T_r and environment temperature T_e K.\nIt heats dotQ_h Jh at a rate proportional to the temperature difference between temperature of the heating fluid T_h K and room temperature T_r K.\nThe room temperature T_r changes proportional to the difference between heating dotQ_h and cooling dotQ_c.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"begineqnarray\ndotQ_c  =  fracleft(T_r - T_eright)eta R   lefttfracJhright  mathrmwhere R = thermal resistance lefttfracK hJright eta = efficiency  factor le 10\ndotQ_h  =  alpha left(T_h - T_rright)   lefttfracJhright  mathrmwhere alpha = proportionality factor lefttfracJK hright \ndotT_h  =  beta left(dotQ_h - dotQ_cright)  lefttfracKhright  mathrmwhere beta = proportionality factor lefttfracKJright\ndotT_c  =  - beta dotQ_c  lefttfracKhright  mathrmwhen heating is switched off\nendeqnarray","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We assume that","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"the thermostat is set to switch heating on if T_r falls under 20°C and to switch heating on if T_r rises above 23°C,\nthat time units are hours,\nthe temperature T_h of the heating fluid is 40°C,\nthe temperature T_e of the environment follows a stochastic process based on a sine function between 8 and 20°C with T_emin at 4am and T_emax at 4pm,\nthe constants have values R = 1times10^-6 leftfracK hJright alpha = 2times 10^6 leftfracJK hright beta = 3times 10^-7 leftfracKJright,\npeople entering the room may reduce insulation efficiency by a factor etale10 to R,\nthe room temperature is initially T_r0 = 20 C and\nthe heater is off.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"First we setup the physical model:","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"using Simulate, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst α = 2e6     # represents thermal conductivity and capacity of the air\nconst β = 3e-7    # represents mass of the air and heat capacity\nη = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false\n\nΔte(t, t1, t2) = cos((t-10)*π/12) * (t2-t1)/2  # change rate of a sinusoidal Te\n\nfunction Δtr(Tr, Te, heating)\n    Δqc = (Tr - Te)/(R * η)\n    Δqh = heating ? α * (Th - Tr) : 0\n    return β * (Δqh - Δqc)\nend","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"Δtr (generic function with 1 method)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We now setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"reset!(𝐶)\nrng = MersenneTwister(122)\nΔt = 1//60\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)\n    global Te += Δte(tau(), t1, t2) * 2π/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Δtr(Tr, Te, heating) * Δt\n    push!(df, (tau(), Tr, Te, Int(heating)) )\nend\n\nfunction switch(t1=20, t2=23)\n    if Tr ≥ t2\n        global heating = false\n        event!(SF(switch, t1, t2), @val :Tr :≤ t1)\n    elseif Tr ≤ t1\n        global heating = true\n        event!(SF(switch, t1, t2), @val :Tr :≥ t2)\n    end\nend\n\nSimulate.sample!(SF(setTemperatures), Δt)\nswitch()\n\n@time run!(𝐶, 24)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"In a living room the thermal resistance is repeatedly diminished if people enter the room or open windows.","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))\n    sleeptime = 22 + rand(Normal(0, 0.5))\n    while tau() < sleeptime\n        global η = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global η = 1.0                       # close it again\n        delay!(rand())\n    end\nend\n\nreset!(𝐶)\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(SP(i, people), 1)               # run process only once\nend\nSimulate.sample!(SF(setTemperatures), Δt)\nswitch()\n\n@time run!(𝐶, 24)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"(Image: svg)","category":"page"},{"location":"examples/house_heating/house_heating/#","page":"House heating","title":"House heating","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"CurrentModule = Simulate","category":"page"},{"location":"internals/#Module-1","page":"Internals","title":"Module","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Simulate","category":"page"},{"location":"internals/#Simulate.Simulate","page":"Internals","title":"Simulate.Simulate","text":"Simulate\n\nA Julia package for discrete event simulation based on state machines.\n\n\n\n\n\n","category":"module"},{"location":"internals/#","page":"Internals","title":"Internals","text":"The module contains two main types: Clock and Logger. Both are implemented as state machines. The implementation functions and types are not exported. The exported functions documented above under Usage are commands to the internal state machines.","category":"page"},{"location":"internals/#State-machines-1","page":"Internals","title":"State machines","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"We have some definitions for them to work.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEngine","category":"page"},{"location":"internals/#Simulate.SEngine","page":"Internals","title":"Simulate.SEngine","text":"supertype for state machines in Sim.jl\n\n\n\n\n\n","category":"type"},{"location":"internals/#States-1","page":"Internals","title":"States","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined states for state machines.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SState\nUndefined\nIdle\nEmpty\nBusy\nHalted","category":"page"},{"location":"internals/#Simulate.SState","page":"Internals","title":"Simulate.SState","text":"supertype for states\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Undefined","page":"Internals","title":"Simulate.Undefined","text":"a state machine is undefined (after creation)\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Idle","page":"Internals","title":"Simulate.Idle","text":"a state machine is idle\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Empty","page":"Internals","title":"Simulate.Empty","text":"a state machine is empty\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Busy","page":"Internals","title":"Simulate.Busy","text":"a state machine is busy\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Halted","page":"Internals","title":"Simulate.Halted","text":"a state machine is halted\n\n\n\n\n\n","category":"type"},{"location":"internals/#Events-1","page":"Internals","title":"Events","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"Defined events.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SEvent\nInit\nSetup\nSwitch\nLog\nStep\nRun\nStart\nStop\nResume\nClear","category":"page"},{"location":"internals/#Simulate.SEvent","page":"Internals","title":"Simulate.SEvent","text":"supertype for events\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Init","page":"Internals","title":"Simulate.Init","text":"Init(info): Init event with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Setup","page":"Internals","title":"Simulate.Setup","text":"Setup(vars::Array{Symbol,1}, scope::Module): setup a logger with some info.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Switch","page":"Internals","title":"Simulate.Switch","text":"Switch(to): switch to some other mode\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Log","page":"Internals","title":"Simulate.Log","text":"Log(): record command for logging\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Step","page":"Internals","title":"Simulate.Step","text":"Step(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Run","page":"Internals","title":"Simulate.Run","text":"Run(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Start","page":"Internals","title":"Simulate.Start","text":"Start(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Stop","page":"Internals","title":"Simulate.Stop","text":"Stop(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Resume","page":"Internals","title":"Simulate.Resume","text":"Resume(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Clear","page":"Internals","title":"Simulate.Clear","text":"Clear(): command\n\n\n\n\n\n","category":"type"},{"location":"internals/#Transition-functions-1","page":"Internals","title":"Transition functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"In state machines transitions occur depending on states and events. The different transitions are described through different methods of the step!-function.","category":"page"},{"location":"internals/#","page":"Internals","title":"Internals","text":"step!","category":"page"},{"location":"internals/#Simulate.step!","page":"Internals","title":"Simulate.step!","text":"step!(A::SEngine, q::SState, σ::SEvent)\n\nDefault transition for clock and logger.\n\nThis is called if no otherwise defined transition occurs.\n\nArguments\n\nA::SEngine: state machine for which a transition is called\nq::SState:  state of the state machine\nσ::SEvent:  event, triggering the transition\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, ::Init)\n\ninitialize a clock.\n\n\n\n\n\nstep!(sim::Clock, ::Undefined, σ::Union{Step,Run})\n\nif uninitialized, initialize and then Step or Run.\n\n\n\n\n\nstep!(sim::Clock, ::Union{Idle,Busy,Halted}, ::Step)\n\nstep forward to next tick or scheduled event.\n\nAt a tick evaluate 1) all sampling functions or expressions, 2) all conditional events, then 3) if an event is encountered, trigger the event.\n\nThe internal clock times sim.tev and sim.tsa is always at least sim.time.\n\n\n\n\n\nstep!(sim::Clock, ::Idle, σ::Run)\n\nRun a simulation for a given duration.\n\nThe duration is given with Run(duration). Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\nstep!(sim::Clock, ::Busy, ::Stop)\n\nStop the clock.\n\n\n\n\n\nstep!(sim::Clock, ::Halted, ::Resume)\n\nResume a halted clock.\n\n\n\n\n\nstep!(sim::Clock, q::SState, σ::SEvent)\n\ncatch all step!-function.\n\n\n\n\n\nstep!(A::Logger, ::Undefined, σ::Init)\n\nInitialize a logger.\n\n\n\n\n\nstep!(A::Logger, ::Empty, σ::Setup)\n\nSetup a logger with logging variables. They are given by Setup(vars, scope).\n\n\n\n\n\nstep!(A::Logger, ::Idle, ::Clear)\n\nClear the last record and the data table of a logger.\n\n\n\n\n\nstep!(A::Logger, ::Idle, σ::Log)\n\nLogging event.\n\n\n\n\n\nstep!(A::Logger, ::Idle, σ::Switch)\n\nSwitch the operating mode of a logger by Switch(to).\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"internals/#Other-internal-types-and-functions-1","page":"Internals","title":"Other internal types and functions","text":"","category":"section"},{"location":"internals/#","page":"Internals","title":"Internals","text":"SimEvent\nSimCond\nSample\nsconvert\nsimExec\nnextevent\nnextevtime\nchecktime\nsetTimes\nstartup!\nloop\nscale","category":"page"},{"location":"internals/#Simulate.SimEvent","page":"Internals","title":"Simulate.SimEvent","text":"SimEvent(ex::Array{SimExpr, 1}, scope::Module, t::Float64, Δt::Float64)\n\nCreate a simulation event: a SimExpr or an array of SimExpr to be executed at event time.\n\nArguments, fields\n\nex::Array{SimExpr, 1}: an array of SimExpr to be evaluated at event time,\nscope::Module: evaluation scope,\nt::Float64: event time,\nΔt::Float64: repeat rate with which the event gets repeated.\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.SimCond","page":"Internals","title":"Simulate.SimCond","text":"SimCond(cond::Array{SimExpr, 1}, ex::Array{SimExpr, 1}, scope::Module)\n\ncreate a condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.\n\nArguments, fields\n\ncond::Array{SimExpr, 1}: Expr or SFs to be evaluated as conditions\nex::Array{SimExpr, 1}: Expr or SFs to be evaluated if conditions are all true\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.Sample","page":"Internals","title":"Simulate.Sample","text":"Sample(ex::SimExpr, scope::Module)\n\nCreate a sampling expression.\n\nArguments, fields\n\nex::SimExpr: expression or SimFunction to be called at sample time\nscope::Module: evaluation scope\n\n\n\n\n\n","category":"type"},{"location":"internals/#Simulate.sconvert","page":"Internals","title":"Simulate.sconvert","text":"sconvert(ex::Union{SimExpr,Array,Tuple})::Array{SimExpr,1}\n\nconvert a SimExpr or an array or a tuple of it to an Array{SimExpr,1}\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.simExec","page":"Internals","title":"Simulate.simExec","text":"simExec(ex::Union{SimExpr, Array{SimExpr,1}}, m::Module=Main)\n\nevaluate the event expressions or SimFunctions.\n\nReturn\n\nthe evaluated value or a tuple of evaluated values\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevent","page":"Internals","title":"Simulate.nextevent","text":"nextevent(sim::Clock)\n\nReturn the next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.nextevtime","page":"Internals","title":"Simulate.nextevtime","text":"nextevtime(sim::Clock)\n\nReturn the internal time (unitless) of next scheduled event.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.checktime","page":"Internals","title":"Simulate.checktime","text":"checktime(sim::Clock, t::Number)::Float64\n\ncheck t given according to clock settings and return a Float64 value\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.setTimes","page":"Internals","title":"Simulate.setTimes","text":"setTimes(sim::Clock)\n\nset clock times for next event or sampling action. The internal clock times sim.tev and sim.tsa must always be set to be at least sim.time.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.startup!","page":"Internals","title":"Simulate.startup!","text":"startup!(p::SimProcess, cycles::Number)\n\nStart a SimProcess as a task in a loop.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.loop","page":"Internals","title":"Simulate.loop","text":"loop(p::SimProcess, start::Channel, cycles::Number)\n\nPut a SimProcess in a loop, which can be broken by a SimException.\n\nArguments\n\np::SimProcess:\nstart::Channel: a channel to ensure that a process starts,\ncycles=Inf: determine, how often the loop should be run.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Simulate.scale","page":"Internals","title":"Simulate.scale","text":"scale(n::Number)::Float64\n\ncalculate the scale from a given number\n\n\n\n\n\n","category":"function"},{"location":"examples/dicegame/dicegame/#Goldratt's-Dice-Game-1","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Goldratt's Dice Game from his business novel \"The Goal\" is a classical illustration that dependencies and statistical fluctuations diminish the throughput through a system.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Alex Rogo, the hero of the novel plays a game with five boys:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"While they go get the others, I figure out the details. The system I've set up is intended to \"process\" matches. It does this by moving a quantity of match sticks out of their box, and through each of the bowls in succession. The dice determine how many matches can be moved from one bowl to the next. The dice represent the capacity of each resource, each bowl; the set of bowls are my dependent events, my stages of production. Each has exactly the same capacity as the others, but its actual yield will fluctuate somewhat.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"In order to keep those fluctuations minimal, however, I decide to use only one of the dice. This allows the fluctuations to range from one to six. So from the first bowl, I can move to the next bowls in line any quantity of matches ranging from a minimum of one to a maximum of six.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Throughput in this system is the speed at which matches come out of the last bowl, Inventory consists of the total number of matches in all of the bowls at any time. And I'm going to assume that market demand is exactly equal to the average number of matches that the system can process. Production capacity of each resource and market demand are perfectly in balance. So that means I now have a model of a perfectly balanced manufacturing plant.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Five of the boys decide to play. Besides Dave, there are Andy, Ben, Chuck, and Evan. Each of them sits behind one of the bowls. I find some paper and a pencil to record what happens. Then I explain what they're supposed to do.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"\"The idea is to move as many matches as you can from your bowl to the bowl on your right. When it's your turn, you roll the die, and the number that comes up is the number of matches you can move. Got it?\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"They all nod. \"But you can only move as many matches as you've got in your bowl. So if you roll a five and you only have two matches in your bowl, then you can only move two matches. And if it comes to your turn and you don't have any matches, then naturally you can't move any.\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Eliyahu M Goldratt: The Goal.– 3rd ed, p. 105","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then Rogo explains to the boys that with the die on average they should pass 3.5 matches through the system, so after twenty cycles they should have got an output of seventy.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: The Dice Game)","category":"page"},{"location":"examples/dicegame/dicegame/#An-assembly-line-1","page":"Goldratt's Dice Game","title":"An assembly line","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As Goldratt described it, the game is done in a fixed cycle – no asynchronism here and no need for a discrete-event-simulation. But more realistically it could be seen as an assembly line with buffers between the five workers:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: assembly line)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The workers take on average 3.5 time units for processing an item and they are admonished to work as fast as possible. To implement it, we need some data structure for workers …","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Simulate, Distributions, DataFrames, Random\n\nmutable struct Worker\n    nr::Int64              # worker number\n    clk::Clock\n    input::Channel  \n    output::Channel\n    dist::Distribution     # distribution of processing time\n    retard::Float64        # worker retard factor, 1: no retardation, >1: retardation\n    done::Int64            # number of finished items\n\n    Worker(nr, clk, input, output, dist, perform) = new(nr, clk, input, output, dist, 1/perform, 0)\nend","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"… and a function representing their operation. The buffers are represented by channels. Then we build the system by creating workers and connecting them by channels. We start the work processes with their respective data and run the simulation.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"stats(t::Float64, nr::Int64, len::Int64) = push!(df, (t, nr, len))  ## write buffersize to dataframe\n\nfunction work(w::Worker, stat::Bool)\n    job = take!(w.input)\n    stat ? stats(tau(w.clk), w.nr, length(w.input.data)) : nothing\n    delay!(w.clk, rand(w.dist) * w.retard)\n    put!(w.output, job)\n    stat ? stats(tau(w.clk), w.nr+1, length(w.output.data)) : nothing\n    w.done += 1\nend\n\nreset!(𝐶)\nRandom.seed!(1234)                 # seed random number generator\ndf = DataFrame(time=Float64[], channel=Int[], length=Int[])\n\nC = [Channel{Int64}(Inf) for i in 1:6]    # create 6 channels\nj = reverse(Array(1:8))\nfor i in 5:-1:2                    # seed channels 2:5 each with 2 inventory items\n    put!(C[i], j[(i-1)*2])\n    put!(C[i], j[(i-1)*2-1])\nend\nfor i in 9:1000                    # put other 992 jobs into channel 1\n    put!(C[1], i)\nend\n\nW = [Worker(i, 𝐶, C[i], C[i+1], Uniform(0.5, 6.5), 1.0) for i in 1:5]\nfor i in 1:5\n    process!(SP(i, work, W[i], true))\nend\n@time run!(𝐶, 1000)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"0.261483 seconds (115.06 k allocations: 4.404 MiB)\n\"run! finished with 1390 clock events, 0 sample steps, simulation time: 1000.0\"","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"length(C[6].data)                    # how much got produced?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"272","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000/272","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"3.676470588235294","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"After running for 1000 time units, we got 272 finished items in channel 6, meaning an average cycle time of 3.68, not 3.5 as expected. The expected throughput would have been 286 units, so the line produced only 95% of that, even under \"perfect\" conditions like unlimited supply, an in-process inventory to start with, infinite buffer sizes, a perfectly balanced line and equally performing workers without breaks … What happened?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Plots\n\nfunction inventory_plot(n::Int64, title)\n    for i ∈ 2:n\n        d = df[df.channel .== i, :]\n        doplot = i == 2 ? plot : plot!\n        doplot(d.time, d.length, label=\"channel$i\")\n    end\n    title!(title)\n    xlabel!(\"time\")\n    ylabel!(\"Inventory\")\nend\ninventory_plot(5, \"In-Process-Inventory of Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We see that statistical fluctuations in processing times (the dice!) lead to wildly fluctuating buffers, overproduction of worker 1 (look at channel 2) and also to starvation of other workers down the line when their input buffers are empty. Let's calculate the inventory of unfinished goods in the line at the end of the simulation run:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1000-length(C[1].data)-length(C[6].data)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"26","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This gives an average of 6.5 inventory items in channels 2-5. But as we see in the plot, some channels are often empty, leading to some starvation.","category":"page"},{"location":"examples/dicegame/dicegame/#Parametrizing-the-model-1","page":"Goldratt's Dice Game","title":"Parametrizing the model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For further investigations we parametrize our model. This is not easily done in graphically oriented simulators, but we can do it with Simulate.jl.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"As parameters we take:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: the length of the line (number of workers)\nmw: max WIP-buffer sizes (WIP is work in progress),\nvp: variation in processing times from item to item and,\nvw: variation between worker performance,\nd: the duration of the simulation run","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We give each simulation its own clock and channels variables so that it can be run in parallel on different threads.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"function dice_line( n::Int64, mw::Int64,\n                    vp::Distribution, vw::Distribution;\n                    d=1000, seed=1234, jobs=1000, stat::Bool=true )\n    clk = Clock()\n    Random.seed!(seed)                  # seed random number generator\n    stat ? ( global df = DataFrame(time=Float64[], channel=Int[], length=Int[]) ) : nothing\n    C = [Channel{Int64}(mw) for i in 1:n+1] # create n+1 channels with given buffer sizes\n    C[1] = Channel{Int64}(Inf)                 # unlimited sizes for channels 1 and n+1\n    C[n+1] = Channel{Int64}(Inf)\n    j = reverse(Array(1:(n-1)*2))\n    for i in n:-1:2                     # seed channels 2:(n-1) each with 2 inventory items\n        C[i].sz_max > 0 ? put!(C[i], j[(i-1)*2]) : nothing\n        C[i].sz_max > 1 ? put!(C[i], j[(i-1)*2-1]) : nothing\n    end\n    for i in ((n-1)*2+1):jobs           # put other jobs into channel 1\n        put!(C[1], i)\n    end\n\n    wp = rand(vw, n)                    # calculate worker performance\n    W = [Worker(i, clk, C[i], C[i+1], vp, wp[i]) for i in 1:n]\n    for i in 1:n\n        process!(clk, SP(i, work, W[i], stat))\n    end\n    info = run!(clk, d)\n    return (info, clk.evcount, length(C[end].data))\nend","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"dice_line (generic function with 1 method)","category":"page"},{"location":"examples/dicegame/dicegame/#Kanban-…-1","page":"Goldratt's Dice Game","title":"Kanban …","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Against too much inventory we have Kanban. So let's introduce maximum buffer sizes of 5 items. We have yet our five perfect workers without varying performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using Printf\ninfo, ev, res = dice_line(5, 5, Uniform(0.5, 6.5), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"%5.2f%s capacity utilization\", 3.5*res/10, \"%\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"run! finished with 1341 clock events, 0 sample steps, simulation time: 1000.0\n266 items produced!\n93.10% capacity utilization","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Uups! We throttled our system further, to an output of 266.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"But we got much less inventory in the system. The throttling occurs because with Kanban in-process-inventories get more often to zero. Seemingly Kanban is no solution for our throughput problem but constrains the system further. With Kanban we have reduced unpredictability and instability in inventory.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Let's pause a moment to look at what we have here: we got a small model with which we can simulate and analyze the impact of dependencies (line length and buffer sizes) and statistical fluctuations (in processing time and worker performance) on simple assembly lines like there are thousands in industry. This is no minor achievement.","category":"page"},{"location":"examples/dicegame/dicegame/#Investigating-assembly-lines-1","page":"Goldratt's Dice Game","title":"Investigating assembly lines","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"With the parametrized model we can do some investigations into the behaviour of assembly lines.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"For that we take first some further simplification steps:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We normalize the model by assuming a mean processing time of 1.\nWe choose a gamma distribution as more realistic for processing times than the uniform distribution, we used until now following Goldratt's example:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsPlots, LaTeXStrings\n\nfor i in [2,3,5,10,15,20]\n    doplot = i == 2 ? plot : plot!\n    doplot(Gamma(i, 1/i), label=latexstring(\"a=$i, \\\\theta=$(round(1/i, digits=2))\"))\nend\nxlabel!(L\"\\mathsf{processing\\, time}\")\nylabel!(L\"\\mathsf{probability\\, density}\")\ntitle!(latexstring(\"\\\\mathsf{Gamma\\\\, distribution,\\\\,} \\\\mu=1\"))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@time info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0))\nprintln(info)\nprintln(res, \" items produced!\")\n@printf(\"y = %5.3f [1/t]\", res/1000)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"1.060803 seconds (1.03 M allocations: 46.115 MiB, 1.03% gc time)\nrun! finished with 4847 clock events, 0 sample steps, simulation time: 1000.0\n966 items produced!\ny = 0.966 [1/t]","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"inventory_plot(5, \"In-Process-Inventory of kanbanized Dice-Line\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Before we go deeper into parameters, we have to check how much path dependence and statistical fluctuations vary the outcome. Therefore we repeat the simulation 30 times with different random number seeds and analyze the distribution of the outcome. As outcome we choose the throughput rate y [1/t] which is also an indicator for line performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Random.seed!(1234)\ns = abs.(rand(Int, 30))\ntc = ones(30)\nThreads.@threads for i = 1:30\n    info, ev, res = dice_line(5, 5, Gamma(10,1/10), Normal(1,0), seed=s[i], jobs=1200, stat=false)\n    tc[i] = res*0.001\nend\nys = (μ=mean(tc), σ=std(tc))\n@printf(\"μ: %5.3f, σ: %5.3f, LCL: %5.3f, UCL: %5.3f\\n\", ys.μ, ys.σ, ys.μ-3ys.σ, ys.μ+3ys.σ)\nplot(1:30, tc, title=\"throughput rate of various runs of dice line\", xlabel=\"runs\",\n    ylabel=\"y [1/t]\", legend=:none, lw=2)\nhline!([ys.μ, ys.μ-3ys.σ, ys.μ+3ys.σ], lc=:red)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"μ: 0.967, σ: 0.006, LCL: 0.950, UCL: 0.984","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#Experimental-design-1","page":"Goldratt's Dice Game","title":"Experimental design","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Our response variable y seems to be under statistical control and its fluctuation is of the same order as the effects we are after. But with an experimental design those fluctuations should cancel out. We setup it up with:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"n: number of workers, line length,\nb: buffersize between workers,\na: shape parameter of gamma distribution of processing times (bigger a means less variation),\nσ: standard deviation of performance variation between workers.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using StatsModels, ExperimentalDesign\n\nn = vcat(5:10,12:2:20)\nb = 1:10\na = vcat(2,3,5:5:20)\nσ = LinRange(0,0.1,5)\n\nD = FullFactorial((n=n, b=b, a=a, σ=σ), @formula(y ~ n + b + a + σ), explicit = true)\nsize(D.matrix)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(3300, 4)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We got a design matrix with 3300 rows for 3300 simulations! Let's do something else while the computer works:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"y = zeros(3300)\nevents = 0\nt = @elapsed begin\n    Threads.@threads for i = 1:3300\n        p = Tuple(D.matrix[i, :])\n        info, ev, res = dice_line(p[1], p[2], Gamma(p[3], 1/p[3]), Normal(1, p[4]), jobs=1200, stat=false )\n        y[i] = res*0.001\n        global events += ev\n    end\nend\n@printf(\"Time elapsed: %5.2f minutes, %d events on %d threads\", t/60, events, Threads.nthreads())","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Time elapsed: 17.47 minutes, 33558658 events on 4 threads","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"It takes over 17 minutes on 4 threads of a 2013 MacBook Pro and over 33times 10^6 events.","category":"page"},{"location":"examples/dicegame/dicegame/#Data-analysis-1","page":"Goldratt's Dice Game","title":"Data analysis","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We put together a results table and do some exploratory data analysis:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"res = D.matrix\nres.y = y\ndescribe(y)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Summary Stats:\nLength:         3300\nMissing Count:  0\nMean:           0.892569\nMinimum:        0.633000\n1st Quartile:   0.863750\nMedian:         0.904000\n3rd Quartile:   0.937000\nMaximum:        0.986000\nType:           Float64","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The performance of our simulated assembly lines varies between 0.637 and 0.986, which is a huge difference: The worst result is 35.8% below the best one!","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"vcat(res[y .== maximum(y), :], res[y .== minimum(y), :])","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"no n b a σ y\n1 6 7 20 0.0 0.986\n2 5 10 20 0.0 0.986\n3 18 1 2 0.05 0.633","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The best performance is with the shortest lines, big buffer sizes, small variation in processing times and no variation in performance between workers. But this is just common sense. The worst performance is with a long line, minimum buffers and maximum variation in processing times and in performance between workers. But how big are the effects?","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:n, :y, title=\"line performance vs line length\", xlabel=\"n\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:n, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:b, :y, title=\"line performance vs buffer size\", xlabel=\"b\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:b, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"@df res dotplot(:a, :y, title=\"line performance vs processing time variation\", xlabel=\"a (bigger a: less variation)\",\n    ylabel=\"y [1/t]\", marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(:a, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = Int.(round.(res.σ*40))\n@df res dotplot(x, :y, title=\"line performance vs worker performance variation\", xlabel=L\"\\sigma\", ylabel=\"y [1/t]\",\n    marker=(:circle, 2, 0.3, :none, 1, 0.3, :blue, :solid), legend=:none)\n@df res boxplot!(x, :y, marker=(:none, 0.3, 0.3, :blue, 2, 0.3, :blue, :solid), fill=(0, 0.2, :blue))\nxticks!(collect(0:4), string.(round.(σ, digits=3)))","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer sizes and variation in processing time clearly have nonlinear effects while line length and performance variation between workers seem to have more linear ones. Small buffers and variation in processing time constrain the line the most and also are responsible for the worst performances. There seems to be also an interaction between those major two factors.","category":"page"},{"location":"examples/dicegame/dicegame/#Statistical-model-1","page":"Goldratt's Dice Game","title":"Statistical model","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We fit a linear model to the results and account for the nonlinearities with logarithmic terms:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"using GLM\n\nols = lm(@formula(y ~ 1 + n + log(1+b) + log(a) + σ), res)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + σ\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────────────────\n                Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n───────────────────────────────────────────────────────────────────────────────────\n(Intercept)   0.738014    0.00235126   313.881     <1e-99   0.733404     0.742624  \nn            -0.00154928  9.81169e-5   -15.7902    <1e-53  -0.00174166  -0.00135691\nlog(1 + b)    0.0576481   0.000897264   64.2488    <1e-99   0.0558889    0.0594074\nlog(a)        0.050857    0.000564214   90.1378    <1e-99   0.0497508    0.0519633\nσ            -0.508588    0.0133498    -38.097     <1e-99  -0.534763    -0.482413  \n───────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"All parameters are highly significant. We find then - as expected - that the b&a-interaction between buffer size and variation in processing times is highly significant too:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"ols2 = lm(@formula(y ~ 1 + n + log(1+b)*log(a) + σ), res)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + n + :(log(1 + b)) + :(log(a)) + σ + :(log(1 + b)) & :(log(a))\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────────────────────────\n                        Estimate   Std. Error   t value  Pr(>|t|)    Lower 95%    Upper 95%\n───────────────────────────────────────────────────────────────────────────────────────────\n(Intercept)           0.5992      0.00314399   190.586     <1e-99   0.593035     0.605364  \nn                    -0.00154928  7.21745e-5   -21.4658    <1e-95  -0.00169079  -0.00140777\nlog(1 + b)            0.13696     0.00163887    83.5699    <1e-99   0.133747     0.140173  \nlog(a)                0.123869    0.00144194    85.9039    <1e-99   0.121041     0.126696  \nσ                    -0.508588    0.00982009   -51.7906    <1e-99  -0.527842    -0.489334  \nlog(1 + b) & log(a)  -0.0417155   0.000788995  -52.8716    <1e-99  -0.0432624   -0.0401685\n───────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Then we can analyze the effects of the four parameters on line performance:","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(1,10,50)\nfor i in reverse(a)\n    _n = fill(mean(n), length(x))\n    _a = fill(i, length(x))\n    _σ = fill(mean(σ), length(x))\n    tmp = DataFrame(n=_n, b=x, a=_a, σ=_σ)\n    _y = predict(ols2, tmp)\n    doplot = i == 20 ? plot : plot!\n    doplot(x, _y, label=\"a=$i\")\nend\ntitle!(\"Effects of buffer size and processing time variation\", legend=:bottomright)\nxlabel!(\"b (buffer size)\")\nylabel!(\"y [1/t]\")","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Buffer size and processing time variation have nonlinear effects and may account together for 26% line performance losses. This shows how important it is to increase buffer sizes with larger variation in processing times (smaller a). Only with small variation one can reduce buffers without loosing much performance.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(5, 20, 50)\ntmp = DataFrame(n=x, b=fill(mean(b), length(x)), a=fill(mean(a), length(x)),\n    σ=fill(mean(σ), length(x)))\nplot(x, predict(ols2, tmp), title=\"Effect of line length\", xlabel=\"n (line length)\",\n    ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"This may account for 3% performance losses.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"x = LinRange(0,0.1,50)\ntmp = DataFrame(n=fill(mean(n), length(x)), b=fill(mean(b), length(x)),\n    a=fill(mean(a), length(x)), σ=x)\nplot(x, predict(ols2, tmp), title=\"Effect of performance variation between workers\",\n    xlabel=L\"\\sigma\", ylabel=\"y [1/t]\", legend=:none)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"(Image: svg)","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Variation in performance between workers may diminish line throughput by other 5%.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The four effects combined can account for 34% performance losses from best to worst. This is most of the 35.8% we found above. The rest is mostly statistical fluctuations.","category":"page"},{"location":"examples/dicegame/dicegame/#Final-remark-1","page":"Goldratt's Dice Game","title":"Final remark","text":"","category":"section"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"Starting from a simple game and with only a quite small simulation model we could come to conclusions with a wide applicability for assembly lines. The performance differences in assembly lines are realistic – I have seen them over and over in industry. And we didn't yet account for failures or supply shortfalls. The unawareness of those simple factors costs manufacturing industry billions.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"The most interesting thing to note here is, that from seemingly quite unpredictable behaviour – look at the inventory chart of the beginning – emerge some quite predictable characteristics out of multiple discrete event simulations with parameter variation combined with some not too sophisticated statistics.","category":"page"},{"location":"examples/dicegame/dicegame/#","page":"Goldratt's Dice Game","title":"Goldratt's Dice Game","text":"We could not have done those experiments and analyses with real lines as it is possible with simulations on a modern computer with Julia and Simulate.jl.","category":"page"},{"location":"troubleshooting/#Troubleshooting-1","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Problems-1","page":"Troubleshooting","title":"Problems","text":"","category":"section"},{"location":"troubleshooting/#Process-startup-1","page":"Troubleshooting","title":"Process startup","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Under some environments (e.g. Jupyter) it may happen, that the processes have not started completely before the clock runs. In such cases it may help to put a little sleep, e.g. sleep!(0.1) between process!(…) and run!(…) to ensure that all started processes have enqueued for clock events.","category":"page"},{"location":"troubleshooting/#A-SimProcess-fails-1","page":"Troubleshooting","title":"A SimProcess fails","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"If c is your clock, you get the list of all running processes with c.processes. You  then look at the failed process with c.processes[id].task. This gives you the stack trace of the failed process, e.g.","category":"page"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"julia> 𝐶.processes\nDict{Any,SimProcess} with 2 entries:\n  2 => SimProcess(2, Task (failed) @0x000000010e467850, Idle(), clerk, Channel{…\n  1 => SimProcess(1, Task (failed) @0x000000010e467cd0, Idle(), people, Channel…\njulia> 𝐶.processes[1].task\nTask (failed) @0x000000010e467cd0\nMethodError: no method matching round(::Float64, ::Int64)\nClosest candidates are:\n  round(::Float64, ::RoundingMode{:Nearest}) at float.jl:370\n  round(::Float64, ::RoundingMode{:Up}) at float.jl:368\n  round(::Float64, ::RoundingMode{:Down}) at float.jl:366\n  ...\nlogevent(::Int64, ::Channel{Any}, ::String, ::Int64) at ./In[6]:12\npeople(::Channel{Any}, ::Channel{Any}, ::Float64) at ./In[17]:8\nloop(::SimProcess) at /Users/paul/.julia/packages/Simulate/BOeZP/src/process.jl:37\n(::getfield(Simulate, Symbol(\"##19#20\")){SimProcess})() at ./task.jl:268","category":"page"},{"location":"troubleshooting/#Report-1","page":"Troubleshooting","title":"Report","text":"","category":"section"},{"location":"troubleshooting/#","page":"Troubleshooting","title":"Troubleshooting","text":"Otherwise please report your problem and open an issue at https://github.com/pbayer/Simulate.jl.  ","category":"page"},{"location":"examples/singleserver/#Single-server-1","page":"Single server","title":"Single server","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This example is from Choi, Kang: Modeling and Simulation of Discrete-Event Systems, p. 18. It describes a single server system. The event graph given is:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: single server)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Initially there are no jobs in the queue Q and the machine M is idle.\nJobs arrive with an inter-arrival-time t_aand are added to Q.\nIf M is idle, it loads a job, changes to busy and executes the job with service time t_s.\nAfter that it changes to idle and, if Q is not empty, it loads the next job.","category":"page"},{"location":"examples/singleserver/#Implementing-it-1","page":"Single server","title":"Implementing it","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use this simple example for illustration of how it can be modeled, simulated and analyzed using Sim.jl. First we have to import the necessary modules:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"using Simulate, Random, Distributions, DataFrames, Plots, LaTeXStrings\npyplot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We have to define some data structures, variables and a function for collecting stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"abstract type MState end\n\nstruct Idle <: MState end\nstruct Busy <: MState end\n\nmutable struct Job\n    no::Int64\n    ts::Float64\n    t1::Float64\n    t2::Float64\n    t3::Float64\nend\n\nmutable struct Machine\n    state::MState\n    job\nend\n\nQ = Job[]   # input queue\nS = Job[]   # stock\nM = Machine(Idle(), 0)\ndf = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\ncount = 1\nprinting = true\n\nstats() = push!(df, (tau(), length(Q), M.state == Busy() ? 1 : 0, length(S)))","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can model our system activity-based und therefore implement functions for the three main activities (arrive, load, unload), which call each other during simulation.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We use the arrival-function for modeling arrival rate t_a with an Erlang and service time t_s with a Normal distribution. We determine the capacity of the server with a c variable such that c  1 gives us overcapacity and c = 1 means that mean service time equals mean arrival rate bart_s = bart_a.","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function arrive(μ, σ, c)\n    @assert μ ≥ 1 \"μ must be ≥ 1\"\n    ts = rand(Normal(μ, σ))/c\n    job = Job(count, ts, tau(), 0, 0)\n    global count += 1\n    push!(Q, job)\n    ta = rand(Erlang())*μ\n    event!(𝐶, SF(arrive, μ, σ, c), after, ta)  # we schedule the next arrival\n    printing ? println(tau(), \": job $(job.no) has arrived\") : nothing # tau() is the current time\n    if M.state == Idle()\n        load()\n    else\n        stats()\n    end\nend\n\nfunction load()\n    M.state = Busy()\n    M.job = popfirst!(Q)\n    M.job.t2 = tau()\n    event!(𝐶, SF(unload), after, M.job.ts)  # we schedule the unload\n    printing ? println(tau(), \": job $(M.job.no) has been loaded\") : nothing\n    stats()\nend\n\nfunction unload()\n    M.state = Idle()\n    M.job.t3 = tau()\n    push!(S, M.job)\n    printing ? println(tau(), \": job $(M.job.no) has been finished\") : nothing\n    stats()\n    M.job = 0\n    if !isempty(Q)\n        load()\n    end\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We want to collect stats() at a sample rate of 0.1:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"sample_time!(𝐶, 0.1)  # we determine the sample rate\nSim.sample!(𝐶, SF(stats));  # we register stats() as sampling function","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We assume now that the capacity equals the arrivals and provide no overcapacity.  Therefore  we start with one arrival and mu = 5, sigma = 15 and c = 1 and let our system run for 30 minutes (let's assume our time unit be minutes):","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Random.seed!(2019)\narrive(5, 1/5, 1)  # we schedule the first event\nrun!(𝐶, 30)        # and run the simulation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"This will give us as output:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"0: job 1 has arrived\n0: job 1 has been loaded\n4.947453062901819: job 1 has been finished\n8.515206032139384: job 2 has arrived\n8.515206032139384: job 2 has been loaded\n8.56975795472613: job 3 has arrived\n8.666481204359087: job 4 has arrived\n10.338522593089287: job 5 has arrived\n11.021099411385869: job 6 has arrived\n13.267881315092211: job 7 has arrived\n13.703372376147774: job 2 has been finished\n13.703372376147774: job 3 has been loaded\n18.726550601155594: job 3 has been finished\n18.726550601155594: job 4 has been loaded\n19.55941423914075: job 8 has arrived\n19.58302738045451: job 9 has arrived\n20.543366077813385: job 10 has arrived\n22.752994020639125: job 11 has arrived\n23.563550850400553: job 4 has been finished\n23.563550850400553: job 5 has been loaded\n23.960464112286694: job 12 has arrived\n26.84742108339802: job 13 has arrived\n28.18186102251928: job 5 has been finished\n28.18186102251928: job 6 has been loaded\n\"run! finished with 17 events, simulation time: 30.0\"","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Using our collected data, we can plot the simulation model trajectory:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function trajectory_plot()\n    p1 = plot(df.time, df.buffer, ylabel=\"buffer\", fill=(0,0.1,:blue))\n    p2 = plot(df.time, df.machine, ylabel=\"machine\", fill=(0,0.1,:blue))\n    p3 = plot(df.time, df.finished, xlabel=\"time [min]\", ylabel=\"stock\", fill=(0,0.1,:blue))\n    plot(p1,p2,p3, layout=(3,1), legend=false)\nend\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 1)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that the queue increases over time. Thus we are interested in the behaviour of our model over a longer time. Therefore we switch off printing and continue the simulation for further 970 \"minutes\".","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"printing = false\nrun!(𝐶, 970)        # we continue the simulation\ntrajectory_plot()","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: trajectory plot 2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"It seems that buffer size is increasing ever more over time. In the plot now machine load and stock aren't very instructive, so let's compare lead time W and number of jobs in the system L = textbuffer_size + textmachine_load:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"function WvsL() # get more instructive info from simulation run\n    t = [j.t1 for j ∈ S]\n    W = [j.t3 - j.t1 for j ∈ S]\n    ts = [j.t3 - j.t2 for j ∈ S]\n    subs = [i ∈ t for i ∈ df.time]\n    L = (df.buffer + df.machine)[subs]\n    l = df.machine[subs]\n    DataFrame(time=t, load=l, W=W, L=L, ts=ts)\nend\nd = WvsL()\nplot(d.time, d.W, label=\"W [min]\", xlabel=\"time [min]\", lw=2, legend=:topleft, title=\"L and W over time\")\nplot!(d.time, d.L, label=\"L [jobs]\", lw=2)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: L and W over time)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Lead time W and unfinished jobs L are clearly increasing, the system is not stationary and gets jammed over time. Let's collect some stats:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"collect_stats() =\n    (Lm = mean(d.L), Wm = mean(d.W), η = mean(df.machine), tsm = mean(d.ts))\ncollect_stats()\n(Lm = 16.21105527638191, Wm = 78.8196419189297, η = 0.9778719397363466, tsm = 5.003771234356064)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Server load of overlineη  98 is great, but the mean queue length overlineL of 16 and mean lead time overlineW  79 min are way too long for a service time of t_s  5 min. So let's analyze the dependency of mean queue length overlineL on server capacity c. For that we can manipulate the server capacity in the arrival function and collect the results in a table:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"df1 = DataFrame(c=Float64[], Lm=Float64[], Wm=Float64[], η=Float64[], tsm=Float64[])\nfor c ∈ collect(0.97:0.01:1.7)\n    global Q = Job[]   # input queue\n    global S = Job[]   # stock\n    global M = Machine(Idle(), 0)\n    global df = DataFrame(time = Float64[], buffer=Int[], machine=Int[], finished=Int[])\n    global count = 1\n\n    reset!(𝐶)                            # reset 𝐶\n    sample_time!(𝐶, 1)                   # set sample rate to 1\n    Sim.sample!(𝐶, SF(stats))   # register the stats() function for sampling\n\n    Random.seed!(2019)\n    arrive(5, 1/5, c)\n    run!(𝐶, 1000)                        # run another simulation for 1000 \"min\"\n    global d = WvsL()\n    s = collect_stats()\n    push!(df1, (c, s.Lm, s.Wm, s.η, s.tsm))\nend","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We can look at it in a scatter plot:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.c, df1.Wm, title=L\"\\overline{W}\"*\" and \"*L\"\\overline{L}\"*\" over server capacity\",\n    xlabel=\"server capacity\", marker = (:o, 3, 0.4, :blue), label=L\"\\overline{W}\"*\" [min]\")\nscatter!(df1.c, df1.Lm, marker = (:x, 4), label=L\"\\overline{L}\"*\" [jobs]\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: W and L over server capacity)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"We need to increase server capacity much in order to avoid long queues and waiting times.","category":"page"},{"location":"examples/singleserver/#How-about-Little's-law?-1","page":"Single server","title":"How about Little's law?","text":"","category":"section"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"overlineW and overlineL seem to be proportional. This is stated by Little's law:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"beginequation\nL = lambdatimes W\nendequation","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"for stationary systems with lambda = arrival rate. In our case lambda = t_a = 5. Let's look at it:","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"scatter(df1.Lm, df1.Wm, xlabel=L\"\\overline{L}\"*\" [jobs]\", ylabel=L\"\\overline{W}\"*\" [min]\",\n    marker = (:o, 4, 0.4, :blue), label=\"data\", title=\"Little's law\", legend=:topleft)\nplot!(df1.Lm, df1.Lm*5, label=\"theory \"*L\"(\\overline{L}\\times 5)\")","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"(Image: Little's law)","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"Data seems not quite to fit theory. Reason is that the system is not stationary. But for a first approach, Little's law seems not to be a bad one. In order to analyze stability and stationarity and to improve, we could refine our analysis by taking only the second half of the simulation data or by doing more simulation runs and having some more fun with Simulate.jl ...","category":"page"},{"location":"examples/singleserver/#","page":"Single server","title":"Single server","text":"See also: tau, 𝐶, SF, event!, run!, reset!","category":"page"},{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#Installation-1","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = Simulate","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Simulate.jl runs on Julia versions ≥ v\"1.0\" [1]. The current stable, registered version is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add Simulate","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The development version is installed with:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/Simulate.jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using Simulate","category":"page"},{"location":"usage/#The-clock-1","page":"Usage","title":"The clock","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Clock","category":"page"},{"location":"usage/#Simulate.Clock","page":"Usage","title":"Simulate.Clock","text":"Clock(Δt::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)\n\nCreate a new simulation clock.\n\nArguments\n\nΔt::Number=0: time increment. If no Δt is given, the simulation doesn't tick,   but jumps from event to event. Δt can be set later with sample_time!.\nt0::Number=0: start time for simulation\nunit::FreeUnits=NoUnits: clock time unit. Units can be set explicitely by   setting e.g. unit=minute or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. t0=60s.\n\nFields\n\nstate::SState: clock state\ntime::Float64: clock time\nunit::FreeUnits: time unit\nevents::PriorityQueue{SimEvent,Float64}: scheduled events\ncevents::Array{SimCond,1}: conditional events\nprocesses::Dict{Any, SimProcess}: registered processes\nend_time::Float64: end time for simulation\nevcount::Int64: event counter\nscount::Int64: sample count\ntev::Float64: next event time\nΔt::Float64: sampling time, timestep between ticks\nsexpr::Array{Sample,1}: sampling expressions to evaluate at each tick\ntsa::Float64: next sample time\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> c = Clock()                 # create a unitless clock (standard)\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> init!(c)                    # initialize it explicitly (normally done implicitly)\nSimulate.Idle()\n\njulia> c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically\nClock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.016666666666666666\n\njulia> c = Clock(1s)               # create a clock with implicit unit setting\nClock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0\n\njulia> c = Clock(t0=60s)           # another example of implicit unit setting\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> c = Clock(1s, t0=1hr)       # if given times with different units, Δt takes precedence\nClock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The central clock  is 𝐶. You can set time units and query the current simulation time.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"𝐶\nsetUnit!\ntau(::Clock)\n@tau(::Clock)","category":"page"},{"location":"usage/#Simulate.𝐶","page":"Usage","title":"Simulate.𝐶","text":"𝐶\nClk\n\n𝐶 (𝐶 = \\itC+tab) or Clk is the central simulation clock. If you do one simulation at a time, you can use 𝐶 or Clk for time keeping.\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\n\njulia> 𝐶  # central clock\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> 𝐶 === Clk\ntrue\n\n\n\n\n\n\n","category":"constant"},{"location":"usage/#Simulate.setUnit!","page":"Usage","title":"Simulate.setUnit!","text":"setUnit!(sim::Clock, new::FreeUnits)\n\nset a clock to a new time unit in Unitful. If necessary convert current clock times to the new unit.\n\nArguments\n\nsim::Clock\nnew::FreeUnits: new is one of ms, s, minute or hr or another Unitful   Time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: Time, s, minute, hr\n\njulia> c = Clock(t0=60)     # setup a new clock with t0=60\nClock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> tau(c) # current time is 60.0 NoUnits\n60.0\n\njulia> setUnit!(c, s)       # set clock unit to Unitful.s\n60.0 s\n\njulia> tau(c) # current time is now 60.0 s\n60.0 s\n\njulia> setUnit!(c, minute)  # set clock unit to Unitful.minute\n1.0 minute\n\njulia> tau(c)               # current time is now 1.0 minute\n1.0 minute\n\njulia> typeof(tau(c))       # tau(c) now returns a time Quantity ...\nQuantity{Float64,𝐓,Unitful.FreeUnits{(minute,),𝐓,nothing}}\n\njulia> isa(tau(c), Time)\ntrue\n\njulia> uconvert(s, tau(c))  # ... which can be converted to other time units\n60.0 s\n\njulia> tau(c).val           # it has a value of 1.0\n1.0\n\njulia> c.time               # internal clock time is set to 1.0 (a Float64)\n1.0\n\njulia> c.unit               # internal clock unit is set to Unitful.minute\nminute\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.tau-Tuple{Clock}","page":"Usage","title":"Simulate.tau","text":"tau(sim::Clock=𝐶)\nτ(sim::Clock=𝐶)\n\nReturn the current simulation time (τ = \\tau+tab).\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\njulia> tau() # gives the central time\n0.0\njulia> τ() # alias, gives the central time\n0.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.@tau-Tuple{Clock}","page":"Usage","title":"Simulate.@tau","text":"@tau(sim::Clock)\n@tau sim\n@tau()\n@tau\n\nreturn the current simulation time.\n\nArguments\n\nsim::Clock: if no clock argument is given, it returns 𝐶's time.\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Events-1","page":"Usage","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Events are scheduled on the clock's timeline and are triggered at a given simulation time or under conditions which may become true during simulation.","category":"page"},{"location":"usage/#Expressions-and-functions-as-events-and-conditions-1","page":"Usage","title":"Expressions and functions as events and conditions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Julia expressions and functions can be scheduled as events.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Timing\nSimFunction\n@SF\nSimExpr","category":"page"},{"location":"usage/#Simulate.Timing","page":"Usage","title":"Simulate.Timing","text":"Timing\n\nEnumeration type for scheduling events and timed conditions:\n\nat: schedule an event at a given time,\nafter: schedule an event a given time after current time,\nevery: schedule an event every given time from now on,\nbefore: a timed condition is true before a given time,\nuntil: delay until t.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.SimFunction","page":"Usage","title":"Simulate.SimFunction","text":"SimFunction(func::Function, arg...; kw...)\nSF(func::Function, arg...; kw...)\n\nPrepare a function for being called as an event in a simulation.\n\nArguments, fields\n\nfunc::Function: function to be executed at a later simulation time\narg...: arguments to the function\nkw...: keyword arguments\n\nnote: Note\nIf the variables stored in a SimFunction are composite types, they can change until they are evaluated later by func.\n\nExample\n\njulia> using Simulate\n\njulia> f(a,b,c; d=4, e=5) = a+b+c+d+e       # if you define a function and ...\nf (generic function with 1 method)\n\njulia> sf = SF(f, 10, 20, 30, d=14, e=15);  # store it as SimFunction\n\njulia> sf.func(sf.arg...; sf.kw...)         # it can be executed later\n89\n\njulia> d = Dict(:a => 1, :b => 2);          # we set up a dictionary\n\njulia> g(t) = t[:a] + t[:b]                 # and a function adding :a and :b\ng (generic function with 1 method)\n\njulia> g(d)                                 # our add function gives 3\n3\n\njulia> ff = SimFunction(g, d);              # we set up a SimFunction\n\njulia> d[:a] = 10;                          # later somehow we change d\n\njulia> ff.func(ff.arg...)                   # calling ff then gives a different result\n12\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.@SF","page":"Usage","title":"Simulate.@SF","text":"@SF(f::Symbol, arg...)\n@SF f arg...\n\ncreate a SimFunction from arguments f, arg...\n\nArguments\n\nf::Symbol: a function given as a symbol, e.g. :f if f() is your function,\narg...: further arguments to your function\n\nnote: Note\nkeyword arguments don't work with this macro, use SF instead.\nif you give @SF as argument(s) to a function, you must enclose it/them  in parentheses ( @SF ... ) or ( (@SF ...), (@SF ...) )\n\nExamples\n\njulia> using Simulate\n\njulia> a = 1\n1\njulia> incra() = global a += 1             # create a simple increment function\nincra (generic function with 1 method)\n\njulia> event!((@SF incra), after, 3);      # schedule an increment after 3 time units\n\njulia> a                                   # nothing happened to a\n1\n\njulia> run!(𝐶, 5)                          # run the simulation\n\"run! finished with 1 clock events, 0 sample steps, simulation time: 5.0\"\n\njulia> a                                   # now it should have been incremented\n2\n\njulia> event!((@SF incra), (@tau :>= 8));  # schedule a conditional event\n\njulia> run!(𝐶, 5)\n\"run! finished with 0 clock events, 301 sample steps, simulation time: 10.0\"\n\njulia> a                                   # the conditional event was triggered\n3\n\njulia> event!(((@SF incra), (@SF incra)),  # two increments\n        ((@tau :>= 12), (@val :a :<= 3))); # on two conditions\n\njulia> run!(𝐶, 5)\n\"run! finished with 0 clock events, 201 sample steps, simulation time: 15.0\"\n\njulia> a                                   # two increments happened\n5\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.SimExpr","page":"Usage","title":"Simulate.SimExpr","text":"SimExpr = Union{Expr, SimFunction}\n\nA type which is either a SimFunction or Julia expression, Expr-type.\n\n\n\n\n\n","category":"constant"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimFunctions and expressions can be given to events on their own or in arrays or tuples, even mixed:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"function events()\n    event!(:(i += 1), after, 10)  # one expression\n    event!(SF(f, 1, 2, 3, diff=pi), every, 1)  # one SimFunction\n    event!((:(i += 1), SF(g, j)), [:(tau() ≥ 50), SF(isready, input), :(a ≤ 10)]) # two SimExpr under three conditions\nend","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"All given expressions or functions are then evaluated at a given simulation time or when during simulation the given conditions become true.","category":"page"},{"location":"usage/#Timed-events-1","page":"Usage","title":"Timed events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimFunctions and expressions can be scheduled for execution at given clock times.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Number)","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Number}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)::Float64\nevent!(ex::Union{SimExpr, Array, Tuple}, t::Number; scope::Module=Main, cycle::Number=0.0)\n\nSchedule an event for a given simulation time.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to 𝐶,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\nt::Real or t::Time: simulation time, if t < sim.time set t = sim.time,\nscope::Module=Main: scope for expressions to be evaluated in,\ncycle::Float64=0.0: repeat cycle time for an event.\n\nreturns\n\nScheduled internal simulation time (unitless) for that event. May return a time > t from repeated applications of nextfloat(t) if there are events scheduled for t.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\n\njulia> event!(𝐶, SimFunction(myfunc, 1, 2), 1) # a 1st event to 1\n1.0\njulia> event!(𝐶, SimFunction(myfunc, 2, 3), 1) #  a 2nd event to the same time\n1.0000000000000002\n\njulia> event!(𝐶, SimFunction(myfunc, 3, 4), 1s)\nWarning: clock has no time unit, ignoring units\n1.0000000000000004\n\njulia> setUnit!(𝐶, s)\n0.0 s\n\njulia> event!(𝐶, SimFunction(myfunc, 4, 5), 1minute)\n60.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"As a convenience the Timing can be also choosen using at, after or every t.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Timing, ::Number)","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Timing,Number}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)::Float64\nevent!(ex::Union{SimExpr, Array, Tuple}, T::Timing, t::Number; scope::Module=Main)\n\nSchedule a timed event, that is an event with a timing.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to 𝐶,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\nT::Timing: a timing, at, after or every (before behaves like at),\nt::Float64 or t::Time: simulation time,\nscope::Module=Main: scope for the expressions to be evaluated\n\nreturns\n\nScheduled internal simulation time (unitless) for that event.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s, minute, hr\n\njulia> setUnit!(𝐶, s)\n0.0 s\n\njulia> myfunc(a, b) = a+b\nmyfunc (generic function with 1 method)\n\njulia> event!(𝐶, SimFunction(myfunc, 5, 6), after, 1hr)\n3600.0\n\n\n\n\n\n","category":"method"},{"location":"usage/#Conditional-events-1","page":"Usage","title":"Conditional events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"They are evaluated at each clock tick (like sampling functions) and are fired when all conditions are met.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"event!(::Clock, ::Union{SimExpr, Array, Tuple}, ::Union{SimExpr, Array, Tuple})","category":"page"},{"location":"usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array},Union{Expr, Tuple, SimFunction, Array}}","page":"Usage","title":"Simulate.event!","text":"event!(sim::Clock, ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main):\nevent!(ex::Union{SimExpr, Array, Tuple}, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\n\nSchedule a conditional event.\n\nIt is executed immediately if the conditions are met, else the condition is checked at each clock tick Δt. A conditional event is triggered only once. After that it is removed from the clock. If no sampling rate Δt is setup, a default sampling rate is setup depending on the scale of the remaining simulation time Δt = scale(t_r)100 or 001 if t_r = 0.\n\nArguments\n\nsim::Clock: simulation clock, if no clock is given, the event goes to 𝐶,\nex::{SimExpr, Array, Tuple}: an expression or SimFunction or an array or tuple of them,\ncond::{SimExpr, Array, Tuple}: a condition is an expression or SimFunction   or an array or tuple of them. It is true only if all expressions or SimFunctions   therein return true,\nscope::Module=Main: scope for the expressions to be evaluated\n\nreturns\n\ncurrent simulation time tau(sim).\n\nExamples\n\njulia> using Simulate\n\njulia> c = Clock()   # create a new clock\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\njulia> event!(c, SF((x)->println(tau(x), \": now I'm triggered\"), c), (@tau c :>= 5))\n0.0\n\njulia> c             # a conditional event turns sampling on\nClock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 1, processes: 0, sampling: 0, sample rate Δt=0.01\n\njulia> run!(c, 10)   # sampling is not exact, so it takes 501 sample steps to fire the event\n5.009999999999938: now I'm triggered\n\"run! finished with 0 clock events, 501 sample steps, simulation time: 10.0\"\n\nAfter the event is triggered, sampling is again switched off.\n\n\n\n\n\n","category":"method"},{"location":"usage/#","page":"Usage","title":"Usage","text":"note: Note\nSince conditions often are not met exactly you should prefer inequalities like <, ≤, ≥, > to equality == in order to get sure that a fulfilled condition can be detected, e.g. (tau()  100) is preferable to (tau() == 100).","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"There are some helper functions and macros for defining conditions. It is usually more convenient to use the macros since the generate the necessary SimFunctions directly:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"tau(::Clock, ::Function, ::Union{Number,Symbol})\n@tau(::Any, ::QuoteNode, ::Union{Number, QuoteNode})\nval\n@val","category":"page"},{"location":"usage/#Simulate.tau-Tuple{Clock,Function,Union{Number, Symbol}}","page":"Usage","title":"Simulate.tau","text":"tau(sim::Clock, check::Function, x::Union{Number,Symbol}; m::Module=Main)\ntau(check::Function, x::Union{Number,Symbol}; m::Module=Main)\n\nCompare the current simulation time against a number or a variable.\n\nArguments\n\nsim::Clock: clock variable, if not given, it is 𝐶.\ncheck::Function: a comparison operator like ≥, >, ==, <, ≤,\nx::Union{Number,Symbol}: a number or a symbolic variable like :a, a   symbolic variable can be evaluated later at event time,\nm::Module=Main: the evaluation scope, if a symbolic variable is given.\n\nExamples\n\njulia> using Simulate\n\njulia> tau(>=, 1)\nfalse\n\njulia> tau(<, 1)\ntrue\n\njulia> a = 1\n1\n\njulia> tau(<=, :a, @__MODULE__)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.@tau-Tuple{Any,QuoteNode,Union{Number, QuoteNode}}","page":"Usage","title":"Simulate.@tau","text":"@tau(sim::Clock, check::Symbol, val)\n@tau sim check val\n@tau(check::Symbol, val)\n@tau check val\n\ncreate a SimFunction comparing current simulation time with a given value or variable.\n\nArguments\n\nsim::Clock: if no clock is given, it compares with 𝐶's time,\ncheck::Symbol: the check operator must be given as a symbol e.g. :<,\nval::Union{Number, QuoteNode}: a value or a symbolic variable,\n\nnote: Note\nIf you give @tau as argument(s) to a function, you must enclose it/them in parentheses ( @tau ... ) or ( (@tau ...), (@tau ...) )!\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\njulia> sf = @tau :≥ 100;\n\njulia> Simulate.simExec(sf)\nfalse\n\njulia> Simulate.simExec(@tau < 100)                ### wrong !!\nERROR: syntax: \"<\" is not a unary operator\n\njulia> Simulate.simExec(@tau :< 100)               ### correct\ntrue\n\njulia> a = 1\n1\n\njulia> Simulate.simExec(@tau :< :a)\ntrue\n\njulia> event!(SF(()->global a+=1), (@tau :>= 3))   ### create a conditional event\n0.0\n\njulia> a\n1\n\njulia> run!(𝐶, 5)                                  ### run\n\"run! finished with 0 clock events, 301 sample steps, simulation time: 5.0\"\n\njulia> a\n2\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.val","page":"Usage","title":"Simulate.val","text":"val(a::Union{Number, Symbol}, check::Function, x::Union{Number, Symbol}, m::Module=Main)\n\nCompare two variables or numbers.\n\nArguments\n\na, xUnion{Number, Symbol}: a number or a symbolic variable like :a, a   symbolic variable can be evaluated later at event time,\ncheck::Function: a comparison operator like ≥, >, ==, <, ≤,\nm::Module=Main: the evaluation scope, if a symbolic variable is given.\n\nExamples\n\njulia> using Simulate\n\njulia> val(1, <=, 2)\ntrue\n\njulia> a = 1\n1\n\njulia> val(:a, <=, 2, @__MODULE__)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.@val","page":"Usage","title":"Simulate.@val","text":"@val(a, check::QuoteNode, b)\n@val a check b\n\nCreate a Simfunction comparing two values a and b or two symbolic variables :a and :b. The comparison operator must be given symbolically, e.g. :≤.\n\nArguments\n\na, b:: a number, expression or symbol\ncheck::QuoteNode: a comparison operator as a symbol like :> or :≤\n\nnote: Note\nIf you give @val as argument(s) to a function, you must enclose it/them in parentheses ( @val ... ) or e.g. ( (@tau ...), (@val ...) )!\n\nExamples\n\njulia> using Simulate\n\njulia> reset!(𝐶)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\n\njulia> Simulate.simExec(@val 1 :≤ 2)\ntrue\n\njulia> a = 1\n1\n\njulia> Simulate.simExec(@val :a :≤ 2)\ntrue\n\njulia> event!(SF(()->global a+=1), ((@tau :>= 3), (@val :a :<= 3))); # a conditional event\n\njulia> run!(𝐶, 5)\n\"run! finished with 0 clock events, 301 sample steps, simulation time: 5.0\"\n\njulia> a\n2\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Processes-1","page":"Usage","title":"Processes","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Julia functions can be registered and run as processes if they have an input and an output channel as their first two arguments. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"SimProcess\n@SP\nSimException\nprocess!\ninterrupt!\nstop!(::SimProcess, ::SEvent)","category":"page"},{"location":"usage/#Simulate.SimProcess","page":"Usage","title":"Simulate.SimProcess","text":"SimProcess( id, func::Function, arg...; kw...)\nSP(id, func::Function, arg...; kw...)\n\nPrepare a function to run as a process in a simulation.\n\nArguments, fields\n\nid: some unique identification, it should get registered with\nfunc::Function: a function f(arg...; kw...)\narg...: further arguments to f\nkw...: keyword arguments to f\n\nnote: Note\nA function as a SimProcess most often runs in a loop. It has to give back control by e.g. doing a take!(input) or by calling delay! etc., which will yield it. Otherwise it will starve everything else!\n\nExamples\n\njulia> using Simulate\n\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.@SP","page":"Usage","title":"Simulate.@SP","text":"@SP(id, f::Symbol, arg...)\n@SP id f arg...\n\ncreate a SimProcess from arguments f, arg...\n\nnote: Note\nkeyword arguments don't work with this macro, use SP instead.\n\n\n\n\n\n","category":"macro"},{"location":"usage/#Simulate.SimException","page":"Usage","title":"Simulate.SimException","text":"SimException(ev::SEvent, value=nothing)\n\nDefine a SimException, which can be thrown to processes.\n\nArguments, fields\n\nev::SEvent: delivers an event to the interrupted task\nvalue=nothing: deliver some other value\n\n\n\n\n\n","category":"type"},{"location":"usage/#Simulate.process!","page":"Usage","title":"Simulate.process!","text":"process!(sim::Clock, p::SimProcess, cycles=Inf)\nprocess!(p::SimProcess, cycles=Inf)\n\nRegister a SimProcess to a clock, start it as an asynchronous process and return the id it was registered with. It can then be found under sim.processes[id].\n\nArguments\n\nsim::Clock: clock, if no clock is given, it runs under 𝐶,\np::SimProcess\ncycles::Number=Inf: number of cycles the process should run.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.interrupt!","page":"Usage","title":"Simulate.interrupt!","text":"interrupt!(p::SimProcess, ev::SEvent, value=nothing)\n\nInterrupt a SimProcess by throwing a SimException to it.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{SimProcess,Simulate.SEvent}","page":"Usage","title":"Simulate.stop!","text":"Stop a SimProcess\n\n\n\n\n\n","category":"method"},{"location":"usage/#Delay-and-wait-…-1","page":"Usage","title":"Delay and wait …","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Processes must not handle their events explicitly, but can call delay! or wait! or take! and put! … on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"delay!\nwait!","category":"page"},{"location":"usage/#Simulate.delay!","page":"Usage","title":"Simulate.delay!","text":"delay!(sim::Clock, t::Number)\ndelay!(t::Number)\n\nDelay a process for a time interval t on the clock sim. Suspend the calling process until being reactivated by the clock at the appropriate time.\n\nArguments\n\nsim::Clock: clock, if no clock is given, the delay goes to 𝐶.\nt::Number: the time interval for the delay.\n\n\n\n\n\ndelay!(sim::Clock, T::Timing, t::Number)\ndelay!(T::Timing, t::Number)\n\nUsed for delaying a process until a given time t.\n\nArguments\n\nsim::Clock: if no clock is given, the delay goes to 𝐶,\nT::Timing: only until is accepted,\nt::Number: delay until time t if t > sim.time, else give a warning.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.wait!","page":"Usage","title":"Simulate.wait!","text":"wait!(sim::Clock, cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\nwait!(cond::Union{SimExpr, Array, Tuple}; scope::Module=Main)\n\nWait on a clock for a condition to become true. Suspend the calling process until the given condition is true.\n\nArguments\n\nsim::Clock: clock, if no clock is given, the delay goes to 𝐶.\ncond::Union{SimExpr, Array, Tuple}: a condition is an expression or SimFunction   or an array or tuple of them. It is true only if all expressions or SimFunctions   therein return true.\nscope::Module=Main: evaluation scope for given expressions\n\n\n\n\n\n","category":"function"},{"location":"usage/#Now-1","page":"Usage","title":"Now","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"If processes want IO-operations to finish before letting the clock proceed, they can enclose those operations in a now! call.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"now!","category":"page"},{"location":"usage/#Simulate.now!","page":"Usage","title":"Simulate.now!","text":"now!(sim::Clock, op::Union{SimExpr, Array, Tuple})\nnow!(op::Union{SimExpr, Array, Tuple})\n\nLet the given operation be executed now! by the clock. Thus the clock cannot proceed before the op is finished.\n\nArguments\n\nsim::Clock:\nop::Union{SimExpr, Array, Tuple}:\n\n\n\n\n\n","category":"function"},{"location":"usage/#Continuous-sampling-1","page":"Usage","title":"Continuous sampling","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Functions or expressions can register for sampling and are then executed \"continuously\" at each clock increment Δt.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sample_time!\nsample!","category":"page"},{"location":"usage/#Simulate.sample_time!","page":"Usage","title":"Simulate.sample_time!","text":"sample_time!(sim::Clock, Δt::Number)\nsample_time!(Δt::Number)\n\nset the clock's sample rate starting from now (tau(sim)).\n\nArguments\n\nsim::Clock: if no clock is given, set the sample rate on 𝐶,\nΔt::Number: sample rate, time interval for sampling\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sample!","page":"Usage","title":"Simulate.sample!","text":"sample!(sim::Clock, ex::Union{Expr, SimFunction}, Δt::Number=sim.Δt; scope::Module=Main)\nsample!(ex::Union{Expr, SimFunction}, Δt::Number=sim.Δt; scope::Module=Main)\n\nenqueue an expression for sampling.\n\nArguments\n\nsim::Clock: if no clock is given, it samples on 𝐶,\nex::Union{Expr, SimFunction}: an expression or function,\nΔt::Number=sim.Δt: set the clock's sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,\nscope::Module=Main: optional, an evaluation scope for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Running-simulations-1","page":"Usage","title":"Running simulations","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed … Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"reset!\nincr!\nrun!\nstop!(::Clock)\nresume!\nsync!","category":"page"},{"location":"usage/#Simulate.reset!","page":"Usage","title":"Simulate.reset!","text":"reset!(sim::Clock, Δt::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)\n\nreset a clock\n\nArguments\n\nsim::Clock\nΔt::Number=0: time increment\nt0::Float64=0 or t0::Time: start time\nhard::Bool=true: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.\nunit=NoUnits: the Time unit for the clock after reset. If a Δt::Time is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.\n\nExamples\n\njulia> using Simulate, Unitful\n\njulia> import Unitful: s\n\njulia> c = Clock(1s, t0=60s)\nClock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=1.0\n\njulia> reset!(c)\n\"clock reset to t₀=0.0, sampling rate Δt=0.0.\"\n\njulia> c\nClock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Δt=0.0\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.incr!","page":"Usage","title":"Simulate.incr!","text":"incr!(sim::Clock)\n\nTake one simulation step, execute the next tick or event.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.run!","page":"Usage","title":"Simulate.run!","text":"run!(sim::Clock, duration::Number)\n\nRun a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.stop!-Tuple{Clock}","page":"Usage","title":"Simulate.stop!","text":"stop!(sim::Clock)\n\nStop a running simulation.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Simulate.resume!","page":"Usage","title":"Simulate.resume!","text":"resume!(sim::Clock)\n\nResume a halted simulation.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.sync!","page":"Usage","title":"Simulate.sync!","text":"sync!(sim::Clock, to::Clock=𝐶)\n\nForce a synchronization of two clocks. Change all registered times of sim accordingly. Convert or force sim.unit to to.unit.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Logging-1","page":"Usage","title":"Logging","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A Logger allows to register variables and to record their states on demand. The last record is stored in the logging variable. According to the Logger's state it can be printed or stored in a table.","category":"page"},{"location":"usage/#Example-1","page":"Usage","title":"Example","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"sim = Clock(); # create a clock\nl = Logger(); # create a logging variable\ninit!(l, sim); # initialize the logger\n(a, b, c) = 1, 1, 1 # create some variables\nsetup!(l, [:a, :b, :c], scope = m); # register them for logging\nrecord!(l) # record the variables with the current clock time\nl.last # show the last record\nfunction f()  # a function for increasing and recording the variables\n  global a += 1\n  global b = a^2\n  global c = a^3\n  record!(l)\nend\nswitch!(l, 1); # switch logger to printing\nf() # increase and record the variables\nswitch!(l, 2); # switch logger to storing in data table\nfor i in 1:10 # create some events\n    event!(sim, :(f()), i, scope = m)\nend\nrun!(sim, 10) # run a simulation\nl.df # view the recorded values","category":"page"},{"location":"usage/#Types-1","page":"Usage","title":"Types","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Logger","category":"page"},{"location":"usage/#Simulate.Logger","page":"Usage","title":"Simulate.Logger","text":"Logger()\n\nSetup and return a logging variable.\n\n\n\n\n\n","category":"type"},{"location":"usage/#Functions-1","page":"Usage","title":"Functions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"init!\nsetup!\nswitch!\nrecord!\nclear!","category":"page"},{"location":"usage/#Simulate.init!","page":"Usage","title":"Simulate.init!","text":"init!(sim::Clock)\n\ninitialize a clock.\n\n\n\n\n\ninit!(L::Logger, sim::Clock)\n\nInitialize a Logger.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.setup!","page":"Usage","title":"Simulate.setup!","text":"setup!(L::Logger, vars::Array{Symbol})\n\nSetup a logger with logging variables.\n\nArguments\n\nL::Logger\nvars::Array{Symbol}: An array of symbols, e.g. of global variables\nscope::Module = Main: Scope in which to evaluate the variables\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.switch!","page":"Usage","title":"Simulate.switch!","text":"switch!(L::Logger, to::Number=0)\n\nSwitch the operating mode of a logger.\n\nto = 0: no output, to = 1: print, `to = 2: store in log table\"\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.record!","page":"Usage","title":"Simulate.record!","text":"record!(L::Logger)\n\nrecord the logging variables with the current operating mode.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Simulate.clear!","page":"Usage","title":"Simulate.clear!","text":"clear!(L::Logger)\n\nclear the loggers last record and data table.\n\n\n\n\n\n","category":"function"},{"location":"usage/#","page":"Usage","title":"Usage","text":"[1]: currently builds fail on x86 machines with Julia 1.0, Appveyor is set to allow this. There is an issue in the repo, maybe someone can look into it or fix it.","category":"page"},{"location":"approach/#Approaches-to-modeling-and-simulation-1","page":"Building models","title":"Approaches to modeling and simulation","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Simulate.jl supports different approaches to modeling and simulation of discrete event systems (DES). It provides three major schemes: 1) an event-scheduling scheme, 2) a process-oriented scheme and 3) continuous sampling. With them different modeling strategies can be applied.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"A problem can be expressed differently through various modeling approaches. A simple problem can illustrate this :","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"A server takes something from an input, processes it for some time and puts it out to an output. There are 8 servers in the system, 4 foos and 4 bars interacting with each other via two channels.","category":"page"},{"location":"approach/#Event-based-modeling-1","page":"Building models","title":"Event based modeling","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"In this view events occur in time and trigger further events. Here the three server actions are seen as events and can be described in an event graph:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"(Image: event graph)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"You define a data structure for the server, provide functions for the three actions, create channels and servers and start:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation to take\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\nfunction take(S::Server)\n    if isready(S.input)\n        S.token = take!(S.input)\n        @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n        event!(SF(put, S), after, rand())         # call put after some time\n    else\n        event!(SF(take, S), SF(isready, S.input)) # call again if input is ready\n    end\nend\n\nfunction put(S::Server)\n    put!(S.output, S.op(S.id, S.token))\n    S.token = nothing\n    take(S)\nend\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    take(Server(s[i], \"foo\", ch1, ch2, +))\n    take(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"julia> include(\"docs/examples/channels1.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"see: tau, event!, SF, reset!, 𝐶, run!","category":"page"},{"location":"approach/#State-based-modeling-1","page":"Building models","title":"State based modeling","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Here the server has three states: Idle, Busy and End (where End does nothing). On an arrival event it resets its internal clock x=0 and determines the service time t_s, moves to Busy, works on its input and puts it out when t_s is over. Then it goes back to Idle. A state transition diagram (Mealy model) of the timed automaton would look like:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"(Image: timed automaton)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Again you need a data structure for the server (state …). You define states and events and implement a δ transition function with two methods. Thereby you dispatch on states and events. Since you don't need to implement all combinations of states and events, you may implement a fallback transition.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"using Simulate, Printf, Random\n\nabstract type Q end  # states\nstruct Idle <: Q end\nstruct Busy <: Q end\nabstract type Σ end  # events\nstruct Arrive <: Σ end\nstruct Leave <: Σ end\n\nmutable struct Server\n    id::Int64\n    name::AbstractString\n    input::Channel\n    output::Channel\n    op     # operation to take\n    state::Q\n    token  # current token\n\n    Server(id, name, input, output, op) = new(id, name, input, output, op, Idle(), nothing)\nend\n\narrive(A) = event!(SF(δ, A, A.state, Arrive()), SF(isready, A.input))\n\nfunction δ(A::Server, ::Idle, ::Arrive)\n    A.token = take!(A.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), A.name, A.id, A.token)\n    A.state=Busy()\n    event!(SF(δ, A, A.state, Leave()), after, rand())\nend\n\nfunction δ(A::Server, ::Busy, ::Leave)\n    put!(A.output, A.op(A.id,A.token))\n    A.state=Idle()\n    arrive(A)\nend\n\nδ(A::Server, q::Q, σ::Σ) =               # fallback transition\n        println(stderr, \"$(A.name) $(A.id) undefined transition $q, $σ\")\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"julia> include(\"docs/examples/channels2.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n ...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"see: tau, event!, SF, reset!, 𝐶, run!","category":"page"},{"location":"approach/#Activity-based-modeling-1","page":"Building models","title":"Activity based modeling","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"The server's activity is the processing of the token. A timed Petri net would look like:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"(Image: timed petri net)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"The arrive \"transition\" puts a \"token\" in the Queue. If both \"places\" Idle and Queue have tokens, the server takes them, shifts one to Busy and puts out two after a timed transition with delay v_put. Then it is Idle again and the cycle restarts.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"The server's activity is described by the blue box. Following the Petri net, you should implement a state variable with states Idle and Busy, but you don't need to if you separate the activities in time. You need a data structure for the server and define a function for the activity:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"using Simulate, Printf, Random\n\nmutable struct Server\n  id::Int64\n  name::AbstractString\n  input::Channel\n  output::Channel\n  op     # operation\n  token  # current token\n\n  Server(id, name, input, output, op) = new(id, name, input, output, op, nothing)\nend\n\narrive(S::Server) = event!(SF(serve, S), SF(isready, S.input))\n\nfunction serve(S::Server)\n    S.token = take!(S.input)\n    @printf(\"%5.2f: %s %d took token %d\\n\", tau(), S.name, S.id, S.token)\n    event!((SF(put!, S.output, S.op(S.id, S.token)), SF(arrive, S)), after, rand())\nend\n\nreset!(𝐶)\nRandom.seed!(123)\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\ns = shuffle(1:8)\nfor i in 1:2:8\n    arrive(Server(s[i], \"foo\", ch1, ch2, +))\n    arrive(Server(s[i+1], \"bar\", ch2, ch1, *))\nend\n\nput!(ch1, 1) # put first token into channel 1\n\nrun!(𝐶, 10)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"julia> include(\"docs/examples/channels3.jl\")\n 0.01: foo 4 took token 1\n 0.12: bar 6 took token 5\n 0.29: foo 1 took token 30\n 0.77: bar 8 took token 31\n 1.64: foo 2 took token 248\n 2.26: bar 3 took token 250\n ...\n 6.70: bar 5 took token 545653\n 6.91: foo 4 took token 2728265\n 7.83: bar 6 took token 2728269\n 8.45: foo 1 took token 16369614\n 9.26: bar 8 took token 16369615\n 9.82: foo 2 took token 130956920\n\"run! finished with 20 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"see: tau, event!, SF, reset!, 𝐶, run!","category":"page"},{"location":"approach/#Process-based-modeling-1","page":"Building models","title":"Process based modeling","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Here you combine it all in a simple function of take!-delay!-put! like in the activity based example, but running in the loop of a process. Processes can wait or delay and are suspended and reactivated by Julia's scheduler according to background events. There is no need to handle events explicitly and no need for a server data type since a process keeps its own data. Processes must look careful to their timing and therefore you must enclose the IO-operation in a now! call:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"function simple(input::Channel, output::Channel, name, id, op)\n    token = take!(input)         # take something, eventually wait for it\n    now!(SF(println, @sprintf(\"%5.2f: %s %d took token %d\", tau(), name, id, token)))\n    d = delay!(rand())           # wait for a given time\n    put!(output, op(token, id))  # put something else out, eventually wait\nend\n\nch1 = Channel(32)  # create two channels\nch2 = Channel(32)\n\nfor i in 1:2:8    # create and register 8 SimProcesses\n    process!(SP(i, simple, ch1, ch2, \"foo\", i, +))\n    process!(SP(i+1, simple, ch2, ch1, \"bar\", i+1, *))\nend\n\nreset!(𝐶)\nput!(ch1, 1) # put first token into channel 1\nrun!(𝐶, 10)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"julia> include(\"docs/examples/channels4.jl\")\n 0.00: foo 7 took token 1\n 0.77: bar 4 took token 8\n 1.71: foo 3 took token 32\n 2.38: bar 2 took token 35\n 2.78: foo 5 took token 70\n 3.09: bar 8 took token 75\n ...\n 7.64: foo 7 took token 1387926\n 7.91: bar 4 took token 1387933\n 8.36: foo 3 took token 5551732\n 8.94: bar 2 took token 5551735\n 9.20: foo 5 took token 11103470\n 9.91: bar 8 took token 11103475\n\"run! finished with 21 clock events, simulation time: 10.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"see: now!, SF, tau, delay!, process!, SP, reset!, run!, 𝐶","category":"page"},{"location":"approach/#Comparison-1","page":"Building models","title":"Comparison","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"The output of the last example is different from the first three approaches because we did not shuffle (the shuffling of the processes is done by the scheduler). So if the output depends very much on the sequence of events and you need to have reproducible results, explicitly controlling for the events like in the first three examples is preferable. If you are more interested in statistical evaluation - which is often the case -, the 4th approach is appropriate.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"All four approaches can be expressed in Simulate.jl. Process based modeling seems to be the simplest and the most intuitive approach, while the first three are more complicated. But they are also more structured and controllable , which comes in handy for more complicated examples. After all, parallel processes are often tricky to control and to debug. But you can combine the approaches and take the best from all worlds.","category":"page"},{"location":"approach/#Combined-approach-1","page":"Building models","title":"Combined approach","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Physical systems can be modeled as continuous systems (nature does not jump), discrete systems (nature jumps here!) or hybrid systems (nature jumps sometimes).","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"While continuous systems are the domain of differential equations, discrete and hybrid systems may be modeled easier with Simulate.jl by combining the event-scheduling, the process-based and the continuous-sampling schemes.","category":"page"},{"location":"approach/#A-hybrid-system-1","page":"Building models","title":"A hybrid system","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"In a hybrid system we have continuous processes and discrete events interacting in one system. A thermostat or a house heating system is a basic example of this:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Heating changes between two states: On and Off.\nA room cools at a rate proportional to the difference between room temperature Tr and environment temperature Te.\nIt heats at a rate proportional to the temperature difference between temperature of the heating fluid Th and room temperature Tr.\nThe room temperature Tr changes proportional to the difference between heating and cooling.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"First we setup the physical model with some assumptions:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"using Simulate, Plots, DataFrames, Random, Distributions, LaTeXStrings\n\nconst Th = 40     # temperature of heating fluid\nconst R = 1e-6    # thermal resistance of room insulation\nconst α = 2e6     # represents thermal conductivity and capacity of the air\nconst β = 3e-7    # represents mass of the air and heat capacity\nη = 1.0           # efficiency factor reducing R if doors or windows are open\nheating = false   # initially the heating is off\n\nΔte(t, t1, t2) = cos((t-10)*π/12) * (t2-t1)/2  # change rate of a sinusoidal Te\n\nfunction Δtr(Tr, Te, heating)\n    Δqc = (Tr - Te)/(R * η)             # cooling rate\n    Δqh = heating ? α * (Th - Tr) : 0   # heating rate\n    return β * (Δqh - Δqc)              # change of room temperature\nend","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Δtr (generic function with 1 method)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"We setup a simulation for 24 hours from 0am to 12am. We update the simulation every virtual minute.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"reset!(𝐶)                               # reset the clock\nrng = MersenneTwister(122)              # set random number generator\nΔt = 1//60                              # evaluate every minute\nTe = 11                                 # starting values\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfunction setTemperatures(t1=8, t2=20)   # define a sampling function\n    global Te += Δte(tau(), t1, t2) * 2π/1440 + rand(rng, Normal(0, 0.1))\n    global Tr += Δtr(Tr, Te, heating) * Δt\n    push!(df, (tau(), Tr, Te, Int(heating)) )\nend\n\nfunction switch(t1=20, t2=23)           # a function simulating the thermostat\n    if Tr ≥ t2\n        global heating = false\n        event!(SF(switch, t1, t2), @val :Tr :≤ t1)  # setup a conditional event\n    elseif Tr ≤ t1\n        global heating = true\n        event!(SF(switch, t1, t2), @val :Tr :≥ t2)  # setup a conditional event\n    end\nend\n\nSimulate.sample!(SF(setTemperatures), Δt)  # setup the sampling function\nswitch()                                   # start the thermostat\n\n@time run!(𝐶, 24)                          # run the simulation","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"0.040105 seconds (89.21 k allocations: 3.435 MiB)\n\"run! finished with 0 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating undisturbed\")","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"(Image: svg)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"Now we have people entering the room or opening windows and thus reducing thermal resistance:","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"function people()\n    delay!(6 + rand(Normal(0, 0.5)))         # sleep until around 6am\n    sleeptime = 22 + rand(Normal(0, 0.5))    # calculate bed time\n    while tau() < sleeptime\n        global η = rand()                    # open door or window\n        delay!(0.1 * rand(Normal(1, 0.3)))   # for some time\n        global η = 1.0                       # close it again\n        delay!(rand())                       # do something else\n    end\nend\n\nreset!(𝐶)\nrng = MersenneTwister(122)\nRandom.seed!(1234)\nTe = 11\nTr = 20\ndf = DataFrame(t=Float64[], tr=Float64[], te=Float64[], heating=Int64[])\n\nfor i in 1:2                                 # put 2 people in the house\n    process!(SP(i, people), 1)               # run process only once\nend\nSimulate.sample!(SF(setTemperatures), Δt)\nswitch()\n\n@time run!(𝐶, 24)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"0.114938 seconds (72.52 k allocations: 2.320 MiB)\n\"run! finished with 116 clock events, 1440 sample steps, simulation time: 24.0\"","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"plot(df.t, df.tr, legend=:bottomright, label=L\"T_r\")\nplot!(df.t, df.te, label=L\"T_e\")\nplot!(df.t, df.heating, label=\"heating\")\nxlabel!(\"hours\")\nylabel!(\"temperature\")\ntitle!(\"House heating with people\")","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"(Image: svg)","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"We have now all major schemes: events, continuous sampling and processes combined in one example.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"see: tau, SF, event!, @val, delay!, sample!, run!, process!, SP, reset!, 𝐶\nsee also: the full house heating example for further explanations.","category":"page"},{"location":"approach/#Theories-1","page":"Building models","title":"Theories","text":"","category":"section"},{"location":"approach/#","page":"Building models","title":"Building models","text":"There are some theories about the different approaches (1) event based, (2) state based, (3) activity based and (4) process based. Choi and Kang [1] have written an entire book about the first three approaches. Basically they can be converted to each other. Cassandras and Lafortune [2] call those \"the event scheduling scheme\" and the 4th approach \"the process-oriented simulation scheme\" [3]. There are communities behind the various views and Simulate.jl wants to be useful for them all.","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"[1]: Choi and Kang: Modeling and Simulation of Discrete-Event Systems, Wiley, 2013","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"[2]: Cassandras and Lafortune: Introduction to Discrete Event Systems, Springer, 2008, Ch. 10","category":"page"},{"location":"approach/#","page":"Building models","title":"Building models","text":"[3]: to be fair, the 4th approach is called by Choi and Kang \"parallel simulation\".","category":"page"},{"location":"examples/greeting/#Two-guys-meet-1","page":"Two guys meet","title":"Two guys meet","text":"","category":"section"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If two guys meet, there is standard verbiage, but some uncertainty in how long they need to greet and respond. We can simulate this as an introductory example.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We call the needed modules and define some types and data:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"using Simulate, Printf\n\nstruct Guy\n    name\nend\n\nabstract type Encounter end\nstruct Meet <: Encounter\n    someone\nend\nstruct Greet <: Encounter\n    num\n    from\nend\nstruct Response <: Encounter\n    num\n    from\nend\n\ncomm = (\"Nice to meet you!\", \"How are you?\", \"Have a nice day!\", \"bye bye\")","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"We implement the behavior of the \"guys\" as step!-functions of a state machine.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"say(name, n) =  @printf(\"%5.2f s, %s: %s\\n\", tau(), name, comm[n])\n\nfunction step!(me::Guy, σ::Meet)\n    event!(𝐶, SF(step!, σ.someone, Greet(1, me)), after, 2*rand())\n    say(me.name, 1)\nend\n\nfunction step!(me::Guy, σ::Greet)\n    if σ.num < 3\n        event!(𝐶, SF(step!, σ.from, Response(σ.num, me)), after, 2*rand())\n        say(me.name, σ.num)\n    else\n        say(me.name, 4)\n    end\nend\n\nfunction step!(me::Guy, σ::Response)\n    event!(𝐶, SF(step!, σ.from, Greet(σ.num+1, me)), after, 2*rand())\n    say(me.name, σ.num+1)\nend","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we define some \"guys\" and a starting event and tell the clock 𝐶 to run for twenty \"seconds\":","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"foo = Guy(\"Foo\")\nbar = Guy(\"Bar\")\n\nevent!(𝐶, SF(step!, foo, Meet(bar)), at, 10*rand())\nrun!(𝐶, 20)","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"If we source this code, it will run a simulation:","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> include(\"docs/examples/greeting.jl\")\n 7.30 s, Foo: Nice to meet you!\n 8.00 s, Bar: Nice to meet you!\n 9.15 s, Foo: How are you?\n10.31 s, Bar: How are you?\n11.55 s, Foo: Have a nice day!\n12.79 s, Bar: bye bye\nFinished: 6 events, simulation time: 20.0","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"Then we reset the clock 𝐶 for further simulations.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"julia> reset!(𝐶)\nclock reset to t₀=0, sampling rate Δt=0.","category":"page"},{"location":"examples/greeting/#","page":"Two guys meet","title":"Two guys meet","text":"See also: tau, 𝐶, SF, event!, run!, reset!","category":"page"},{"location":"examples/tabletennis/#Table-tennis-1","page":"Table tennis","title":"Table tennis","text":"","category":"section"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"In table tennis we have some physical constraints, standard moves and rules, but uncertainty in execution due to lack of accuray and attentiveness of the players and so on.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"First we need to call the needed modules:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"using Simulate, Printf\nimport Simulate.init!","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Then we need some definitions for states, events and players:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"abstract type PState end\nstruct Idle <: PState end\nstruct Wait <: PState end\nstruct Unalert <: PState end\n\nabstract type PEvent end\nstruct Start <: PEvent end\nstruct Serve <: PEvent end\nstruct Return <: PEvent end\nstruct Miss <: PEvent end\n\nmutable struct Player\n    name::AbstractString\n    opp::Union{Number,Player}\n    state::PState\n    accuracy::Float64\n    attentiveness::Float64\n    score::Int64\n\n    Player(name, acc, att) = new(name, 0, Idle(), acc, att, 0)\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We have to define the physical facts and a function to randomize them:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"const dist = 3 # distance for ball to fly [m]\nconst vs   = 10 # serve velocity [m/s]\nconst vr   = 20 # return velocity [m/s]\n\nrd(s::Float64) = randn()*s + 1","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Some functions describe the setup of players, serve and return.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"function init!(p::Player, opp::Player)\n    p.opp = opp\n    if rand() ≤ p.attentiveness\n        p.state = Wait()\n    else\n        p.state = Unalert()\n    end\nend\n\nfunction serve(p::Player)\n    ts = 3 + dist*rd(0.15)/(vs*rd(0.25))\n    if (rand() ≤ p.accuracy) && (p.state == Wait())\n        event!(𝐶, SF(step!, p.opp, Serve()), after, ts)\n        @printf(\"%5.2f: %s serves %s\\n\", tau()+ts, p.name, p.opp.name)\n    else\n        event!(𝐶, SF(step!, p.opp, Miss()), after, ts)\n        @printf(\"%5.2f: %s serves and misses %s\\n\", tau()+ts, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend\n\nfunction ret(p::Player)\n    tr = dist*rd(0.15)/(vr*rd(0.25))\n    if rand() ≤ p.accuracy\n        event!(𝐶, SF(step!, p.opp, Return()), after, tr)\n        @printf(\"%5.2f: %s returns %s\\n\", tau()+tr, p.name, p.opp.name)\n    else\n        event!(𝐶, SF(step!, p.opp, Miss()), after, tr)\n        @printf(\"%5.2f: %s returns and misses %s\\n\", tau()+tr, p.name, p.opp.name)\n    end\n    if rand() ≥ p.attentiveness\n        p.state = Unalert()\n    end\nend","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We can model the players as state machines. Their behaviour is described by the following step!-transition functions, leading to some actions and a new state.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"\"default transition for players\"\nstep!(p::Player, q::PState, σ::PEvent) =\n        println(\"undefined transition for $(p.name), $q, $σ\")\n\n\"player p gets a start command\"\nstep!(p::Player, ::Union{Wait, Unalert}, ::Start) = serve(p)\n\n\"player p is waiting and gets served or returned\"\nstep!(p::Player, ::Wait, ::Union{Serve, Return}) = ret(p)\n\n\"player p is unalert and gets served or returned\"\nfunction step!(p::Player, ::Unalert, ::Union{Serve, Return})\n    @printf(\"%5.2f: %s looses ball\\n\", τ(), p.name)\n    p.opp.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"player p is waiting or unalert and gets missed\"\nfunction step!(p::Player, ::Union{Wait, Unalert}, ::Miss)\n    p.score += 1\n    p.state = Wait()\n    serve(p)\nend\n\n\"simplified `step!` call\"\nstep!(p::Player, σ::PEvent) = step!(p, p.state, σ)","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"We define and setup the players and give Ping the Start() command.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"ping = Player(\"Ping\", 0.90, 0.90)\npong = Player(\"Pong\", 0.90, 0.90)\ninit!(ping, pong)\ninit!(pong, ping)\nstep!(ping, Start())","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we setup a simulation and analysis of the results:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Random.seed!(123)\n\nprintln(run!(𝐶, 30))\nprintln(\"Ping scored $(ping.score)\")\nprintln(\"Pong scored $(pong.score)\")","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"If we source this code, the simulation runs:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> include(\"docs/examples/tabletennis.jl\")\n3.35: Ping serves Pong\n3.47: Pong returns and misses Ping\n6.82: Ping serves Pong\n6.96: Pong returns Ping\n7.15: Ping returns Pong\n7.28: Pong returns Ping\n7.54: Ping returns Pong\n7.80: Pong returns Ping\n7.80: Ping looses ball\n11.27: Ping serves Pong\n11.45: Pong returns Ping\n11.59: Ping returns Pong\n11.92: Pong returns Ping\n12.08: Ping returns Pong\n12.08: Pong looses ball\n15.59: Pong serves Ping\n15.59: Ping looses ball\n18.75: Ping serves Pong\n18.91: Pong returns Ping\n18.91: Ping looses ball\n22.15: Ping serves Pong\n22.30: Pong returns Ping\n22.30: Ping looses ball\n25.62: Ping serves Pong\n25.83: Pong returns Ping\n26.19: Ping returns and misses Pong\n29.50: Pong serves and misses Ping\n32.75: Ping serves Pong\nrun! finished with 47 clock events, 0 sample steps, simulation time: 30.0\nPing scored 3\nPong scored 5","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"Finally we reset the clock for further simulations:","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"julia> reset!(𝐶)\nclock reset to t₀=0, sampling rate Δt=0.","category":"page"},{"location":"examples/tabletennis/#","page":"Table tennis","title":"Table tennis","text":"See also: event!, SF, tau, 𝐶,  run!, reset!","category":"page"},{"location":"#Simulate.jl-1","page":"Home","title":"Simulate.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A Julia package for discrete event simulation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl provides three schemes for modeling and simulating discrete event systems (DES): 1) event scheduling, 2) interacting processes and 3) continuous sampling. By building directly on Julia it aims for simplicity and flexibility in building models and for high performance in simulation.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Getting started: Get an overview and learn the basics.\nBuilding models: Use and combine different approaches to modeling and simulation.\nUsage: Get detailed informations about types, functions and macros in Simulate.jl.\nExamples: Look at and learn from examples.\nInternals: Get informations about internal functions.\nTroubleshooting: If something doesn't work as expected.","category":"page"},{"location":"#Development-1","page":"Home","title":"Development","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulate.jl is a new package and still in early development. Please use and test it and help it evolve. Its GitHub repository is at https://github.com/pbayer/Simulate.jl.","category":"page"},{"location":"#New-in-v0.2.0-1","page":"Home","title":"New in v0.2.0","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"v0.2.0 is the first version supporting fully the three schemes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"now! for IO-operations of processes,\nfunctions and macros for defining conditions,\nconditional wait!(cond),\nconditional events with event!(sim, ex, cond),\nmost functions can be called without the first clock argument, default to 𝐶,\nevent! takes an expression or a SimFunction or a tuple or an array of them,\nintroduced aliases: SF for SimFunction and SP for SimProcess\nintroduced process-based simulation: SimProcess and process! and delay!,\nextensive documentation,\nmore examples.","category":"page"},{"location":"#Earlier-releases-1","page":"Home","title":"Earlier releases","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Release notes: A look at earlier releases.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"}]
}
