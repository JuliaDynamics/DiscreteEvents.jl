<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../approach/">Approaches</a></li><li class="current"><a class="toctext" href>Overview</a><ul class="internal"><li><a class="toctext" href="#The-clock-1">The clock</a></li><li><a class="toctext" href="#Functions-and-expressions-as-Events-1">Functions and expressions as Events</a></li><li><a class="toctext" href="#Sampling-expressions-1">Sampling expressions</a></li><li><a class="toctext" href="#Functions-as-processes-1">Functions as processes</a></li><li><a class="toctext" href="#Running-a-simulation-1">Running a simulation</a></li><li><a class="toctext" href="#Logging-1">Logging</a></li></ul></li><li><a class="toctext" href="../usage/">Usage</a></li><li><a class="toctext" href="../examples/examples/">Examples</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubeshooting</a></li><li><a class="toctext" href="../history/">History</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Overview</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/overview.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Overview</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Discrete-event-simulation-with-Simulate.jl-1" href="#Discrete-event-simulation-with-Simulate.jl-1">Discrete event simulation with <code>Simulate.jl</code></a></h1><ol><li><a href="https://github.com/pbayer/Simulate.jl"><code>Simulate.jl</code></a> evaluates Julia expressions or arbitrary functions at given (virtual) simulation times.</li><li>Thus discrete event systems based on state machines can be modeled and simulated.</li><li>Variables can be logged over simulation time and then accessed for</li></ol><p>analysis or visualization.</p><h2><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h2><p><code>Simulate.jl</code> provides a clock for a simulation time  (a <code>Float64</code>) with an arbitrary unit of time. A unit can be set and times can be given to the clock with <code>Unitful</code> time units and thus are automatically converted.</p><ul><li><code>Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code>: create a new clock with sampling time <code>Œît</code>, start time <code>t0</code> and a choosen <code>Unitful</code> time unit.</li><li>italic <code>ùê∂</code> (<code>\itC</code>+Tab) or <code>Clk</code> : is the central Clock() variable.</li><li><code>œÑ(sim::Clock=ùê∂)</code>: return the current clock time.</li><li><code>sample_time!(sim::Clock, Œît::Number)</code>: set the clock&#39;s sample rate starting from <code>now(sim)</code>.</li><li><code>reset!(sim::Clock, Œît::Number=0; t0::Time=0, hard::Bool=true)</code>: reset a clock.</li><li><code>sync!(sim::Clock, to::Clock=ùê∂)</code>: Force a synchronization of two clocks.</li></ul><p>If no Œît ‚â† 0 is given, the simulation doesn&#39;t tick with a fixed interval, but jumps from event to event.</p><h4><a class="nav-anchor" id="A-note-on-using-time-units-1" href="#A-note-on-using-time-units-1">A note on using time units</a></h4><p>Internally <code>Simulate</code> clocks work with a <code>Float64</code> time and it works per default with <code>Unitful.NoUnits</code> but you can set them to work with <code>Unitful.Time</code> units like <code>ms, s, minute, hr</code>. In this case <code>œÑ(c)</code> returns a time, e.g. <code>1 s</code>. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.</p><ul><li><code>setUnit(sim::Clock, unit::FreeUnits)</code>: set a clock unit.</li><li><code>œÑ(sim::Clock).val</code>: return unitless number for current time.</li></ul><p>At the moment I find it unconvenient to work with units if you trace simulation times in a table or you do plots. It seems easier not to use them as long you need automatic time conversion in your simulation projects.</p><h2><a class="nav-anchor" id="Functions-and-expressions-as-Events-1" href="#Functions-and-expressions-as-Events-1">Functions and expressions as Events</a></h2><p>Julia functions or expressions are scheduled as events on the clock&#39;s time line:</p><ul><li><code>SimFunction(func::Function, arg...; kw...)</code>: prepare a function and its arguments for simulation.</li><li><code>event!(sim::Clock, ex::Union{Expr,SimFunction}, t::Number)</code> or</li><li><code>event!(sim, ex, at, t)</code>: schedule a function or an expression for a given simulation time.</li><li><code>event!(sim, ex, after, t):</code> schedule a function or an expression for time <code>t</code> after current simulation time.</li><li><code>event!(sim, ex, every, Œît)</code>: schedule a function an expression for now and every time step <code>Œît</code> until end of simulation.</li></ul><p>Events are called later as we <code>step</code> or <code>run</code> through the simulation. They may at runtime create further events and thus cause chains of events to be scheduled and called during simulation.</p><h2><a class="nav-anchor" id="Sampling-expressions-1" href="#Sampling-expressions-1">Sampling expressions</a></h2><p>If we provide the clock with a time interval <code>Œît</code>, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:</p><ul><li><code>sample_time!(sim::Clock, Œît::Number)</code>: set the clock&#39;s sampling time starting from now (<code>œÑ(sim)</code>).</li><li><code>sample!(sim::Clock, ex::Union{Expr,SimFunction})</code>: enqueue a function or expression for sampling.</li></ul><p>Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.</p><h2><a class="nav-anchor" id="Functions-as-processes-1" href="#Functions-as-processes-1">Functions as processes</a></h2><p>If they match certain conditions, functions can be started as processes, which wait for inputs, respond accordingly and create some output.</p><ul><li><code>SimProcess(id, func::Function, input::Channel=Channel(Inf), output::Channel=Channel(Inf), arg...; kw...)</code>: prepare a function <code>func(input::Channel, output::Channel, arg...; kw...)</code> for</li></ul><p>running as a process in a simulation.</p><ul><li><code>process!(sim::Clock, p::SimProcess)</code>: register a <code>SimProcess</code> to a clock</li><li><code>start!(sim::Clock)</code>: start all registered <code>SimProcess</code>es.</li><li><code>stop!(p::SimProcess)</code>: stop <code>p</code>.</li><li><code>delay!(sim::Clock, t::Number)</code>: a process can call for a delay, which creates</li></ul><p>an event on the clock&#39;s timeline and wakes up the process after the given <code>t</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function <code>f</code> running as a <code>SimProcess</code> is put in a loop. So it has to give back control by e.g. doing a <code>take!(input)</code> on its input channel or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will after start starve everything else!</p></div></div><h2><a class="nav-anchor" id="Running-a-simulation-1" href="#Running-a-simulation-1">Running a simulation</a></h2><p>Now, after we have setup a clock, scheduled events or setup sampling, we can step or run through a simulation, stop or resume it.</p><ul><li><code>run!(sim::Clock, duration::Number)</code>: run a simulation for a given duration. Call all ticks and scheduled events in that timeframe.</li><li><code>incr!(sim::Clock)</code>: take one simulation step, call the next tick or event.</li><li><code>stop!(sim::Clock)</code>: stop a simulation</li><li><code>resume!(sim::Clock)</code>: resume a halted simulation.</li></ul><p>Now we can evaluate the results.</p><h2><a class="nav-anchor" id="Logging-1" href="#Logging-1">Logging</a></h2><p>Logging enables us to trace variables over simulation time and such analyze their behaviour.</p><ul><li><code>L = Logger()</code>: create a new logger, providing the newest record <code>L.last</code>, a logging table <code>L.df</code> and a switch <code>L.ltype</code> between logging types.</li><li><code>init!(L::Logger, sim::Clock=ùê∂)</code>:</li><li><code>setup!(L::Logger, vars::Array{Symbol})</code>: setup <code>L</code>, providing it with an array of logging variables <code>[:a, :b, :c ...]</code></li><li><code>switch!(L::Logger, to::Number=0)</code>: switch between <code>0</code>: only keep the last record, <code>1</code>: print, <code>2</code>: write records to the table</li><li><code>record!(L::Logger)</code>: record the logging variables with current simulation time.</li></ul><footer><hr/><a class="previous" href="../approach/"><span class="direction">Previous</span><span class="title">Approaches</span></a><a class="next" href="../usage/"><span class="direction">Next</span><span class="title">Usage</span></a></footer></article></body></html>
