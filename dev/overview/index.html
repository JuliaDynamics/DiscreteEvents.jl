<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview ¬∑ Sim.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Sim.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Overview</a><ul class="internal"></ul></li><li><a class="toctext" href="../usage/">Usage</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/greeting/">Two guys meet</a></li><li><a class="toctext" href="../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../examples/examples/">Further examples</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Overview</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Sim.jl/blob/master/docs/src/overview.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Overview</span><a class="fa fa-bars" href="#"></a></div></header><h3><a class="nav-anchor" id="Discrete-event-simulation-with-Sim.jl-1" href="#Discrete-event-simulation-with-Sim.jl-1">Discrete event simulation with <code>Sim.jl</code></a></h3><ol><li><a href="https://github.com/pbayer/Sim.jl"><code>Sim.jl</code></a> evaluates Julia expressions or arbitrary functions at given (virtual) simulation times.</li><li>Thus discrete event systems based on state machines can be modeled and simulated.</li><li>Variables can be logged over simulation time and then accessed for</li></ol><p>analysis or visualization.</p><h3><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h3><p><code>Sim.jl</code> provides a clock for a simulation time  (a <code>Float64</code>) with an arbitrary unit of time.</p><ul><li><code>Clock(Œît::Number=0; t0::Number=0)</code>: create a new clock with start time <code>t0</code> and sample time <code>Œît</code>.</li><li>italic <code>ùê∂</code> (<code>\itC</code>+Tab) or <code>Clk</code> : is the central Clock() variable.</li><li><code>œÑ(sim::Clock=ùê∂)</code>: return the current clock time.</li><li><code>sample_time!(sim::Clock, Œît::Number)</code>: set the clock&#39;s sample rate starting from <code>now(sim)</code>.</li><li><code>reset!(sim::Clock, Œît::Number=0; t0::Time=0, hard::Bool=true)</code>: reset a clock.</li><li><code>sync!(sim::Clock, to::Clock=ùê∂)</code>: Force a synchronization of two clocks.</li></ul><p>If no Œît ‚â† 0 is given, the simulation doesn&#39;t tick with a fixed interval, but jumps from event to event.</p><h3><a class="nav-anchor" id="Functions-and-expressions-as-Events-1" href="#Functions-and-expressions-as-Events-1">Functions and expressions as Events</a></h3><p>Julia functions or expressions are scheduled as events on the clock&#39;s time line:</p><ul><li><code>SimFunction(func::Function, arg...; kw...)</code>: prepare a function and its arguments for simulation.</li><li><code>event!(sim::Clock, ex::Union{Expr,SimFunction}, t::Float64)</code> or</li><li><code>event!(sim, ex, at, t)</code>: schedule a function or an expression for a given simulation time.</li><li><code>event!(sim, ex, after, t):</code> schedule a function or an expression for time <code>t</code> after current simulation time.</li><li><code>event!(sim, ex, every, Œît)</code>: schedule a function an expression for now and every time step <code>Œît</code> until end of simulation.</li></ul><p>Events are called later as we <code>step</code> or <code>run</code> through the simulation. They may at runtime create further events and thus cause chains of events to be scheduled and called during simulation.</p><h3><a class="nav-anchor" id="Sampling-expressions-1" href="#Sampling-expressions-1">Sampling expressions</a></h3><p>If we provide the clock with a time interval <code>Œît</code>, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:</p><ul><li><code>sample!(sim::Clock, ex::Union{Expr,SimFunction})</code>: enqueue a function or expression for sampling.</li></ul><p>Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events which may have been scheduled for the same time.</p><h3><a class="nav-anchor" id="Running-the-simulation-1" href="#Running-the-simulation-1">Running the simulation</a></h3><p>Now, after we have setup a clock, scheduled events or setup sampling, we can step or run through a simulation, stop or resume it.</p><ul><li><code>run!(sim::Clock, duration::Number)</code>: run a simulation for a given duration. Call all ticks and scheduled events in that timeframe.</li><li><code>incr!(sim::Clock)</code>: take one simulation step, call the next tick or event.</li><li><code>stop!(sim::Clock)</code>: stop a simulation</li><li><code>resume!(sim::Clock)</code>: resume a halted simulation.</li></ul><p>Now we can evaluate the results.</p><h3><a class="nav-anchor" id="Logging-1" href="#Logging-1">Logging</a></h3><p>Logging enables us to trace variables over simulation time and such analyze their behaviour.</p><ul><li><code>L = Logger()</code>: create a new logger, providing the newest record <code>L.last</code>, a logging table <code>L.df</code> and a switch <code>L.ltype</code> between logging types.</li><li><code>init!(L::Logger, sim::Clock=ùê∂)</code>:</li><li><code>setup!(L::Logger, vars::Array{Symbol})</code>: setup <code>L</code>, providing it with an array of logging variables <code>[:a, :b, :c ...]</code></li><li><code>switch!(L::Logger, to::Number=0)</code>: switch between <code>0</code>: only keep the last record, <code>1</code>: print, <code>2</code>: write records to the table</li><li><code>record!(L::Logger)</code>: record the logging variables with current simulation time.</li></ul><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../usage/"><span class="direction">Next</span><span class="title">Usage</span></a></footer></article></body></html>
