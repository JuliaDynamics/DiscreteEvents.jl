<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Clocks · DiscreteEvents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DiscreteEvents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../news/">News</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../setup/">Installation</a></li><li class="is-active"><a class="tocitem" href>Clocks</a><ul class="internal"><li><a class="tocitem" href="#Virtual-Clocks"><span>Virtual Clocks</span></a></li><li><a class="tocitem" href="#Parallel-Clocks-(Experimental)"><span>Parallel Clocks (Experimental)</span></a></li><li><a class="tocitem" href="#Real-Time-Clocks-(Experimental)"><span>Real Time Clocks (Experimental)</span></a></li><li><a class="tocitem" href="#Clock-Operation"><span>Clock Operation</span></a></li><li><a class="tocitem" href="#Time-Units"><span>Time Units</span></a></li></ul></li><li><a class="tocitem" href="../events/">Events</a></li><li><a class="tocitem" href="../processes/">Processes</a></li><li><a class="tocitem" href="../actors/">Actors</a></li><li><a class="tocitem" href="../resources/">Resources</a></li><li><a class="tocitem" href="../parallel/">Parallel Simulation</a></li><li><a class="tocitem" href="../usage/">Utilities</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../history/">Version history</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Clocks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Clocks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pbayer/DiscreteEvents.jl/blob/master/docs/src/clocks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Clocks"><a class="docs-heading-anchor" href="#Clocks">Clocks</a><a id="Clocks-1"></a><a class="docs-heading-anchor-permalink" href="#Clocks" title="Permalink"></a></h1><p>Clocks schedule and execute <em>actions</em>, computations that happen as <em>events</em> at specified times (or under specified conditions).</p><h2 id="Virtual-Clocks"><a class="docs-heading-anchor" href="#Virtual-Clocks">Virtual Clocks</a><a id="Virtual-Clocks-1"></a><a class="docs-heading-anchor-permalink" href="#Virtual-Clocks" title="Permalink"></a></h2><p>A <code>Clock</code> is not bound to physical time and executes an event sequence as fast as possible by jumping from event to event.</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.Clock" href="#DiscreteEvents.Clock"><code>DiscreteEvents.Clock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Clock{AC} &lt;: AbstractClock</code></pre><p>A virtual clock structure, used for global and thread local clocks.</p><p><strong>Fields</strong></p><ul><li><code>id::Int</code>: clock ident number 1: master clock, &gt; 1: parallel clock,</li><li><code>ac::AC</code>: if id == 1: a <a href="../internals/#DiscreteEvents.ClockChannel"><code>Vector{ClockChannel}</code></a> else: <a href="../internals/#DiscreteEvents.ActiveClock"><code>Ref{ActiveClock}</code></a>,</li><li><code>state::ClockState</code>: clock state,</li><li><code>time::Float64</code>: clock time,</li><li><code>unit::FreeUnits</code>: time unit,</li><li><code>end_time::Float64</code>: end time for simulation,</li><li><code>Δt::Float64</code>: sampling time, timestep between ticks,</li><li><code>sc::Schedule</code>: the clock <a href="../internals/#DiscreteEvents.Schedule"><code>Schedule</code></a> (events, cond events and sampling),</li><li><code>processes::Dict{Any, Prc}</code>: registered <code>Prc</code>es,</li><li><code>channels::Vector{Channel}</code>: registered (Actor) channels,</li><li><code>tn::Float64</code>: next timestep,</li><li><code>tev::Float64</code>: next event time,</li><li><code>evcount::Int</code>: event counter,</li><li><code>scount::Int</code>: sample counter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/types.jl#L184-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.Clock-Union{Tuple{T}, Tuple{T}} where T&lt;:Number" href="#DiscreteEvents.Clock-Union{Tuple{T}, Tuple{T}} where T&lt;:Number"><code>DiscreteEvents.Clock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Clock(Δt::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Create a new virtual clock.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::T=0.01</code>: time increment for sampling. Δt can be set later with <code>sample_time!</code>.</li><li><code>t0::U=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p>The created clock has id==1 (master).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/types.jl#L225-L239">source</a></section></article><p>You can create clocks easily:</p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful, .Threads

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                  # create a unitless clock (standard)
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c1 = Clock(1s, unit=minute)  # create a clock with unit [minute]
Clock 1: state=:idle, t=0.0minute, Δt=0.01667minute, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c2 = Clock(1s)               # create a clock with implicit unit [s]
Clock 1: state=:idle, t=0.0s, Δt=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c3 = Clock(t0=60s)           # another clock with implicit unit [s]
Clock 1: state=:idle, t=60.0s, Δt=0.01s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c4 = Clock(1s, t0=1hr)       # here Δt&#39;s unit [s] takes precedence
Clock 1: state=:idle, t=3600.0s, Δt=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre><p>There is a default clock <code>𝐶</code> for experimental work:</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.𝐶" href="#DiscreteEvents.𝐶"><code>DiscreteEvents.𝐶</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">𝐶</code></pre><p><code>𝐶</code> (𝐶 = <code>\itC+tab</code>) is a default clock, ready to use. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;

julia&gt; 𝐶  # default clock
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L9-L26">source</a></section></article><p>You can query the current clock time:</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.tau" href="#DiscreteEvents.tau"><code>DiscreteEvents.tau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tau(clk::Clock=𝐶)</code></pre><p>Return the current simulation time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(𝐶)   # reset the default clock
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;
julia&gt; tau()            # gives the default clock&#39;s time
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L108-L122">source</a></section></article><h2 id="Parallel-Clocks-(Experimental)"><a class="docs-heading-anchor" href="#Parallel-Clocks-(Experimental)">Parallel Clocks (Experimental)</a><a id="Parallel-Clocks-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Clocks-(Experimental)" title="Permalink"></a></h2><p>Parallel clocks are a new feature in v0.3 and cannot yet considered to be stable. Please develop your applications first single-threaded before going parallel. Please report any failures.</p><p>Parallel clocks are virtual clocks with local clocks on parallel threads to support multi-threaded simulations.</p><p>A parallel clock structure consists of a master (global) clock on thread 1 and <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a>s on all available threads &gt; 1. An active clock is a task running a thread local clock. The thread local clock can schedule and execute events locally.</p><p>The master clock communicates with its parallel active clocks via message channels. It synchronizes time with the local clocks. Tasks (processes and actors) have access to their thread local clock from it and then work only with the local clock.</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.PClock" href="#DiscreteEvents.PClock"><code>DiscreteEvents.PClock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">PClock(Δt::T=0.01; t0::U=0.0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Setup a clock with parallel clocks on all available threads.</p><p>When running the master clock on thread 1 will synchronize  time between parallel clocks every time increment <code>Δt</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::T=0.01</code>: time increment &gt; 0. If given Δt ≤ 0, it gets set to 0.01.</li><li><code>t0::U=0.0</code>: start time for simulation,</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit for explicitl unit setting.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Processes on multiple threads are possible in Julia ≥ 1.3 and with <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS &gt; 1</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/threads.jl#L178-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.pclock" href="#DiscreteEvents.pclock"><code>DiscreteEvents.pclock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pclock(clk::Clock, id::Int ) :: C where {C&lt;:AbstractClock}
pclock(ac::ActiveClock, id::Int ) :: C where {C&lt;:AbstractClock}</code></pre><p>Get a parallel clock to a given clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: a master clock or</li><li><code>ac::ActiveClock</code>: an active clock,</li><li><code>id::Int=threadid()</code>: thread id, defaults to the caller&#39;s current thread.</li></ul><p><strong>Returns</strong></p><ul><li>the master <a href="#DiscreteEvents.Clock"><code>Clock</code></a> if id==1,</li><li>a parallel <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a> else</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/threads.jl#L206-L221">source</a></section></article><p>Parallel clocks can be identified by their thread number: the master clock works on thread 1, local clocks on parallel threads ≥ 2. They can be setup and accessed easily:</p><pre><code class="language-julia-repl">julia&gt; @show x=nthreads()-1;
x = nthreads() - 1 = 1

julia&gt; clk = PClock()       # now the clock has (+x) active parallel clocks
Clock 1 (+1): state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; ac2 = pclock(clk, 2) # access the active clock on thread 2
Active clock 2: state=:idle, t=0.0, Δt=0.01, prc:0
   scheduled ev:0, cev:0, sampl:0

julia&gt; ac2.clock            # the thread local clock
Clock 2: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; ac2.clock.ac[]       # local clocks can access their active clock
Active clock 2: state=:idle, t=0.0, Δt=0.01, prc:0
   scheduled ev:0, cev:0, sampl:0</code></pre><p>Tasks on parallel threads have access to the thread local clock by <code>pclock(clk)</code>. Then they can schedule events, <code>delay!</code> or <code>wait!</code> on it as usual. The thread local clock is passed to a <code>process!</code> automatically if you set it up on a parallel thread.</p><p>You can fork explicitly existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel active clocks and diagnose them.</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.fork!" href="#DiscreteEvents.fork!"><code>DiscreteEvents.fork!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fork!(master::Clock)</code></pre><p>Establish copies of a master clock (thread 1) on all parallel threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/threads.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.collapse!" href="#DiscreteEvents.collapse!"><code>DiscreteEvents.collapse!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collapse!(master::Clock)</code></pre><p>Transfer the schedules of the parallel clocks to master and them stop them.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are processes on other threads registered to parallel clocks, make sure that they aren&#39;t needed anymore before calling <code>collapse</code>. They are not transferred to and cannot be controlled by master.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/threads.jl#L146-L155">source</a></section></article><pre><code class="language-julia-repl">julia&gt; clk = Clock()      # create a clock
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; fork!(clk)         # fork it

julia&gt; clk                # it now has parallel clocks
Clock 1 (+1): state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; collapse!(clk)     # collapse it

julia&gt; clk                # it now has no parallel clocks
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.diagnose" href="#DiscreteEvents.diagnose"><code>DiscreteEvents.diagnose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diagnose(master::Clock, id::Int)</code></pre><p>Return the stacktrace from parallel clock id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/threads.jl#L246-L250">source</a></section></article><h2 id="Real-Time-Clocks-(Experimental)"><a class="docs-heading-anchor" href="#Real-Time-Clocks-(Experimental)">Real Time Clocks (Experimental)</a><a id="Real-Time-Clocks-(Experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Real-Time-Clocks-(Experimental)" title="Permalink"></a></h2><p>Real time clocks are a new feature in v0.3 and thus cannot yet be considered as stable. Please try and report problems.</p><p><code>RTClock</code>s schedule and execute actions on a real (system) time line.</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.RTClock" href="#DiscreteEvents.RTClock"><code>DiscreteEvents.RTClock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RTClock{E &lt;: ClockEvent} &lt;: AbstractClock</code></pre><p>A real time clock checks every given period for scheduled events and executes them. It has a time in seconds since its start or last reset and uses system time for updating.</p><p>Real time clocks are controlled over channels. Multiple real time clocks can be setup with arbitrary periods (≥ 1 ms). Real time clocks should not be created directly but rather with <code>CreateRTClock</code>.</p><p><strong>Fields</strong></p><ul><li><code>Timer::Timer</code>:     clock period in seconds, minimum is 0.001 (1 ms)</li><li><code>clock::Clock</code>:     clock work</li><li><code>cmd::Channel{T}</code>:  command channel to asynchronous clock</li><li><code>back::Channel{T}</code>: back channel from async clock</li><li><code>id::Int</code>:          arbitrary id number</li><li><code>thread::Int</code>:      thread the async clock is living in</li><li><code>time::Float64</code>:    clock time since start in seconds</li><li><code>t0::Float64</code>:      system time at clock start in seconds</li><li><code>T::Float64</code>:       clock period in seconds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/types.jl#L317-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.createRTClock" href="#DiscreteEvents.createRTClock"><code>DiscreteEvents.createRTClock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createRTClock(T::Float64, id::Int, thrd::Int=nthreads(); ch_size::Int=256)</code></pre><p>Create, start and return a real time Clock.</p><p>The clock takes the current system time and starts to count in seconds with the given period <code>T</code>. Events or sampling functions can then be scheduled to it.</p><p><strong>Arguments</strong></p><ul><li><code>T::Float64</code>:           period (clock resolution) in seconds, T ≥ 0.001</li><li><code>id::Int</code>:              clock identification number other than 0:nthreads()</li><li><code>thrd::Int=nthreads()</code>: thread, the clock task should run in</li><li><code>ch_size::Int=256</code>:     clock communication channel size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/timer.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.stopRTClock" href="#DiscreteEvents.stopRTClock"><code>DiscreteEvents.stopRTClock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stopRTClock(rtc::RTClock)</code></pre><p>Stop a real time clock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/timer.jl#L110-L114">source</a></section></article><p>You can work with real time clocks easily:</p><pre><code class="language-julia-repl">julia&gt; rtc = createRTClock(0.01, 99)     # create a real time clock
RTClock 99 on thread 2: state=:idle, t=0.1734 s, T=0.01 s, prc:0
   scheduled ev:0, cev:0, sampl:0

julia&gt; sleep(1)

julia&gt; tau(rtc)                          # query its time after a sleep
1.2075882370000102

julia&gt; a = [1]                           # create a mutable variable
1-element Array{Int64,1}:
 1

julia&gt; f(x) = x[1] += 1                  # an incrementing function
f (generic function with 1 method)

julia&gt; event!(rtc, fun(f, a), every, 1)  # increment now and then every second
DiscreteEvents.Register{DiscreteEvents.DiscreteEvent{DiscreteEvents.var&quot;#9#10&quot;{typeof(Main.ex-clocks.f)},Float64}}(DiscreteEvents.DiscreteEvent{DiscreteEvents.var&quot;#9#10&quot;{typeof(Main.ex-clocks.f)},Float64}(DiscreteEvents.var&quot;#9#10&quot;{typeof(Main.ex-clocks.f)}(Core.Box(nothing), Main.ex-clocks.f, Core.Box(([2],))), 1.2075882370000102, 1.0, 9223372036854775807))

julia&gt; sleep(3)                          # sleep 3 seconds

julia&gt; a[1]                              # query a
5

julia&gt; stopRTClock(rtc)                  # stop the clock
DiscreteEvents.Stop()</code></pre><h2 id="Clock-Operation"><a class="docs-heading-anchor" href="#Clock-Operation">Clock Operation</a><a id="Clock-Operation-1"></a><a class="docs-heading-anchor-permalink" href="#Clock-Operation" title="Permalink"></a></h2><p>Virtual clocks can be run, stopped or stepped through and thereby used to simulate chains of events.</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.run!" href="#DiscreteEvents.run!"><code>DiscreteEvents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run!(clk::Clock, duration::N) where {N&lt;:Number}</code></pre><p>Run a simulation for a given duration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L392-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.@run!" href="#DiscreteEvents.@run!"><code>DiscreteEvents.@run!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@run! clk t</code></pre><p>Run a clock <code>clk</code> for a duration <code>t</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/macros.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.incr!" href="#DiscreteEvents.incr!"><code>DiscreteEvents.incr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">incr!(clk::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.resetClock!" href="#DiscreteEvents.resetClock!"><code>DiscreteEvents.resetClock!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resetClock!(clk::Clock, Δt::T=0.01; t0::U=0; &lt;keyword arguments&gt;) where {T&lt;:Number, U&lt;:Number}</code></pre><p>Reset a clock.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>Δt::T=0.01</code>: sample rate</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Δt::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock 1: state=:idle, t=60.0s, Δt=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; resetClock!(c)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.01.&quot;

julia&gt; c
Clock 1: state=:idle, t=0.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L155-L189">source</a></section><section><div><pre><code class="language-none">resetClock!(rtc::RTClock)</code></pre><p>Reset a real time clock. Set its time to zero and delete all scheduled and sampling events.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/timer.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.stop!" href="#DiscreteEvents.stop!"><code>DiscreteEvents.stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stop!(clk::Clock)</code></pre><p>Stop a running simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L411-L415">source</a></section><section><div><p>Stop a Prc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/process.jl#L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.resume!" href="#DiscreteEvents.resume!"><code>DiscreteEvents.resume!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resume!(clk::Clock)</code></pre><p>Resume a halted simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.sync!" href="#DiscreteEvents.sync!"><code>DiscreteEvents.sync!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sync!(clk::Clock, to::Clock=𝐶)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>clk</code> accordingly. Convert or force clk.unit to to.unit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L125-L130">source</a></section></article><h2 id="Time-Units"><a class="docs-heading-anchor" href="#Time-Units">Time Units</a><a id="Time-Units-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Units" title="Permalink"></a></h2><p>You can set time units of a virtual clock:</p><article class="docstring"><header><a class="docstring-binding" id="DiscreteEvents.setUnit!" href="#DiscreteEvents.setUnit!"><code>DiscreteEvents.setUnit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setUnit!(clk::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock 1: state=:idle, t=60.0, Δt=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; tau(c)               # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c)               # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/5feccdb697cd938402e02e52013ea22560bff8d8/src/clock.jl#L33-L84">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is not yet implemented for parallel clocks!</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../setup/">« Installation</a><a class="docs-footer-nextpage" href="../events/">Events »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 September 2020 15:32">Wednesday 16 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
