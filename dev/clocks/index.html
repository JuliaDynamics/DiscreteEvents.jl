<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Clocks ¬∑ DiscreteEvents.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DiscreteEvents.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../news/">News</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Introduction</a></li><li><a class="toctext" href="../setup/">Installation</a></li><li class="current"><a class="toctext" href>Clocks</a><ul class="internal"><li><a class="toctext" href="#Virtual-clocks-1">Virtual clocks</a></li><li><a class="toctext" href="#Parallel-clocks-1">Parallel clocks</a></li><li><a class="toctext" href="#Real-time-clocks-1">Real time clocks</a></li><li><a class="toctext" href="#Clock-operation-1">Clock operation</a></li><li><a class="toctext" href="#Units-1">Units</a></li></ul></li><li><a class="toctext" href="../events/">Events</a></li><li><a class="toctext" href="../processes/">Processes</a></li><li><a class="toctext" href="../actors/">Actors</a></li><li><a class="toctext" href="../resources/">Resources</a></li><li><a class="toctext" href="../usage/">Utilities</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Version history</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Clocks</a></li></ul><a class="edit-page" href="https://github.com/pbayer/DiscreteEvents.jl/blob/master/docs/src/clocks.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Clocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Clocks-1" href="#Clocks-1">Clocks</a></h1><p>Clocks schedule and execute <em>actions</em>, computations that happen as <em>events</em> at specified times (or under specified conditions).</p><h2><a class="nav-anchor" id="Virtual-clocks-1" href="#Virtual-clocks-1">Virtual clocks</a></h2><p>A <code>Clock</code> is not bound to physical time and executes an event sequence as fast as possible.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Clock" href="#DiscreteEvents.Clock"><code>DiscreteEvents.Clock</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock{AC} &lt;: AbstractClock</code></pre><p>A virtual clock structure, used for global and thread local clocks.</p><p><strong>Fields</strong></p><ul><li><code>id::Int</code>: clock ident number 1: master clock, &gt; 1: parallel clock,</li><li><code>ac::AC</code>: if id &gt; 1: communication channels else: reference to active clock(s),</li><li><code>state::ClockState</code>: clock state,</li><li><code>time::Float64</code>: clock time,</li><li><code>unit::FreeUnits</code>: time unit,</li><li><code>end_time::Float64</code>: end time for simulation,</li><li><code>Œît::Float64</code>: sampling time, timestep between ticks,</li><li><code>sc::Schedule</code>: the clock <a href="../internals/#DiscreteEvents.Schedule"><code>Schedule</code></a> (events, cond events and sampling),</li><li><code>processes::Dict{Any, Prc}</code>: registered <code>Prc</code>es,</li><li><code>channels::Vector{ClockChannel}</code>: registered channels,</li><li><code>tn::Float64</code>: next timestep,</li><li><code>tev::Float64</code>: next event time,</li><li><code>evcount::Int</code>: event counter,</li><li><code>scount::Int</code>: sample counter</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/types.jl#L172-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.Clock-Union{Tuple{T}, Tuple{T}} where T&lt;:Number" href="#DiscreteEvents.Clock-Union{Tuple{T}, Tuple{T}} where T&lt;:Number"><code>DiscreteEvents.Clock</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Clock(Œît::T=0.01; t0::U=0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Create a new virtual clock.</p><p><strong>Arguments</strong></p><ul><li><code>Œît::T=0.01</code>: time increment for sampling. Œît can be set later with <code>sample_time!</code>.</li><li><code>t0::U=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p>The created clock has id==1 (master).</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/types.jl#L213-L227">source</a></section><p>You can create clocks easily:</p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful, .Threads

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                  # create a unitless clock (standard)
Clock 1: state=:idle, t=0.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c1 = Clock(1s, unit=minute)  # create a clock with unit [minute]
Clock 1: state=:idle, t=0.0minute, Œît=0.01667minute, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c2 = Clock(1s)               # create a clock with implicit unit [s]
Clock 1: state=:idle, t=0.0s, Œît=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c3 = Clock(t0=60s)           # another clock with implicit unit [s]
Clock 1: state=:idle, t=60.0s, Œît=0.01s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c4 = Clock(1s, t0=1hr)       # here Œît&#39;s unit [s] takes precedence
Clock 1: state=:idle, t=3600.0s, Œît=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre><p>There is a default clock <code>ùê∂</code> for experimental work:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.ùê∂" href="#DiscreteEvents.ùê∂"><code>DiscreteEvents.ùê∂</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">ùê∂</code></pre><p><code>ùê∂</code> (ùê∂ = <code>\itC+tab</code>) is a default clock, ready to use. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.&quot;

julia&gt; ùê∂  # default clock
Clock 1: state=:idle, t=0.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L9-L26">source</a></section><p>You can query the current clock time:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.tau" href="#DiscreteEvents.tau"><code>DiscreteEvents.tau</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tau(clk::Clock=ùê∂)</code></pre><p>Return the current simulation time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents

julia&gt; resetClock!(ùê∂)   # reset the default clock
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.&quot;
julia&gt; tau()            # gives the default clock&#39;s time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L108-L122">source</a></section><h2><a class="nav-anchor" id="Parallel-clocks-1" href="#Parallel-clocks-1">Parallel clocks</a></h2><p>Parallel clocks are virtual clocks with local clocks on parallel threads to support parallel simulations.</p><div class="admonition warning"><div class="admonition-title">Parallel clocks are experimental!</div><div class="admonition-text"><p>Working with parallel clocks over multiple threads is a new feature in v0.3 and cannot yet considered to be stable. Please develop your applications first single-threaded before going parallel. Please report any failures.</p></div></div><p>A parallel clock structure consists of a master (global) clock on thread 1 and <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a>s on all available threads &gt; 1. An active clock is a task running a thread local clock. The thread local clock can schedule and execute events locally.</p><p>The master clock communicates with its parallel active clocks via message channels. It synchronizes time with the local clocks. Tasks (processes and actors) can get access to their thread local clock from it and then need to work only with the local clock.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.PClock" href="#DiscreteEvents.PClock"><code>DiscreteEvents.PClock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">PClock(Œît::T=0.01; t0::U=0.0, unit::FreeUnits=NoUnits) where {T&lt;:Number,U&lt;:Number}</code></pre><p>Setup a clock with parallel clocks on all available threads.</p><p>When running the master clock on thread 1 will synchronize  time between parallel clocks every time increment <code>Œît</code>.</p><p><strong>Arguments</strong></p><ul><li><code>Œît::T=0.01</code>: time increment &gt; 0. If given Œît ‚â§ 0, it gets set to 0.01.</li><li><code>t0::U=0.0</code>: start time for simulation,</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit for explicitl unit setting.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Processes on multiple threads are possible in Julia ‚â• 1.3 and with <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS &gt; 1</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/threads.jl#L175-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.pclock" href="#DiscreteEvents.pclock"><code>DiscreteEvents.pclock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pclock(clk::Clock, id::Int ) :: C where {C&lt;:AbstractClock}
pclock(ac::ActiveClock, id::Int ) :: C where {C&lt;:AbstractClock}</code></pre><p>Get a parallel clock to a given clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: a master clock or</li><li><code>ac::ActiveClock</code>: an active clock,</li><li><code>id::Int=threadid()</code>: thread id, defaults to the caller&#39;s current thread.</li></ul><p><strong>Returns</strong></p><ul><li>the master <a href="#DiscreteEvents.Clock"><code>Clock</code></a> if id==1,</li><li>a parallel <a href="../internals/#DiscreteEvents.ActiveClock"><code>ActiveClock</code></a> else</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/threads.jl#L203-L218">source</a></section><p>Parallel clocks can be identified by their thread number: the master clock works on thread 1, local clocks on parallel threads ‚â• 2. They can be setup and accessed easily:</p><pre><code class="language-julia-repl">julia&gt; @show x=nthreads()-1;
x = nthreads() - 1 = 1

julia&gt; clk = PClock()       # now the clock has (+x) active parallel clocks
Clock 1 (+1): state=:idle, t=0.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; ac2 = pclock(clk, 2) # access the active clock on thread 2
Active clock 2: state=:idle, t=0.0, Œît=0.01, prc:0
   scheduled ev:0, cev:0, sampl:0

julia&gt; ac2.clock            # access their thread local clock
Clock 2: state=:idle, t=0.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; ac2.clock.ac[]       # local clocks can access their active clock
Active clock 2: state=:idle, t=0.0, Œît=0.01, prc:0
   scheduled ev:0, cev:0, sampl:0</code></pre><p>Tasks on parallel threads can get access to the thread local clock by <code>pclock(clk)</code>. Then they can schedule events, <code>delay!</code> or <code>wait!</code> on it as usual.</p><p>You can fork explicitly existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel active clocks and diagnose them.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.fork!" href="#DiscreteEvents.fork!"><code>DiscreteEvents.fork!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fork!(master::Clock)</code></pre><p>Establish copies of a master clock (thread 1) on all parallel threads.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/threads.jl#L116-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.collapse!" href="#DiscreteEvents.collapse!"><code>DiscreteEvents.collapse!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collapse!(master::Clock)</code></pre><p>Transfer the schedules of the parallel clocks to master and them stop them.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If there are processes on other threads registered to parallel clocks, make sure that they aren&#39;t needed anymore before calling <code>collapse</code>. They are not transferred to and cannot be controlled by master.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/threads.jl#L144-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.diagnose" href="#DiscreteEvents.diagnose"><code>DiscreteEvents.diagnose</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diagnose(master::Clock, id::Int)</code></pre><p>Return the stacktrace from parallel clock id.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/threads.jl#L237-L241">source</a></section><h2><a class="nav-anchor" id="Real-time-clocks-1" href="#Real-time-clocks-1">Real time clocks</a></h2><p><code>RTClock</code>s schedule and execute actions on a real (system) time line.</p><div class="admonition warning"><div class="admonition-title">Real time clocks are experimental!</div><div class="admonition-text"><p>Real time clocks are a new feature in v0.3 and thus cannot yet be considered as stable. Please try and report problems.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.RTClock" href="#DiscreteEvents.RTClock"><code>DiscreteEvents.RTClock</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RTClock{E &lt;: ClockEvent} &lt;: AbstractClock</code></pre><p>A real time clock checks every given period for scheduled events and executes them. It has a time in seconds since its start or last reset and uses system time for updating.</p><p>Real time clocks are controlled over channels. Multiple real time clocks can be setup with arbitrary periods (‚â• 1 ms). Real time clocks should not be created directly but rather with <code>CreateRTClock</code>.</p><p><strong>Fields</strong></p><ul><li><code>Timer::Timer</code>:     clock period in seconds, minimum is 0.001 (1 ms)</li><li><code>clock::Clock</code>:     clock work</li><li><code>cmd::Channel{T}</code>:  command channel to asynchronous clock</li><li><code>back::Channel{T}</code>: back channel from async clock</li><li><code>id::Int</code>:          arbitrary id number</li><li><code>thread::Int</code>:      thread the async clock is living in</li><li><code>time::Float64</code>:    clock time since start in seconds</li><li><code>t0::Float64</code>:      system time at clock start in seconds</li><li><code>T::Float64</code>:       clock period in seconds</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/types.jl#L305-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.createRTClock" href="#DiscreteEvents.createRTClock"><code>DiscreteEvents.createRTClock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">createRTClock(T::Float64, id::Int, thrd::Int=nthreads(); ch_size::Int=256)</code></pre><p>Create, start and return a real time Clock.</p><p>The clock takes the current system time and starts to count in seconds with the given period <code>T</code>. Events or sampling functions can then be scheduled to it.</p><p><strong>Arguments</strong></p><ul><li><code>T::Float64</code>:           period (clock resolution) in seconds, T ‚â• 0.001</li><li><code>id::Int</code>:              clock identification number other than 0:(nthreads()-1)</li><li><code>thrd::Int=nthreads()</code>: thread, the clock task should run in</li><li><code>ch_size::Int=256</code>:     clock communication channel size</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/timer.jl#L82-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.stopRTClock" href="#DiscreteEvents.stopRTClock"><code>DiscreteEvents.stopRTClock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stopRTClock(rtc::RTClock)</code></pre><p>Stop a real time clock.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/timer.jl#L110-L114">source</a></section><p>You can work with real time clocks easily:</p><pre><code class="language-julia-repl">julia&gt; rtc = createRTClock(0.01, 99)     # create a real time clock
RTClock 99 on thread 2: state=:idle, t=0.145 s, T=0.01 s, prc:0
   scheduled ev:0, cev:0, sampl:0

julia&gt; sleep(1)

julia&gt; tau(rtc)                          # query its time after a sleep
1.1770405520000082

julia&gt; a = [1]                           # create a mutable variable
1-element Array{Int64,1}:
 1

julia&gt; f(x) = x[1] += 1                  # an incrementing function
f (generic function with 1 method)

julia&gt; event!(rtc, fun(f, a), every, 1)  # increment now and then every second

julia&gt; sleep(3)                          # sleep 3 seconds

julia&gt; a[1]                              # query a
5

julia&gt; stopRTClock(rtc)                  # stop the clock
DiscreteEvents.Stop()</code></pre><h2><a class="nav-anchor" id="Clock-operation-1" href="#Clock-operation-1">Clock operation</a></h2><p>Virtual clocks can be run, stopped or stepped through and thereby used to simulate chains of events.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.run!" href="#DiscreteEvents.run!"><code>DiscreteEvents.run!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(clk::Clock, duration::N) where {N&lt;:Number}</code></pre><p>Run a simulation for a given duration.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L392-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.incr!" href="#DiscreteEvents.incr!"><code>DiscreteEvents.incr!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(clk::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L404-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.resetClock!" href="#DiscreteEvents.resetClock!"><code>DiscreteEvents.resetClock!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resetClock!(clk::Clock, Œît::T=0.01; t0::U=0; &lt;keyword arguments&gt;) where {T&lt;:Number, U&lt;:Number}</code></pre><p>Reset a clock.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>Œît::T=0.01</code>: sample rate</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Œît::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock 1: state=:idle, t=60.0s, Œît=1.0s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; resetClock!(c)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.01.&quot;

julia&gt; c
Clock 1: state=:idle, t=0.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L155-L189">source</a><div><div><pre><code class="language-none">resetClock!(rtc::RTClock)</code></pre><p>Reset a real time clock. Set its time to zero and delete all scheduled and sampling events.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/timer.jl#L14-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.stop!" href="#DiscreteEvents.stop!"><code>DiscreteEvents.stop!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stop!(clk::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L411-L415">source</a><div><div><p>Stop a Prc</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/process.jl#L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.resume!" href="#DiscreteEvents.resume!"><code>DiscreteEvents.resume!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(clk::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L418-L422">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.sync!" href="#DiscreteEvents.sync!"><code>DiscreteEvents.sync!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(clk::Clock, to::Clock=ùê∂)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>clk</code> accordingly. Convert or force clk.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L125-L130">source</a></section><h2><a class="nav-anchor" id="Units-1" href="#Units-1">Units</a></h2><p>You can set time units of a virtual clock:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DiscreteEvents.setUnit!" href="#DiscreteEvents.setUnit!"><code>DiscreteEvents.setUnit!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(clk::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using DiscreteEvents, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock 1: state=:idle, t=60.0, Œît=0.01, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; tau(c)               # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c)               # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/DiscreteEvents.jl/blob/3c4641f9e104417f96b7b41550d8949d4c37af46/src/clock.jl#L33-L84">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This is not yet implemented for parallel clocks!</p></div></div><footer><hr/><a class="previous" href="../setup/"><span class="direction">Previous</span><span class="title">Installation</span></a><a class="next" href="../events/"><span class="direction">Next</span><span class="title">Events</span></a></footer></article></body></html>
