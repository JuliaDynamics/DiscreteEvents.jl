<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../news/">News</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Getting started</a></li><li><a class="toctext" href="../approach/">Approaches to modeling and simulation</a></li><li><a class="toctext" href="../parallel/">Parallel simulations</a></li><li><a class="toctext" href="../timer/">Real time clocks</a></li><li class="current"><a class="toctext" href>User guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Clocks-1">Clocks</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li></ul></li><li><span class="toctext">Performance</span><ul><li><a class="toctext" href="../../performance/performance/">Performance</a></li><li><a class="toctext" href="../../performance/par_perf/">Parallel performance</a></li><li><a class="toctext" href="../../performance/benchmarks/">Benchmarks</a></li></ul></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Examples - overview</a></li><li><a class="toctext" href="../../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../../examples/postoffice/postoffice/">Post Office</a></li><li><a class="toctext" href="../../examples/dicegame/dicegame/">Goldratt&#39;s Dice Game</a></li><li><a class="toctext" href="../../examples/house_heating/house_heating/">House heating</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>User guide</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/manual/usage.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>Simulate.jl</code> runs on Julia versions ≥ v&quot;1.0&quot;. Multithreading requires Julia ≥ v&quot;1.3&quot;.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Simulate" href="#Simulate.Simulate"><code>Simulate.Simulate</code></a> — <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">Simulate</code></pre><p>A Julia package for discrete event simulation.</p><p>The current stable, registered version is installed with</p><pre><code class="language-julia">pkg&gt; add Simulate</code></pre><p>The development version is installed with:</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/Simulate.jl&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/Simulate.jl#L9-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.version" href="#Simulate.version"><code>Simulate.version</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">version</code></pre><p>Gives the package version:</p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; Simulate.version
v&quot;0.3.0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/Simulate.jl#L27-L38">source</a></section><h2><a class="nav-anchor" id="Clocks-1" href="#Clocks-1">Clocks</a></h2><p>A clock in <code>Simulate.jl</code> is an active object residing in a thread and registers function calls or expressions as events, schedules them at a given time or under a given condition and executes them at their time or if conditions are met.</p><ul><li><code>Clock</code> and <code>ActiveClock</code>s have virtual (simulation) time. A <code>Clock</code> can control and synchronizes with <code>ActiveClock</code>s on other threads. It can be started and run for a given time.</li><li><code>RTClock</code>s have real (system) time and operate independently from each other and other clocks. They run continuously at given clock ticks and execute scheduled events if their time becomes due.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Clock" href="#Simulate.Clock"><code>Simulate.Clock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Δt::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::Number=0</code>: time increment. If no Δt is given, the simulation doesn&#39;t tick,   but jumps from event to event. Δt can be set later with <code>sample_time!</code>.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>id::Int</code>: thread on which the clock is running,</li><li><code>state::ClockState</code>: clock state,</li><li><code>time::Float64</code>: clock time,</li><li><code>unit::FreeUnits</code>: time unit,</li><li><code>end_time::Float64</code>: end time for simulation,</li><li><code>Δt::Float64</code>: sampling time, timestep between ticks,</li><li><code>ac::Vector{ClockChannel}</code>: active clocks running on parallel threads,</li><li><code>sc::Schedule</code>: the clock schedule (events, cond events and sampling),</li><li><code>processes::Dict{Any, Prc}</code>: registered <code>Prc</code>es,</li><li><code>tn::Float64</code>: next timestep,</li><li><code>tev::Float64</code>: next event time,</li><li><code>evcount::Int</code>: event counter,</li><li><code>scount::Int</code>: sample counter</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                 # create a unitless clock (standard)
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 minute, Δt=0.01667 minute, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c = Clock(1s)               # create a clock with implicit unit setting
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c = Clock(t0=60s)           # another example of implicit unit setting
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Δt=0.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; c = Clock(1s, t0=1hr)       # if given times with different units, Δt takes precedence
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=3600.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L184-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ActiveClock" href="#Simulate.ActiveClock"><code>Simulate.ActiveClock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ActiveClock(clock::Clock, master::Ref{Clock},
            cmd::Channel{ClockEvent}, ans::Channel{ClockEvent})</code></pre><p>A thread specific clock which can be operated via a channel.</p><p><strong>Fields</strong></p><ul><li><code>clock::Clock</code>: the thread specific clock,</li><li><code>master::Ref{Clock}</code>: a pointer to the master clock (on thread 1),</li><li><code>cmd::Channel{ClockEvent}</code>: the command channel from master,</li><li><code>ans::Channel{ClockEvent}</code>: the response channel to master.</li><li><code>id::Int</code>: the id in master&#39;s ac array,</li><li><code>thread::Int</code>: the thread, the active clock runs on.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>You should not setup an <code>ActiveClock</code> explicitly. Rather this is done implicitly by <a href="#Simulate.fork!"><code>fork!</code></a>ing a <a href="#Simulate.Clock"><code>Clock</code></a> to other available threads or directly with <a href="#Simulate.PClock"><code>PClock</code></a>. It then can be accessed via <a href="#Simulate.pclock"><code>pclock</code></a> as in the following example.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; clk = Clock()
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0


julia&gt; fork!(clk)

julia&gt; clk    #  ⬇ you got 3 parallel active clocks
Clock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0


julia&gt; clk = PClock()
Clock thread 1 (+ 3 ac): state=Simulate.Undefined(), t=0.0 , Δt=0.01 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; pclock(clk, 1)    # get access to the 1st active clock (on thread 2)
Active clock 1 on thrd 2: state=Simulate.Idle(), t=0.0 , Δt=0.01 , prc:0
   scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L276-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.RTClock" href="#Simulate.RTClock"><code>Simulate.RTClock</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RTClock{T &lt;: ClockEvent} &lt;: AbstractClock</code></pre><p>Real time clocks use system time for time keeping and are controlled over a channel. They are independent from each other and other clocks and run asynchronously as tasks on arbitrary threads. Multiple real time clocks can be setup with arbitrary frequencies to do different things.</p><p><strong>Fields</strong></p><ul><li><code>clock::Clock</code>:</li><li><code>cmd::Channel{T}</code>:</li><li><code>back::Channel{T}</code>:</li><li><code>id::Int</code>:</li><li><code>thread::Int</code>:</li><li><code>t0::Float64</code>:</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L331-L346">source</a></section><p>Clocks have the following substructures:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Schedule" href="#Simulate.Schedule"><code>Simulate.Schedule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Schedule()</code></pre><p>A Schedule contains events, conditional events and sampling functions to be executed or evaluated on the clock&#39;s time line.</p><p><strong>Fields</strong></p><ul><li><code>events::PriorityQueue{DiscreteEvent,Float64}</code>: scheduled events,</li><li><code>cevents::Array{DiscreteCond,1}</code>: conditional events to evaluate at each tick,</li><li><code>samples::Array{Sample,1}</code>: sampling expressions to evaluate at each tick,</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L146-L156">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ClockChannel" href="#Simulate.ClockChannel"><code>Simulate.ClockChannel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClockChannel</code></pre><p>Provide a channel to an active clock or a real time clock.</p><p><strong>Fields</strong></p><ul><li><code>ref::Ref{Task}</code>: a pointer to an active clock,</li><li><code>ch::Channel</code>: a communication channel to an active clock,</li><li><code>id::Int</code>: the thread id of the active clock.</li><li><code>done::Bool</code>: flag indicating if the active clock has completed its cycle.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L165-L175">source</a></section><p>You can set time units and query the current clock time. There is a default clock <code>𝐶</code>, which can be used for experimental work. <code>RTC</code> can be used to setup and control real time Clocks.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setUnit!" href="#Simulate.setUnit!"><code>Simulate.setUnit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(clk::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; tau(c) # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c) # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L34-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau" href="#Simulate.tau"><code>Simulate.tau</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tau(clk::Clock=𝐶)</code></pre><p>Return the current simulation time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;
julia&gt; tau() # gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L109-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.𝐶" href="#Simulate.𝐶"><code>Simulate.𝐶</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">𝐶</code></pre><p><code>𝐶</code> (𝐶 = <code>\itC</code>+<code>tab</code>) is the default simulation clock. If you do one simulation at a time, you can use it for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(𝐶)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;

julia&gt; 𝐶  # default clock
Clock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L9-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.RTC" href="#Simulate.RTC"><code>Simulate.RTC</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">RTC::Vector{ClockChannel}</code></pre><p>Real time clocks are registered to RTC and can be accessed and operated through it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/timer.jl#L9-L14">source</a></section><p>You can create a clock with parallel active clocks on all available threads or fork existing clocks to other threads or collapse them if no longer needed. You can get direct access to parallel clocks and diagnose them.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.PClock" href="#Simulate.PClock"><code>Simulate.PClock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">PClock(Δt::Number=0.01; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Setup a clock with parallel clocks on all available threads.</p><p><strong>Arguments</strong></p><ul><li><code>Δt::Number=0.01</code>: time increment. For parallel clocks Δt has to be &gt; 0.   If given Δt ≤ 0 it is set to 0.01.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Δt as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Processes on multiple threads are possible in Julia ≥ 1.3 and with <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS &gt; 1</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/threads.jl#L161-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.fork!" href="#Simulate.fork!"><code>Simulate.fork!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fork!(master::Clock)</code></pre><p>Establish copies of a clock on all parallel threads and operate them as active clocks under control of the master clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: the master clock, must be on thread 1</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/threads.jl#L98-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.pclock" href="#Simulate.pclock"><code>Simulate.pclock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pclock(clk::Clock, id::Int ) :: AbstractClock
pclock(ac::ActiveClock, id::Int ) :: AbstractClock</code></pre><p>Get a parallel clock to a given clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: a master clock or</li><li><code>ac::ActiveClock</code>: an active clock,</li><li><code>id::Int=threadid()</code>: thread id, defaults to the caller&#39;s current thread.</li></ul><p><strong>Returns</strong></p><ul><li>the master <code>Clock</code> if id==0,</li><li>a parallel <code>ActiveClock</code> else</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/threads.jl#L189-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.collapse!" href="#Simulate.collapse!"><code>Simulate.collapse!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collapse!(master::Clock)</code></pre><p>Transfer the schedules of the parallel clocks to master and them stop them.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If there are processes on other threads registered to parallel clocks, make sure that they aren&#39;t needed anymore before calling <code>collapse</code>. They are not transferred to and cannot be controlled by master.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/threads.jl#L130-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.diag" href="#Simulate.diag"><code>Simulate.diag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diag(clk::Clock, id::Int)</code></pre><p>Return the stacktrace from a parallel clock.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: a master clock,</li><li><code>id::Int</code>: the id of a parallel clock.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/threads.jl#L224-L232">source</a></section><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>Directly accessing the <code>clock</code> substructure of parallel <code>ActiveClock</code>s is possible but not recommended since it breaks parallel operation. The right way is to pass <code>event!</code>s to the <code>ActiveClock</code>-variable. The communication then happens over the channel to the <code>ActiveClock</code> as it should be.</p><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Julia expressions and functions can be scheduled as events on the clock&#39;s timeline and are triggered at a given simulation time or under conditions which may become true during simulation.</p><p>Functions and expressions can be scheduled for execution</p><ol><li>at given clock times and</li><li>under specified conditions.</li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.AbstractEvent" href="#Simulate.AbstractEvent"><code>Simulate.AbstractEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>supertype for events</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.DiscreteEvent" href="#Simulate.DiscreteEvent"><code>Simulate.DiscreteEvent</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscreteEvent{T&lt;:Action} &lt;: AbstractEvent</code></pre><p>A discrete event is a function or an expression or a tuple of them to be executed at an event time.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ex::T</code>: a function or an expression or a tuple of them,</li><li><code>scope::Module</code>: evaluation scope,</li><li><code>t::Float64</code>: event time,</li><li><code>Δt::Float64</code>: repeat rate with for repeating events.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L42-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.DiscreteCond" href="#Simulate.DiscreteCond"><code>Simulate.DiscreteCond</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscreteCond{S&lt;:Action, T&lt;:Action} &lt;: AbstractEvent</code></pre><p>A condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.</p><p><strong>Arguments, fields</strong></p><ul><li><code>cond::S</code>: a conditional function or an expression or a tuple of them   (conditions must evaluate to <code>Bool</code>),</li><li><code>ex::T</code>: a function or an expression or a tuple of them to be executed   if conditions are met,</li><li><code>scope::Module</code>: evaluation scope</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L63-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Timing" href="#Simulate.Timing"><code>Simulate.Timing</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time,</li><li><code>after</code>: schedule an event a given time after current time,</li><li><code>every</code>: schedule an event every given time from now on,</li><li><code>before</code>: a timed condition is true before a given time,</li><li><code>until</code>: delay until t.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.fun" href="#Simulate.fun"><code>Simulate.fun</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fun(f::Function, args..., kwargs...)</code></pre><p>Saves a function and its arguments for later execution.</p><p><strong>Arguments</strong></p><p><code>fun</code> can take any arguments. If you want <code>f</code> at execution time to have current arguments you can give symbols, expressions or other <code>fun</code>s. They are then evaluated just before being passed to f. There is one exception: if f is an <code>event!</code>, its arguments are not evaluated before execution.</p><div class="admonition warn"><div class="admonition-title">Evaluating symbols and expressions is slow</div><div class="admonition-text"></div></div><p>It should be avoided in time critical parts of applications. You will get a one time warning if you use that feature. See the Performance section in the documentation.</p><p><strong>Returns</strong></p><p>It returns a closure of f(args..., kwargs...) which has to be called with a <code>Module</code> argument (for evaluation scope of symbols and expressions).</p><p><strong>Examples</strong></p><pre><code class="language-julia"></code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/fclosure.jl#L54-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Action" href="#Simulate.Action"><code>Simulate.Action</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">Action</code></pre><p>An action is either an <code>Expr</code> or a <code>Function</code> or a <code>Tuple</code> of them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!" href="#Simulate.event!"><code>Simulate.event!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">event!</code></pre><p>An event! is a Julia function or expression or a tuple of them to execute at a given event time or under given conditions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/fclosure.jl#L11-L16">source</a></section><p>Functions and expressions can be given to events on their own or in tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(fun(f, 1, 2, 3, diff=pi), every, 1)  # one fun
    event!((:(i += 1), fun(g, j)), [:(tau() ≥ 50), fun(isready, input), :(a ≤ 10)]) # two funs under three conditions
end</code></pre><p>All given functions or expressions are then called or evaluated at a given simulation time or when during simulation the given conditions become true.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Evaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. See <a href="../../performance/performance/">Performance</a>. This functionality may be removed entirely in a future version. (Please write an <a href="https://github.com/pbayer/Simulate.jl/issues">issue</a> if you want to keep it.)</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since conditions often are not met exactly you should prefer inequalities like &lt;, ≤, ≥, &gt; to equality == in order to get sure that a fulfilled condition can be detected, e.g. <code>:(tau() ≥ 100)</code> is preferable to <code>:(tau() == 100)</code>.</p></div></div><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Δt.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Sample" href="#Simulate.Sample"><code>Simulate.Sample</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Sample{T&lt;:Action} &lt;: AbstractEvent</code></pre><p>Sampling functions or expressions are called at sampling time.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ex&lt;:Action</code>: expression or function or a tuple of them to be called   at sample time,</li><li><code>scope::Module</code>: evaluation scope.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L82-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample_time!" href="#Simulate.sample_time!"><code>Simulate.sample_time!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!([clk::Clock], Δt::Number)</code></pre><p>set the clock&#39;s sample rate starting from now (<code>tau(clk)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not supplied, set the sample rate on 𝐶,</li><li><code>Δt::Number</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L245-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.periodic!" href="#Simulate.periodic!"><code>Simulate.periodic!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">periodic!([clk::Clock], ex::T, Δt::Number=clk.Δt;
        scope::Module=Main, spawn=false) where {T&lt;:Action}
periodic!(ac::ActiveClock, ex::T, Δt::Number=ac.clock.Δt; kw...) where {T&lt;:Action}</code></pre><p>Register a function or expression for periodic execution at the clock`s sample rate.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>, <code>ac::ActiveClock</code>: if not supplied, it samples on 𝐶,</li><li><code>ex&lt;:Action</code>: an expression or function or a tuple of them,</li><li><code>Δt::Number=clk.Δt</code>: set the clock&#39;s sampling rate, if no Δt is given, it takes   the current sampling rate, if that is 0, it calculates one,</li><li><code>scope::Module=Main</code>: optional, an evaluation scope for a given expression.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/schedule.jl#L150-L164">source</a></section><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can be registered and run as processes. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Prc" href="#Simulate.Prc"><code>Simulate.Prc</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Prc( id, f::Function, arg...; kw...)</code></pre><p>Prepare a function to run as a process in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>id</code>: some unique identification for registration,</li><li><code>task::Union{Task,Nothing}</code>: a task structure,</li><li><code>clk::Union{AbstractClock,Nothing}</code>: clock where the process is registered,</li><li><code>state::ClockState</code>: process state,</li><li><code>f::Function</code>: a function <code>f(clk, arg...; kw...)</code>, must take <code>clk</code> as its   first argument,</li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function started as a Prc most often runs in a loop. It has to give back control by e.g. doing a <code>take!(input)</code> or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will starve everything else!</p></div></div><div class="admonition warn"><div class="admonition-title">Warn</div><div class="admonition-text"><p>That <code>f</code> nust take <code>clk</code> as first argument is a breaking change in v0.3!</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L112-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ClockException" href="#Simulate.ClockException"><code>Simulate.ClockException</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClockException(ev::ClockEvent, value=nothing)</code></pre><p>Define a ClockException, which can be thrown to processes.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ev::ClockEvent</code>: delivers an event to the interrupted task</li><li><code>value=nothing</code>: deliver some other value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/types.jl#L97-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.process!" href="#Simulate.process!"><code>Simulate.process!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!([clk::Clock], p::Prc, cycles=Inf; spawn::Bool=false)</code></pre><p>Register a <a href="#Simulate.Prc"><code>Prc</code></a> to a clock, start it as an asynchronous process and return the <code>id</code> it was registered with. It can then be found under <code>clk.processes[id]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::AbstractClock</code>: <code>Clock</code> or <code>ActiveClock</code>, if not provided, the process runs   under <code>𝐶</code>,</li><li><code>p::Prc</code>: it contains a function and its arguments,</li><li><code>cycles::Number=Inf</code>: number of cycles the process should run,</li><li><code>spawn::Bool=false</code>: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>spawn</code>ing a process is possible only with parallel clocks setup with <a href="#Simulate.PClock"><code>PClock</code></a> or <a href="#Simulate.fork!"><code>fork!</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L103-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.interrupt!" href="#Simulate.interrupt!"><code>Simulate.interrupt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interrupt!(p::Prc, ev::ClockEvent, value=nothing)</code></pre><p>Interrupt a <code>Prc</code> by throwing a <code>ClockException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L200-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}" href="#Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Stop a Prc</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L210">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-…-1" href="#Delay-and-wait-…-1">Delay and wait …</a></h3><p>Processes do not need to handle their events explicitly, but can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> … on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.delay!" href="#Simulate.delay!"><code>Simulate.delay!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!(clk::Clock, t::Number)</code></pre><p>Delay a process for a time interval <code>t</code> on the clock <code>clk</code>. Suspend the calling process until being reactivated by the clock at the appropriate time.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not provided, the delay goes to <code>𝐶</code>.</li><li><code>t::Number</code>: the time interval for the delay.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L133-L143">source</a><div><div><pre><code class="language-none">delay!(clk::Clock, T::Timing, t::Number)</code></pre><p>Used for delaying a process <em>until</em> a given time t.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if no clock is given, the delay goes to 𝐶,</li><li><code>T::Timing</code>: only <code>until</code> is accepted,</li><li><code>t::Number</code>: delay until time t if t &gt; clk.time, else give a warning.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L153-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.wait!" href="#Simulate.wait!"><code>Simulate.wait!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!(clk::Clock, cond::Action; scope::Module=Main)</code></pre><p>Wait on a clock for a condition to become true. Suspend the calling process until the given condition is true.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if no clock is supplied, the delay goes to <code>𝐶</code>,</li><li><code>cond::Action</code>: a condition is an expression or function   or an array or tuple of them. It is true only if all expressions or functions   therein return true,</li><li><code>scope::Module=Main</code>: evaluation scope for given expressions.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L176-L189">source</a></section><h3><a class="nav-anchor" id="Now-1" href="#Now-1">Now</a></h3><p>Processes in a simulation want their IO-operations to finish before the clock proceeds. Therefore they must enclose those operations in a <code>now!</code> call.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.now!" href="#Simulate.now!"><code>Simulate.now!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">now!(clk::Clock, op::Action)</code></pre><p>Tell the clock to execute an operation. Thus it cannot proceed before the op is finished.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This is needed for IO-operations of tasks. IO-operations yield the task to the scheduler and the scheduler may invoke the clock before giving control back to the task. In that case the clock will proceed and the task has gone out of sync with the clock. Use <code>now!</code> to avoid this situation!</p></div></div><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>,</li><li><code>op::Action</code>: operation to execute.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/process.jl#L213-L228">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed … We can also step through a simulation, stop, resume or reset it.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.reset!" href="#Simulate.reset!"><code>Simulate.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(clk::Clock, Δt::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)</code></pre><p>reset a clock</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>Δt::Number=0</code>: time increment</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Δt::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=60.0 s, Δt=1.0 s, prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; reset!(c)
&quot;clock reset to t₀=0.0, sampling rate Δt=0.0.&quot;

julia&gt; c
Clock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Δt=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L159-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.incr!" href="#Simulate.incr!"><code>Simulate.incr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(clk::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L405-L409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.run!" href="#Simulate.run!"><code>Simulate.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(clk::Clock, duration::Number)</code></pre><p>Run a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L393-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Clock}" href="#Simulate.stop!-Tuple{Clock}"><code>Simulate.stop!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(clk::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L412-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.resume!" href="#Simulate.resume!"><code>Simulate.resume!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(clk::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L419-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sync!" href="#Simulate.sync!"><code>Simulate.sync!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(clk::Clock, to::Clock=𝐶)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>clk</code> accordingly. Convert or force clk.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/3026907f4e311bd120e233041a10b1585613eae3/src/clock.jl#L128-L134">source</a></section><footer><hr/><a class="previous" href="../timer/"><span class="direction">Previous</span><span class="title">Real time clocks</span></a><a class="next" href="../../performance/performance/"><span class="direction">Next</span><span class="title">Performance</span></a></footer></article></body></html>
