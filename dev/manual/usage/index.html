<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../news/">News</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Getting started</a></li><li><a class="toctext" href="../approach/">Approaches to modeling and simulation</a></li><li><a class="toctext" href="../parallel/">Parallel simulations</a></li><li class="current"><a class="toctext" href>User guide</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#The-clock-1">The clock</a></li><li><a class="toctext" href="#Events-1">Events</a></li><li><a class="toctext" href="#Processes-1">Processes</a></li><li><a class="toctext" href="#Continuous-sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Running-simulations-1">Running simulations</a></li></ul></li><li><span class="toctext">Performance</span><ul><li><a class="toctext" href="../../performance/performance/">Performance</a></li><li><a class="toctext" href="../../performance/par_perf/">Parallel performance</a></li><li><a class="toctext" href="../../performance/benchmarks/">Benchmarks</a></li></ul></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Examples - overview</a></li><li><a class="toctext" href="../../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../../examples/postoffice/postoffice/">Post Office</a></li><li><a class="toctext" href="../../examples/dicegame/dicegame/">Goldratt&#39;s Dice Game</a></li><li><a class="toctext" href="../../examples/house_heating/house_heating/">House heating</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>User guide</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/manual/usage.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-guide-1" href="#User-guide-1">User guide</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p><code>Simulate.jl</code> runs on Julia versions ‚â• v&quot;1.0&quot;.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Simulate" href="#Simulate.Simulate"><code>Simulate.Simulate</code></a> ‚Äî <span class="docstring-category">Module</span>.</div><div><div><pre><code class="language-julia">Simulate</code></pre><p>A Julia package for discrete event simulation.</p><p>The current stable, registered version is installed with</p><pre><code class="language-julia">pkg&gt; add Simulate</code></pre><p>The development version is installed with:</p><pre><code class="language-julia">pkg&gt; add(&quot;https://github.com/pbayer/Simulate.jl&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/Simulate.jl#L9-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.version" href="#Simulate.version"><code>Simulate.version</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">version</code></pre><p>Gives the package version:</p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; Simulate.version
v&quot;0.3.0&quot;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/Simulate.jl#L27-L38">source</a></section><h2><a class="nav-anchor" id="The-clock-1" href="#The-clock-1">The clock</a></h2><p>A clock in <code>Simulate.jl</code> is an active object residing in a thread and continuously registering function calls or expressions as events, scheduling them for execution or evaluation at a given time or under a given condition and executing them at their time or if conditions are met.</p><p>A clock can be created. It is operated as a state machine. It can control active clocks on other threads.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Clock" href="#Simulate.Clock"><code>Simulate.Clock</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Clock(Œît::Number=0; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Create a new simulation clock.</p><p><strong>Arguments</strong></p><ul><li><code>Œît::Number=0</code>: time increment. If no Œît is given, the simulation doesn&#39;t tick,   but jumps from event to event. Œît can be set later with <code>sample_time!</code>.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><p><strong>Fields</strong></p><ul><li><code>id::Int</code>: thread on which the clock is running,</li><li><code>state::ClockState</code>: clock state,</li><li><code>time::Float64</code>: clock time,</li><li><code>unit::FreeUnits</code>: time unit,</li><li><code>end_time::Float64</code>: end time for simulation,</li><li><code>Œît::Float64</code>: sampling time, timestep between ticks,</li><li><code>ac::Vector{AC}</code>: active clocks running on parallel threads,</li><li><code>sc::Schedule</code>: the clock schedule (events, cond events and sampling),</li><li><code>processes::Dict{Any, Prc}</code>: registered <code>Prc</code>es,</li><li><code>tn::Float64</code>: next timestep,</li><li><code>tev::Float64</code>: next event time,</li><li><code>evcount::Int</code>: event counter,</li><li><code>scount::Int</code>: sample counter</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; c = Clock()                 # create a unitless clock (standard)
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; Simulate.init!(c)           # initialize it explicitly (normally done implicitly)
Simulate.Idle()

julia&gt; c = Clock(1s, unit=minute)  # create a clock with units, does conversions automatically
Clock: state=Simulate.Undefined(), time=0.0, unit=minute, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.016666666666666666

julia&gt; c = Clock(1s)               # create a clock with implicit unit setting
Clock: state=Simulate.Undefined(), time=0.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0

julia&gt; c = Clock(t0=60s)           # another example of implicit unit setting
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; c = Clock(1s, t0=1hr)       # if given times with different units, Œît takes precedence
Clock: state=Simulate.Undefined(), time=3600.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L243-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.PClock" href="#Simulate.PClock"><code>Simulate.PClock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">PClock(Œît::Number=0.01; t0::Number=0, unit::FreeUnits=NoUnits)</code></pre><p>Setup a clock with parallel clocks on all available threads.</p><p><strong>Arguments</strong></p><ul><li><code>Œît::Number=0.01</code>: time increment. For parallel clocks Œît has to be &gt; 0.   If given Œît ‚â§ 0 it is set to 0.01.</li><li><code>t0::Number=0</code>: start time for simulation</li><li><code>unit::FreeUnits=NoUnits</code>: clock time unit. Units can be set explicitely by   setting e.g. <code>unit=minute</code> or implicitly by giving Œît as a time or else setting   t0 to a time, e.g. <code>t0=60s</code>.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Processes on multiple threads are possible in Julia ‚â• 1.3 and with <a href="https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_NUM_THREADS-1"><code>JULIA_NUM_THREADS &gt; 1</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L333-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ActiveClock" href="#Simulate.ActiveClock"><code>Simulate.ActiveClock</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ActiveClock(clock::Clock, master::Ref{Clock},
            cmd::Channel{ClockEvent}, ans::Channel{ClockEvent})</code></pre><p>A thread specific clock which can be operated via a channel.</p><p><strong>Fields</strong></p><ul><li><code>clock::Clock</code>: the thread specific clock,</li><li><code>master::Ref{Clock}</code>: a pointer to the master clock (on thread 1),</li><li><code>cmd::Channel{ClockEvent}</code>: the command channel from master,</li><li><code>ans::Channel{ClockEvent}</code>: the response channel to master.</li><li><code>id::Int</code>: the id in master&#39;s ac array,</li><li><code>thread::Int</code>: the thread, the active clock runs on.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L373-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.pclock" href="#Simulate.pclock"><code>Simulate.pclock</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pclock(clk::Clock, id::Int ) :: AbstractClock
pclock(ac::ActiveClock, id::Int ) :: AbstractClock</code></pre><p>Get a parallel clock to a given clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: a master clock or</li><li><code>ac::ActiveClock</code>: an active clock,</li><li><code>id::Int=threadid()</code>: thread id, defaults to the caller&#39;s current thread.</li></ul><p><strong>Returns</strong></p><ul><li>the master <code>Clock</code> if id==0,</li><li>a parallel <code>ActiveClock</code> else</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/threads.jl#L168-L183">source</a></section><p>Clocks have the following substructures:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Schedule" href="#Simulate.Schedule"><code>Simulate.Schedule</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Schedule()</code></pre><p>A Schedule contains events, conditional events and sampling functions to be executed or evaluated on the clock&#39;s time line.</p><p><strong>Fields</strong></p><ul><li><code>events::PriorityQueue{DiscreteEvent,Float64}</code>: scheduled events,</li><li><code>cevents::Array{DiscreteCond,1}</code>: conditional events to evaluate at each tick,</li><li><code>samples::Array{Sample,1}</code>: sampling expressions to evaluate at each tick,</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L203-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.AC" href="#Simulate.AC"><code>Simulate.AC</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AC</code></pre><p>AC is a channel to an active clock. An active clock is a task running on a parallel thread and operating a (parallel) clock. It is controlled by the master clock (on thread 1) via messages over a channel.</p><p><strong>Fields</strong></p><ul><li><code>ref::Ref{Task}</code>: a pointer to an active clock,</li><li><code>ch::Channel</code>: a communication channel to an active clock,</li><li><code>id::Int</code>: the thread id of the active clock.</li><li><code>done::Bool</code>: flag indicating if the active clock has completed its cycle.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L222-L234">source</a></section><p>There is a default central clock ùê∂. You can set time units and query the current simulation time.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ùê∂" href="#Simulate.ùê∂"><code>Simulate.ùê∂</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">ùê∂
Clk</code></pre><p><code>ùê∂</code> (ùê∂ = \itC+[tab]) or <code>Clk</code> is the central simulation clock. If you do one simulation at a time, you can use ùê∂ or Clk for time keeping.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;

julia&gt; ùê∂  # central clock
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; ùê∂ === Clk
true
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L86-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.setUnit!" href="#Simulate.setUnit!"><code>Simulate.setUnit!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">setUnit!(clk::Clock, new::FreeUnits)</code></pre><p>set a clock to a new time unit in <code>Unitful</code>. If necessary convert current clock times to the new unit.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>new::FreeUnits</code>: new is one of <code>ms</code>, <code>s</code>, <code>minute</code> or <code>hr</code> or another Unitful   <code>Time</code> unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: Time, s, minute, hr

julia&gt; c = Clock(t0=60)     # setup a new clock with t0=60
Clock: state=Simulate.Undefined(), time=60.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; tau(c) # current time is 60.0 NoUnits
60.0

julia&gt; setUnit!(c, s)       # set clock unit to Unitful.s
60.0 s

julia&gt; tau(c) # current time is now 60.0 s
60.0 s

julia&gt; setUnit!(c, minute)  # set clock unit to Unitful.minute
1.0 minute

julia&gt; tau(c)               # current time is now 1.0 minute
1.0 minute

julia&gt; typeof(tau(c))       # tau(c) now returns a time Quantity ...
Quantity{Float64,ùêì,Unitful.FreeUnits{(minute,),ùêì,nothing}}

julia&gt; isa(tau(c), Time)
true

julia&gt; uconvert(s, tau(c))  # ... which can be converted to other time units
60.0 s

julia&gt; tau(c).val           # it has a value of 1.0
1.0

julia&gt; c.time               # internal clock time is set to 1.0 (a Float64)
1.0

julia&gt; c.unit               # internal clock unit is set to Unitful.minute
minute</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L10-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.tau-Tuple{Clock}" href="#Simulate.tau-Tuple{Clock}"><code>Simulate.tau</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">tau(clk::Clock=ùê∂)</code></pre><p>Return the current simulation time.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; reset!(ùê∂)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;
julia&gt; tau() # gives the central time
0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L112-L128">source</a></section><p>You can fork single clocks to multiple threads or collapse them if no longer needed and diagnose parallel clocks.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.fork!" href="#Simulate.fork!"><code>Simulate.fork!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">fork!(master::Clock)</code></pre><p>Establish copies of a clock on all parallel threads and operate them as active clocks under control of the master clock.</p><p><strong>Arguments</strong></p><ul><li><code>master::Clock</code>: the master clock, must be on thread 1</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/threads.jl#L101-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.collapse!" href="#Simulate.collapse!"><code>Simulate.collapse!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">collapse!(master::Clock)</code></pre><p>Transfer the schedules of the parallel clocks to master and them stop them.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If there are processes on other threads registered to parallel clocks, make sure that they aren&#39;t needed anymore before calling <code>collapse</code>. They are not transferred to and cannot be controlled by master.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/threads.jl#L133-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.diag" href="#Simulate.diag"><code>Simulate.diag</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diag(clk::Clock, id::Int)</code></pre><p>Return the stacktrace from a parallel clock.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: a master clock,</li><li><code>id::Int</code>: the id of a parallel clock.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/threads.jl#L203-L211">source</a></section><h2><a class="nav-anchor" id="Events-1" href="#Events-1">Events</a></h2><p>Julia expressions and functions can be scheduled as events on the clock&#39;s timeline and are triggered at a given simulation time or under conditions which may become true during simulation.</p><p>Functions and expressions can be scheduled for execution</p><ol><li>at given clock times and</li><li>under specified conditions.</li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.DiscreteEvent" href="#Simulate.DiscreteEvent"><code>Simulate.DiscreteEvent</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscreteEvent{T&lt;:Action}</code></pre><p>A discrete event is a function or an expression or a tuple of them to be executed at an event time.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ex::T</code>: a function or an expression or a tuple of them,</li><li><code>scope::Module</code>: evaluation scope,</li><li><code>t::Float64</code>: event time,</li><li><code>Œît::Float64</code>: repeat rate with for repeating events.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L90-L102">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.DiscreteCond" href="#Simulate.DiscreteCond"><code>Simulate.DiscreteCond</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscreteCond{S&lt;:Action, T&lt;:Action}</code></pre><p>A condition to be evaluated repeatedly with expressions or functions to be executed if conditions are met.</p><p><strong>Arguments, fields</strong></p><ul><li><code>cond::S</code>: a conditional function or an expression or a tuple of them   (conditions must evaluate to <code>Bool</code>),</li><li><code>ex::T</code>: a function or an expression or a tuple of them to be executed   if conditions are met,</li><li><code>scope::Module</code>: evaluation scope</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L112-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Timing" href="#Simulate.Timing"><code>Simulate.Timing</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Timing</code></pre><p>Enumeration type for scheduling events and timed conditions:</p><ul><li><code>at</code>: schedule an event at a given time,</li><li><code>after</code>: schedule an event a given time after current time,</li><li><code>every</code>: schedule an event every given time from now on,</li><li><code>before</code>: a timed condition is true before a given time,</li><li><code>until</code>: delay until t.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Fun" href="#Simulate.Fun"><code>Simulate.Fun</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Fun(f::Function, arg...; kw...)</code></pre><p>Store a function and its arguments for being called later as an event.</p><p><strong>Arguments, fields</strong></p><ul><li><code>f::Function</code>:  event function to be executed at event time,</li><li><code>arg...</code>: arguments to the event function,</li><li><code>kw...</code>: keyword arguments to the event function.</li></ul><p>Arguments and keyword arguments can be 1) values or variables mixed with 2) symbols, expressions or even other functions. In the 2nd cases they are evaluated at event time before they are passed to the event function.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Composite types or variables given symbolically can change until they are evaluated later at event time.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; f(a,b,c; d=4, e=5) = a+b+c+d+e       # if you define a function and ...
f (generic function with 1 method)

julia&gt; sf = SF(f, 10, 20, 30, d=14, e=15);  # store it as Fun

julia&gt; sf.f(sf.arg...; sf.kw...)         # it can be executed later
89

julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2);          # we set up a dictionary

julia&gt; g(t) = t[:a] + t[:b]                 # and a function adding :a and :b
g (generic function with 1 method)

julia&gt; g(d)                                 # our add function gives 3
3

julia&gt; ff = Fun(g, d);              # we set up a Fun

julia&gt; d[:a] = 10;                          # later somehow we change d

julia&gt; ff.f(ff.arg...)                   # calling ff then gives a different result
12</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L31-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Action" href="#Simulate.Action"><code>Simulate.Action</code></a> ‚Äî <span class="docstring-category">Constant</span>.</div><div><div><p>An action is either an <code>Expr</code> or a <code>Fun</code> or a <code>Tuple</code> of them.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L87">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.event!" href="#Simulate.event!"><code>Simulate.event!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">event!([clk::Clock], ex::Action, t::Number;
       scope::Module=Main, cycle::Number=0.0, spawn=false)::Float64
event!([clk::Clock], ex::Action, T::Timing, t::Number; kw...)</code></pre><p>Schedule an event for a given simulation time.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: it not supplied, the event is scheduled to ùê∂,</li><li><code>ex::Action</code>: an expression or Fun or a tuple of them,</li><li><code>T::Timing</code>: a timing, one of <code>at</code>, <code>after</code> or <code>every</code>,</li><li><code>t::Real</code> or <code>t::Time</code>: simulation time, if t &lt; clk.time set t = clk.time,</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>scope::Module=Main</code>: scope for expressions to be evaluated in,</li><li><code>cycle::Float64=0.0</code>: repeat cycle time for an event,</li><li><code>spawn=false</code>: it true spawn the event at other available threads.</li></ul><p><strong>returns</strong></p><p>Scheduled internal simulation time (unitless) for that event. May return a time <code>&gt; t</code> from repeated applications of <code>nextfloat(t)</code> if there are events scheduled for <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s, minute, hr

julia&gt; myfunc(a, b) = a+b
myfunc (generic function with 1 method)

julia&gt; event!(ùê∂, Fun(myfunc, 1, 2), 1) # a 1st event to 1
1.0
julia&gt; event!(ùê∂, Fun(myfunc, 2, 3), 1) #  a 2nd event to the same time
1.0000000000000002

julia&gt; event!(ùê∂, Fun(myfunc, 3, 4), 1s)
Warning: clock has no time unit, ignoring units
1.0000000000000004

julia&gt; setUnit!(ùê∂, s)
0.0 s

julia&gt; event!(ùê∂, Fun(myfunc, 4, 5), 1minute)
60.0

julia&gt; event!(Fun(myfunc, 5, 6), after, 1hr)
3600.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L245-L296">source</a><div><div><pre><code class="language-none">event!([clk::Clock], ex::Action, cond::Action; scope::Module=Main)::Float64</code></pre><p>Schedule a conditional event.</p><p>It is executed immediately if the conditions are met, else the condition is checked at each clock tick Œît. A conditional event is triggered only once. After that it is removed from the clock. If no sampling rate Œît is setup, a default sampling rate is setup depending on the scale of the remaining simulation time <span>$Œît = scale(t_r)/100$</span> or <span>$0.01$</span> if <span>$t_r = 0$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if no clock is supplied, the event is scheduled to ùê∂,</li><li><code>ex::Union{SimExpr, Tuple{SimExpr}}</code>: an expression or Fun or a tuple of them,</li><li><code>cond::Union{SimExpr, Tuple{SimExpr}}</code>: a condition is an expression or Fun   or a tuple of them. It is true only if all expressions or Funs   therein return true,</li><li><code>scope::Module=Main</code>: scope for the expressions to be evaluated</li></ul><p><strong>returns</strong></p><p>current simulation time <code>tau(clk)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate

julia&gt; c = Clock()   # create a new clock
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0

julia&gt; event!(c, SF((x)-&gt;println(tau(x), &quot;: now I&#39;m triggered&quot;), c), (@tau c :&gt;= 5))
0.0

julia&gt; c             # a conditional event turns sampling on
Clock: state=Simulate.Undefined(), time=0.0, unit=, events: 0, cevents: 1, processes: 0, sampling: 0, sample rate Œît=0.01

julia&gt; run!(c, 10)   # sampling is not exact, so it takes 501 sample steps to fire the event
5.009999999999938: now I&#39;m triggered
&quot;run! finished with 0 clock events, 501 sample steps, simulation time: 10.0&quot;</code></pre><p>After the event is triggered, sampling is again switched off.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L320-L363">source</a></section><p>Functions and expressions can be given to events on their own or in tuples, even mixed:</p><pre><code class="language-julia">function events()
    event!(:(i += 1), after, 10)  # one expression
    event!(Fun(f, 1, 2, 3, diff=pi), every, 1)  # one Fun
    event!((:(i += 1), Fun(g, j)), [:(tau() ‚â• 50), Fun(isready, input), :(a ‚â§ 10)]) # two Fun under three conditions
end</code></pre><p>All given functions or expressions are then called or evaluated at a given simulation time or when during simulation the given conditions become true.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Evaluating expressions or symbols at global scope is much slower than using <code>Fun</code>s and gives a one time warning. See <a href="../../performance/performance/">Performance</a>. This functionality may be removed entirely in a future version. (Please write an <a href="https://github.com/pbayer/Simulate.jl/issues">issue</a> if you want to keep it.)</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Since conditions often are not met exactly you should prefer inequalities like &lt;, ‚â§, ‚â•, &gt; to equality == in order to get sure that a fulfilled condition can be detected, e.g. <code>:(tau() ‚â• 100)</code> is preferable to <code>:(tau() == 100)</code>.</p></div></div><h2><a class="nav-anchor" id="Processes-1" href="#Processes-1">Processes</a></h2><p>Julia functions can be registered and run as processes. They follow another (the process-oriented) scheme and can be suspended and reactivated by the scheduler if they wait for something or delay. They must not (but are free to) handle and create events explicitly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Prc" href="#Simulate.Prc"><code>Simulate.Prc</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Prc( id, f::Function, arg...; kw...)
alias   SP( id, f::Function, arg...; kw...)</code></pre><p>Prepare a function to run as a process in a simulation.</p><p><strong>Arguments, fields</strong></p><ul><li><code>id</code>: some unique identification for registration,</li><li><code>task::Union{Task,Nothing}</code>: a task structure,</li><li><code>clk::Union{AbstractClock,Nothing}</code>: clock where the process is registered,</li><li><code>state::ClockState</code>: process state,</li><li><code>f::Function</code>: a function <code>f(clk, arg...; kw...)</code>, must take <code>clk</code> as its   first argument,</li><li><code>arg...</code>: further arguments to <code>f</code></li><li><code>kw...</code>: keyword arguments to <code>f</code></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>A function started as a Prc most often runs in a loop. It has to give back control by e.g. doing a <code>take!(input)</code> or by calling <code>delay!</code> etc., which will <code>yield</code> it. Otherwise it will starve everything else!</p></div></div><div class="admonition warn"><div class="admonition-title">Warn</div><div class="admonition-text"><p>That <code>f</code> nust take <code>clk</code> as first argument is a breaking change in v0.3!</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L161-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.ClockException" href="#Simulate.ClockException"><code>Simulate.ClockException</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClockException(ev::ClockEvent, value=nothing)</code></pre><p>Define a ClockException, which can be thrown to processes.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ev::ClockEvent</code>: delivers an event to the interrupted task</li><li><code>value=nothing</code>: deliver some other value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L146-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.process!" href="#Simulate.process!"><code>Simulate.process!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">process!([clk::Clock], p::Prc, cycles=Inf; spawn::Bool=false)</code></pre><p>Register a <a href="#Simulate.Prc"><code>Prc</code></a> to a clock, start it as an asynchronous process and return the <code>id</code> it was registered with. It can then be found under <code>clk.processes[id]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>c::AbstractClock</code>: <code>Clock</code> or <code>ActiveClock</code>, if not provided, the process runs   under <code>ùê∂</code>,</li><li><code>p::Prc</code>: it contains a function and its arguments,</li><li><code>cycles::Number=Inf</code>: number of cycles the process should run,</li><li><code>spawn::Bool=false</code>: if true, the process may be scheduled on another thread   in parallel and registered to the thread specific clock.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>spawn</code>ing a process is possible only with parallel clocks setup with <a href="#Simulate.PClock"><code>PClock</code></a> or <a href="#Simulate.fork!"><code>fork!</code></a>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L103-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.interrupt!" href="#Simulate.interrupt!"><code>Simulate.interrupt!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">interrupt!(p::Prc, ev::ClockEvent, value=nothing)</code></pre><p>Interrupt a <code>Prc</code> by throwing a <code>ClockException</code> to it.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L200-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}" href="#Simulate.stop!-Tuple{Prc,Simulate.ClockEvent}"><code>Simulate.stop!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><p>Stop a Prc</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L210">source</a></section><h3><a class="nav-anchor" id="Delay-and-wait-‚Ä¶-1" href="#Delay-and-wait-‚Ä¶-1">Delay and wait ‚Ä¶</a></h3><p>Processes do not need to handle their events explicitly, but can call <code>delay!</code> or <code>wait!</code> or <code>take!</code> and <code>put!</code> ‚Ä¶ on their channels. This usually comes in handy. They are then suspended until certain conditions are met or requested resources are available.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.delay!" href="#Simulate.delay!"><code>Simulate.delay!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">delay!(clk::Clock, t::Number)</code></pre><p>Delay a process for a time interval <code>t</code> on the clock <code>clk</code>. Suspend the calling process until being reactivated by the clock at the appropriate time.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not provided, the delay goes to <code>ùê∂</code>.</li><li><code>t::Number</code>: the time interval for the delay.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L133-L143">source</a><div><div><pre><code class="language-none">delay!(clk::Clock, T::Timing, t::Number)</code></pre><p>Used for delaying a process <em>until</em> a given time t.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if no clock is given, the delay goes to ùê∂,</li><li><code>T::Timing</code>: only <code>until</code> is accepted,</li><li><code>t::Number</code>: delay until time t if t &gt; clk.time, else give a warning.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L153-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.wait!" href="#Simulate.wait!"><code>Simulate.wait!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">wait!(clk::Clock, cond::Action; scope::Module=Main)</code></pre><p>Wait on a clock for a condition to become true. Suspend the calling process until the given condition is true.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if no clock is supplied, the delay goes to <code>ùê∂</code>,</li><li><code>cond::Action</code>: a condition is an expression or function   or an array or tuple of them. It is true only if all expressions or functions   therein return true,</li><li><code>scope::Module=Main</code>: evaluation scope for given expressions.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L176-L189">source</a></section><h3><a class="nav-anchor" id="Now-1" href="#Now-1">Now</a></h3><p>Processes in a simulation want their IO-operations to finish before the clock proceeds. Therefore they must enclose those operations in a <code>now!</code> call.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.now!" href="#Simulate.now!"><code>Simulate.now!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">now!(clk::Clock, op::Action)</code></pre><p>Tell the clock to execute an operation. Thus it cannot proceed before the op is finished.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This is needed for IO-operations of tasks. IO-operations yield the task to the scheduler and the scheduler may invoke the clock before giving control back to the task. In that case the clock will proceed and the task has gone out of sync with the clock. Use <code>now!</code> to avoid this situation!</p></div></div><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>,</li><li><code>op::Action</code>: operation to execute.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/process.jl#L213-L228">source</a></section><h2><a class="nav-anchor" id="Continuous-sampling-1" href="#Continuous-sampling-1">Continuous sampling</a></h2><p>Functions or expressions can register for sampling and are then executed &quot;continuously&quot; at each clock increment Œît.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.Sample" href="#Simulate.Sample"><code>Simulate.Sample</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Sample{T&lt;:Union{Fun,Expr}}</code></pre><p>A sampling function or expression is called at sampling time.</p><p><strong>Arguments, fields</strong></p><ul><li><code>ex::T</code>: expression or function to be called at sample time,</li><li><code>scope::Module</code>: evaluation scope.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/types.jl#L132-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sample_time!" href="#Simulate.sample_time!"><code>Simulate.sample_time!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_time!([clk::Clock], Œît::Number)</code></pre><p>set the clock&#39;s sample rate starting from now (<code>tau(clk)</code>).</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not supplied, set the sample rate on ùê∂,</li><li><code>Œît::Number</code>: sample rate, time interval for sampling</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L374-L383">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.periodic!" href="#Simulate.periodic!"><code>Simulate.periodic!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">periodic!([clk::Clock], ex::Union{Expr, Fun}, Œît::Number=clk.Œît;
        scope::Module=Main, spawn=false)</code></pre><p>Register a function or expression for periodic execution.</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code>: if not supplied, it samples on ùê∂,</li><li><code>ex::Union{Expr, Fun}</code>: an expression or function,</li><li><code>Œît::Number=clk.Œît</code>: set the clock&#39;s sampling rate, if no Œît is given, it takes   the current sampling rate, if that is 0, it calculates one,</li><li><code>scope::Module=Main</code>: optional, an evaluation scope for a given expression.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L390-L403">source</a></section><h2><a class="nav-anchor" id="Running-simulations-1" href="#Running-simulations-1">Running simulations</a></h2><p>If we run the clock, events are triggered, conditions are evaluated, sampling is done and delays are executed ‚Ä¶ Thus we run a simulation. We can also step through a simulation or stop and resume a clock, reset ist and so on.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.reset!" href="#Simulate.reset!"><code>Simulate.reset!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset!(clk::Clock, Œît::Number=0; t0::Number=0, hard::Bool=true, unit=NoUnits)</code></pre><p>reset a clock</p><p><strong>Arguments</strong></p><ul><li><code>clk::Clock</code></li><li><code>Œît::Number=0</code>: time increment</li><li><code>t0::Float64=0</code> or <code>t0::Time</code>: start time</li><li><code>hard::Bool=true</code>: time is reset, all scheduled events and sampling are   deleted. If hard=false, then only time is reset, event and   sampling times are adjusted accordingly.</li><li><code>unit=NoUnits</code>: the Time unit for the clock after reset. If a <code>Œît::Time</code> is   given, its Time unit goes into the clock Time unit. If only t0::Time is given,   its Time unit goes into the clock time unit.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Simulate, Unitful

julia&gt; import Unitful: s

julia&gt; c = Clock(1s, t0=60s)
Clock: state=Simulate.Undefined(), time=60.0, unit=s, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=1.0

julia&gt; reset!(c)
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;

julia&gt; c
Clock: state=Simulate.Idle(), time=0.0, unit=, events: 0, cevents: 0, processes: 0, sampling: 0, sample rate Œît=0.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L162-L195">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.incr!" href="#Simulate.incr!"><code>Simulate.incr!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">incr!(clk::Clock)</code></pre><p>Take one simulation step, execute the next tick or event.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L543-L547">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.run!" href="#Simulate.run!"><code>Simulate.run!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">run!(clk::Clock, duration::Number)</code></pre><p>Run a simulation for a given duration. Call scheduled events and evaluate sampling expressions at each tick in that timeframe.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L531-L536">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.stop!-Tuple{Clock}" href="#Simulate.stop!-Tuple{Clock}"><code>Simulate.stop!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">stop!(clk::Clock)</code></pre><p>Stop a running simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L550-L554">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.resume!" href="#Simulate.resume!"><code>Simulate.resume!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resume!(clk::Clock)</code></pre><p>Resume a halted simulation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L557-L561">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Simulate.sync!" href="#Simulate.sync!"><code>Simulate.sync!</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sync!(clk::Clock, to::Clock=ùê∂)</code></pre><p>Force a synchronization of two clocks. Change all registered times of <code>clk</code> accordingly. Convert or force clk.unit to to.unit.</p></div></div><a class="source-link" target="_blank" href="https://github.com/pbayer/Simulate.jl/blob/df3565837f51a5d4d7ba11aa221a9c2e76d24395/src/clock.jl#L131-L137">source</a></section><footer><hr/><a class="previous" href="../parallel/"><span class="direction">Previous</span><span class="title">Parallel simulations</span></a><a class="next" href="../../performance/performance/"><span class="direction">Next</span><span class="title">Performance</span></a></footer></article></body></html>
