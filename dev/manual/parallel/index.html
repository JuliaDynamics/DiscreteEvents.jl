<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel simulations · Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../news/">News</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../intro/">Getting started</a></li><li class="current"><a class="toctext" href>Parallel simulations</a><ul class="internal"><li><a class="toctext" href="#Simulations-in-parallel-1">Simulations in parallel</a></li><li><a class="toctext" href="#Multithreading-of-events-and-processes-1">Multithreading of events and processes</a></li></ul></li><li><a class="toctext" href="../approach/">Approaches to modeling and simulation</a></li><li><a class="toctext" href="../usage/">User guide</a></li></ul></li><li><span class="toctext">Performance</span><ul><li><a class="toctext" href="../../performance/performance/">Performance</a></li><li><a class="toctext" href="../../performance/par_perf/">Parallel performance</a></li><li><a class="toctext" href="../../performance/benchmarks/">Benchmarks</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Examples - overview</a></li><li><a class="toctext" href="../../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../../examples/postoffice/postoffice/">Post Office</a></li><li><a class="toctext" href="../../examples/dicegame/dicegame/">Goldratt&#39;s Dice Game</a></li><li><a class="toctext" href="../../examples/house_heating/house_heating/">House heating</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Parallel simulations</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/manual/parallel.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Parallel simulations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Parallel-simulations-1" href="#Parallel-simulations-1">Parallel simulations</a></h1><p>Currently <code>Simulate.jl</code> enables two approaches to parallel simulations.</p><h2><a class="nav-anchor" id="Simulations-in-parallel-1" href="#Simulations-in-parallel-1">Simulations in parallel</a></h2><p>Multiple simulations can be executed on parallel threads using the <code>@threads</code>- macro. Such simulations have different clocks with different times. One example of this is given in the <a href="../../examples/dicegame/dicegame/">dice game example</a>. This approach is useful if you do multiple simulations to investigate their response to parameter variation.</p><h2><a class="nav-anchor" id="Multithreading-of-events-and-processes-1" href="#Multithreading-of-events-and-processes-1">Multithreading of events and processes</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Multithreading is still experimental and in active development. It requires Julia ≥ 1.3.</p></div></div><p>Big simulations consist of multiple events, sampling functions and asynchronous processes. All those activities must be coordinated by a clock. In order to avoid that a single clock becomes the bottleneck of a simulation,</p><ol><li>you can create a new clock with copies on each available thread with</li></ol><p><a href="../usage/#Simulate.PClock"><code>PClock</code></a> or you <a href="../usage/#Simulate.fork!"><code>fork!</code></a> an existing single clock to other   threads. You then have parallel <a href="../usage/#Simulate.ActiveClock"><code>ActiveClock</code></a>s <a href="#footnote-1">[1]</a> with events,   processes and scheduling.  </p><ol><li>The parallel clocks then are accessible with <a href="../usage/#Simulate.pclock"><code>pclock</code></a>. By</li></ol><p>registering events (<a href="../usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array{T,1} where T},Number}"><code>event!</code></a>), samples (<a href="../usage/#Simulate.sample!"><code>sample!</code></a>) or processes (<a href="../usage/#Simulate.process!"><code>process!</code></a>) to them as before you then get parallel clock schedules.</p><ol><li>Or you can tell a clock to randomly spawn events or processes to its</li></ol><p>parallel clocks by setting <code>spawn=true</code> in (<a href="../usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array{T,1} where T},Number}"><code>event!</code></a>) or   (<a href="../usage/#Simulate.process!"><code>process!</code></a>) calls. This allows the clock to balance the load between threads.</p><ol><li>If you <a href="../usage/#Simulate.run!"><code>run!</code></a> a parallelized clock, the clock on thread 1 becomes</li></ol><p>the &quot;master&quot; clock telling the clocks on the other threads to run for a time   step Δt and synchronizing with them after each such step.</p><h3><a class="nav-anchor" id="Uncertainty-of-event-sequence-1" href="#Uncertainty-of-event-sequence-1">Uncertainty of event sequence</a></h3><p>This introduces an <strong>uncertainty</strong> into simulations on parallel threads: If an event <code>e_x</code> has a scheduling time slightly less than event <code>e_y</code>on another thread and both times lie inside the same time interval <code>t_x + Δt</code>, maybe – depending on the thread load – <code>e_y</code> gets physically executed before <code>e_x</code>. There are several techniques to reduce the uncertainty:</p><ol><li>If there is a causal connection between two events such that <code>e_y</code> depends on <code>e_x</code>, the first one can be scheduled (<a href="../usage/#Simulate.event!-Tuple{Clock,Union{Expr, Tuple, SimFunction, Array{T,1} where T},Number}"><code>event!</code></a>) with <code>sync=true</code> to <em>force</em> its execution before the second. But such dependencies are not always known in simulations.</li><li>You can choose to <em>group</em> causally connected events on one thread by scheduling them on a specific parallel clock, such that they are executed in sequence. Consider a factory simulation: also in real factories different departments are decoupled by buffers. You can allocate processes, events and samples of one department together on a thread. See <a href="manual/@ref grouping">grouping</a> below.</li><li>You can generally reduce the synchronization cycle Δt such that clocks get synchronized more often.</li></ol><p>There is a tradeoff between parallel efficiency and uncertainty: if threads must be synchronized more often, there is more cost of synchronization relative to execution. You have to choose the uncertainty. Often also in simulations as in life such fluctuations in event sequence cancel out statistically and do not matter at all.</p><h3><a class="nav-anchor" id="Grouping-of-events-and-processes-1" href="#Grouping-of-events-and-processes-1">Grouping of events and processes</a></h3><ul><li>grouping parallel simulations with the <code>@threads</code> macro,</li></ul><h3><a class="nav-anchor" id="Parallel-efficiency-1" href="#Parallel-efficiency-1">Parallel efficiency</a></h3><ul><li>number of threads to use,</li></ul><p>see the chapter in performance</p><h3><a class="nav-anchor" id="Thread-safety-1" href="#Thread-safety-1">Thread safety</a></h3><ul><li>using random numbers on parallel threads,</li><li>synchronizing write access to shared variables,</li></ul><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>They are called &quot;active clocks&quot; because they follow the <a href="https://en.wikipedia.org/wiki/Active_object">active object design pattern</a>. They run in event loops, behave internally as state machines and communicate with the master clock across threads via channels following a simple communication protocol.</p></div><footer><hr/><a class="previous" href="../intro/"><span class="direction">Previous</span><span class="title">Getting started</span></a><a class="next" href="../approach/"><span class="direction">Next</span><span class="title">Approaches to modeling and simulation</span></a></footer></article></body></html>
