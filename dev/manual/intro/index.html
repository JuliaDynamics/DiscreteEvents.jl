<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started ¬∑ Simulate.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Simulate.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../news/">News</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Getting started</a><ul class="internal"><li><a class="toctext" href="#A-first-example-1">A first example</a></li><li><a class="toctext" href="#Four-building-blocks-1">Four building blocks</a></li><li><a class="toctext" href="#the_clock-1">The clock</a></li><li><a class="toctext" href="#event_scheme-1">Events</a></li><li><a class="toctext" href="#process_scheme-1">Processes</a></li><li><a class="toctext" href="#continuous_sampling-1">Continuous sampling</a></li><li><a class="toctext" href="#Running-a-simulation-1">Running a simulation</a></li></ul></li><li><a class="toctext" href="../approach/">Approaches to modeling and simulation</a></li><li><a class="toctext" href="../parallel/">Parallel simulations</a></li><li><a class="toctext" href="../timer/">Real time clocks</a></li><li><a class="toctext" href="../usage/">User guide</a></li><li><span class="toctext">Performance</span><ul><li><a class="toctext" href="../../performance/performance/">Performance</a></li><li><a class="toctext" href="../../performance/par_perf/">Parallel performance</a></li><li><a class="toctext" href="../../performance/benchmarks/">Benchmarks</a></li></ul></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/examples/">Examples - overview</a></li><li><a class="toctext" href="../../examples/tabletennis/">Table tennis</a></li><li><a class="toctext" href="../../examples/singleserver/">Single server</a></li><li><a class="toctext" href="../../examples/postoffice/postoffice/">Post Office</a></li><li><a class="toctext" href="../../examples/dicegame/dicegame/">Goldratt&#39;s Dice Game</a></li><li><a class="toctext" href="../../examples/house_heating/house_heating/">House heating</a></li></ul></li><li><a class="toctext" href="../internals/">Internals</a></li><li><a class="toctext" href="../troubleshooting/">Troubleshooting</a></li><li><a class="toctext" href="../history/">Release notes</a></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Getting started</a></li></ul><a class="edit-page" href="https://github.com/pbayer/Simulate.jl/blob/master/docs/src/manual/intro.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-started-1" href="#Getting-started-1">Getting started</a></h1><p>Get an overview and learn the basics.</p><p><code>Simulate.jl</code> provides 1) a <em>clock</em> with a virtual simulation time and 2) the ability to schedule Julia functions and expressions as <em>events</em> on the clock&#39;s timeline or 3) run them as <em>processes</em> synchronizing with the clock. The clock can 4) invoke <em>sampling</em> functions or expressions continuously at a given rate.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>Simulate.jl</code> doesn&#39;t have a special concept for shared resources since this can be expressed in native Julia via tokens in a <code>Channel</code>.</p></div></div><h2><a class="nav-anchor" id="A-first-example-1" href="#A-first-example-1">A first example</a></h2><p>A simple server takes something (a resource) from its input and puts it out modified after some time. We implement the server&#39;s activity in a function, create input and output channels and some &quot;foo&quot; and &quot;bar&quot; processes interacting on them:  </p><pre><code class="language-julia">using Simulate, Printf, Random

function simple(c::Clock, input::Channel, output::Channel, name, id, op)
    token = take!(input)         # take something from the input
    now!(c, fun(println, @sprintf(&quot;%5.2f: %s %d took token %d&quot;, tau(c), name, id, token)))
    d = delay!(c, rand())        # after a delay
    put!(output, op(token, id))  # put it out with some op applied
end

clk = Clock()      # create a clock
Random.seed!(123)  # seed the random number generator

ch1 = Channel(32)  # create two channels
ch2 = Channel(32)

for i in 1:2:8    # create and register 8 processes
    process!(clk, Prc(i, simple, ch1, ch2, &quot;foo&quot;, i, +))
    process!(clk, Prc(i+1, simple, ch2, ch1, &quot;bar&quot;, i+1, *))
end

put!(ch1, 1)    # put first token into channel 1
yield()         # let the first task take it
run!(clk, 10)   # and run for 10 time units</code></pre><p>We then run it:</p><pre><code class="language-julia">julia&gt; include(&quot;docs/examples/channels.jl&quot;)
 0.00: foo 1 took token 1
 0.77: bar 2 took token 2
 1.71: foo 3 took token 4
 2.38: bar 4 took token 7
 2.78: foo 5 took token 28
 ...
 ...
 7.91: bar 2 took token 631017
 8.36: foo 3 took token 1262034
 8.94: bar 4 took token 1262037
 9.20: foo 5 took token 5048148
 9.91: bar 6 took token 5048153
&quot;run! finished with 43 clock events, 0 sample steps, simulation time: 10.0&quot;</code></pre><h4><a class="nav-anchor" id="Types-and-functions-1" href="#Types-and-functions-1">Types and functions</a></h4><p><a href="../usage/#Simulate.ùê∂"><code>ùê∂</code></a>, <a href="../usage/#Simulate.reset!"><code>reset!</code></a>, <a href="../usage/#Simulate.now!"><code>now!</code></a>, <a href="../usage/#Simulate.delay!"><code>delay!</code></a>, <a href="../usage/#Simulate.process!"><code>process!</code></a>, <a href="../usage/#Simulate.Prc"><code>Prc</code></a>, <a href="../usage/#Simulate.run!"><code>run!</code></a></p><h2><a class="nav-anchor" id="Four-building-blocks-1" href="#Four-building-blocks-1">Four building blocks</a></h2><p><code>Simulate.jl</code> provides 4 major building blocks for modeling and simulation of discrete event systems:</p><ol><li>the logical <a href="#the_clock-1"><strong>clock</strong></a> gives the simulation time,</li><li><a href="#event_scheme-1"><strong>events</strong></a> are Julia functions or expressions   executing at given simulation times or under given conditions,</li><li><a href="#process_scheme-1"><strong>processes</strong></a> are functions running as <a href="https://docs.julialang.org/en/v1/manual/control-flow/#man-tasks-1">tasks</a> and synchronizing with the clock by delaying for a time or waiting for conditions,</li><li><a href="#continuous_sampling-1"><strong>continuous sampling</strong></a> is done by invoking given expressions or functions at a given rate on the time line.</li></ol><h2><a class="nav-anchor" id="the_clock-1" href="#the_clock-1">The clock</a></h2><p>The clock is central to any model and simulation, since it establishes the timeline. It does not only provide the time, but contains also a time unit, all scheduled events, conditional events, processes, sampling expressions or functions and the sample rate Œît. Each simulation can have its own clock.</p><pre><code class="language-julia">julia&gt; c = Clock()                           # create a new clock
Clock thread 1 (+ 0 ac): state=Simulate.Undefined(), t=0.0 , Œît=0.0 , prc:0
  scheduled ev:0, cev:0, sampl:0

julia&gt; tick() = println(tau(c), &quot;: tick!&quot;)   # define a function printing the clock&#39;s time
tick (generic function with 1 method)

julia&gt; event!(c, fun(tick), every, 1)         # schedule a repeat event on the clock
0.0

julia&gt; run!(c, 10)                           # run the clock for 10 time units
0.0: tick!
1.0: tick!
2.0: tick!
3.0: tick!
4.0: tick!
5.0: tick!
6.0: tick!
7.0: tick!
8.0: tick!
9.0: tick!
10.0: tick!
&quot;run! finished with 11 clock events, 0 sample steps, simulation time: 10.0&quot;</code></pre><p>If you work with only one simulation at a time, you normally use the <em>central clock</em> <a href="../usage/#Simulate.ùê∂"><code>ùê∂</code></a> (<code>\\itùê∂</code>+<code>tab</code>):</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>You definitely need different clock variables if you run multiple simulations on parallel threads. In such cases each simulation should have its own clock. Please look at the <a href="../../examples/dicegame/dicegame/">dicegame</a> example for that.</p></div></div><pre><code class="language-julia">julia&gt; tick() = println(tau(), &quot;: tick!&quot;)         # the tick function now uses central time tau()
tick (generic function with 1 method)

julia&gt; sample_time!(1)                            # set the sampling rate on the central clock to 1
1.0

julia&gt; periodic!( fun(tick) );                       # set tick as a sampling function

julia&gt; ùê∂                                          # ùê∂ now has one sampling entry and the sample rate set
Clock thread 1 (+ 0 ac): state=Simulate.Idle(), t=0.0 , Œît=1.0 , prc:0
  scheduled ev:0, cev:0, sampl:1

julia&gt; run!(ùê∂, 5)                                 # run ùê∂ for 5 time units
1.0: tick!
2.0: tick!
3.0: tick!
4.0: tick!
5.0: tick!
&quot;run! finished with 0 clock events, 5 sample steps, simulation time: 5.0&quot;

julia&gt; run!(ùê∂, 5)                                 # run it again
6.0: tick!
7.0: tick!
8.0: tick!
9.0: tick!
10.0: tick!
&quot;run! finished with 0 clock events, 5 sample steps, simulation time: 10.0&quot;

julia&gt; reset!(ùê∂)                                  # reset the clock
&quot;clock reset to t‚ÇÄ=0.0, sampling rate Œît=0.0.&quot;</code></pre><p>If Œît = 0, the clock doesn&#39;t tick with a fixed interval, but jumps from event to event.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Clocks work with a <code>Float64</code> time and with <code>Unitful.NoUnits</code> but you can set them to work with <code>Unitful.Time</code> units like <code>ms, s, minute, hr</code>. In this case <a href="../usage/#Simulate.tau"><code>tau</code></a> returns a time, e.g. <code>1 s</code>. You can also provide time values to clocks or in scheduling events. They then are converted to the defined unit as long as the clock is set to a time unit.</p><ul><li><a href="../usage/#Simulate.setUnit!"><code>setUnit!(sim::Clock, unit::FreeUnits)</code></a>: set a clock unit.</li><li><code>tau(sim::Clock).val</code>: return a unitless number for current time.</li></ul><p>At the moment I don&#39;t find it practical to work with units if for example I collect simulation events or variables with their time in a table or do plots. It seems easier not to use them as long you don&#39;t need automatic time conversion in your simulation projects.</p></div></div><h4><a class="nav-anchor" id="Types-and-functions-2" href="#Types-and-functions-2">Types and functions</a></h4><p><a href="../usage/#Simulate.Clock"><code>Clock</code></a>, <a href="../usage/#Simulate.ùê∂"><code>ùê∂</code></a>, <a href="../usage/#Simulate.tau"><code>tau</code></a>, <a href="../usage/#Simulate.sample_time!"><code>sample_time!</code></a>, <a href="../usage/#Simulate.periodic!"><code>periodic!</code></a>, <a href="../usage/#Simulate.run!"><code>run!</code></a>, <a href="../usage/#Simulate.reset!"><code>reset!</code></a>, <a href="../usage/#Simulate.incr!"><code>incr!</code></a>, <a href="../usage/#Simulate.sync!"><code>sync!</code></a>, <a href="../usage/#Simulate.stop!-Tuple{Clock}"><code>stop!</code></a>, <a href="../usage/#Simulate.resume!"><code>resume!</code></a>,  </p><h2><a class="nav-anchor" id="event_scheme-1" href="#event_scheme-1">Events</a></h2><p>Julia <em>functions</em> or <em>expressions</em> are scheduled as events on the clock&#39;s time line. In order to not be invoked immediately,</p><ul><li>event functions must be stored in a closure or in a <a href="../usage/#Simulate.fun"><code>fun</code></a> and</li><li>event expressions must be <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#Quoting-1">quoted</a> with <code>:()</code>.</li></ul><p>Event functions in a <code>fun</code> can get 1) values, variables or 2) symbols, expressions or function closures or other <code>fun</code>s as arguments. The 2nd case arguments are evaluated not till event time before they are passed to the event function.</p><p>Several functions and expressions can be scheduled as events combined in a tuple.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>Evaluating expressions or symbols at global scope is much slower than using functions and gives a one time warning. See <a href="../../performance/performance/">Performance</a>.  This functionality may be removed entirely in a future version. (Please write an <a href="https://github.com/pbayer/Simulate.jl/issues">issue</a> if you want to keep it.)</p></div></div><h3><a class="nav-anchor" id="Timed-events-1" href="#Timed-events-1">Timed events</a></h3><p>Timed events with <a href="../usage/#Simulate.event!"><code>event!</code></a> schedule functions and expressions to execute at a given time:</p><pre><code class="language-julia">ev1 = :(println(tau(), &quot;: I&#39;m a quoted expression&quot;))
ev2 = fun(() -&gt; println(tau(), &quot;: I&#39;m a fun&quot;))
ev3 = fun(println, fun(tau), &quot;: now a is &quot;, :a)  # various arguments to a fun

a = 1
event!(ev1, at, 2)                             # schedule events at 2, 3, 4, 6, 8
event!(ev3, at, 3)
event!(:(a += 5), at, 4)
event!(ev3, at, 6)
event!(ev1, after, 8)                          # schedule an event after 8
event!(ev2, every, 5)                          # schedule an event every 5</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)                             # run
0.0: I&#39;m a fun
2.0: I&#39;m a quoted expression
3.0: now a is 1
5.0: I&#39;m a fun
6.0: now a is 6
8.0: I&#39;m a quoted expression
10.0: I&#39;m a fun
&quot;run! finished with 8 clock events, 0 sample steps, simulation time: 10.0&quot;

julia&gt; event!((ev1, ev2), after, 2)            # schedule both ev1 and ev2 as one event
12.0

julia&gt; run!(ùê∂, 5)                              # run
12.0: I&#39;m a quoted expression
12.0: I&#39;m a fun
15.0: I&#39;m a fun
&quot;run! finished with 2 clock events, 0 sample steps, simulation time: 15.0&quot;</code></pre><h3><a class="nav-anchor" id="Conditional-events-1" href="#Conditional-events-1">Conditional events</a></h3><p><em>Conditional events</em>  with (<a href="../usage/#Simulate.event!"><code>event!</code></a> execute under given conditions. Conditions can be formulated as logical expressions or functions or combinations of them.</p><pre><code class="language-julia">reset!(ùê∂)                                       # reset the clock
y = 0                                           # create a variable y
periodic!( fun(() -&gt; global y = tau()/2) );        # a sampling function
event!( fun(()-&gt;println(tau(),&quot;: now y ‚â• œÄ&quot;) ), (@val :y :‚â• œÄ) ) # a conditional event</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)                              # run
6.28999999999991: now y ‚â• œÄ
&quot;run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0&quot;

julia&gt; 2œÄ                                       # exact value
6.283185307179586</code></pre><pre><code class="language-julia">reset!(ùê∂)
periodic!( fun(()-&gt; global y=sin(@tau)) );         # sample a sine function on y
event!(fun(()-&gt;println(tau(),&quot;: now y ‚â• 1/2&quot;)), ((@val :y :‚â• 1/2),(@tau :‚â• 5))) # two conditions</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)
6.809999999999899: now y ‚â• 1/2
&quot;run! finished with 0 clock events, 1000 sample steps, simulation time: 10.0&quot;

julia&gt; asin(0.5) + 2œÄ                           # exact value
6.806784082777885</code></pre><p>The example shows: (1) the sample rate has some uncertainty in detecting events and (2) conditional events are triggered only once. If there is no sample rate set, a conditional event sets one up and deletes it again after it becomes true.</p><h4><a class="nav-anchor" id="Types-and-functions-3" href="#Types-and-functions-3">Types and functions</a></h4><p><a href="../usage/#Simulate.tau"><code>tau</code></a>, <a href="../usage/#Simulate.fun"><code>fun</code></a>, <a href="../usage/#Simulate.event!"><code>event!</code></a>, <a href="../usage/#Simulate.run!"><code>run!</code></a>, <a href="../usage/#Simulate.reset!"><code>reset!</code></a>, <a href="../usage/#Simulate.periodic!"><code>periodic!</code></a></p><h2><a class="nav-anchor" id="process_scheme-1" href="#process_scheme-1">Processes</a></h2><p>Functions can be started as asynchronous <a href="https://docs.julialang.org/en/v1/manual/control-flow/#man-tasks-1">tasks or coroutines</a>, which can coordinate with the clock and events by delaying for some time or waiting for conditions, taking inputs from events or other tasks, triggering events or starting other tasks ‚Ä¶</p><p>From a modeling or simulation standpoint we call such tasks <em>processes</em>, because they can represent some ongoing activity in nature. Tasks seen as processes are a powerful modeling device, but you need to take care that</p><ol><li>they <em>give back control</em> to the clock and other processes by calling delays or conditional waits or requesting resources (and thus implicitly waiting for them to become available) and</li><li>they <em>transfer critical operations to the clock</em> in order to not get out of sync with simulation time.</li></ol><h3><a class="nav-anchor" id="Create-and-start-a-process-1" href="#Create-and-start-a-process-1">Create and start a process</a></h3><p><a href="../usage/#Simulate.Prc"><code>Prc</code></a> prepares a function for running as a process and assignes it an id.  Then <code>process!</code> registers it to the clock and starts it as a process in a loop. You can define how many loops the function should persist, but the default is <code>Inf</code>. You can create as many instances of a function as processes as you like.</p><pre><code class="language-julia">function doit(c::Clock, n)  # function doit takes a clock as 1st argument
    i = 1
    while i ‚â§ n
        delay!(c, rand()*2)                     # delay for some time
        now!(c, fun(println, @sprintf(&quot;%5.2f: finished %d&quot;, tau(), i)))  # print
        i += 1
    end
end

Random.seed!(1234);        
reset!(ùê∂)                                       # reset the central clock
process!(Prc(1, doit, 5), 1)                    # create, register and start doit(5) as a process, id=1, runs only once</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 5)                               # run for 5 time units
 1.18: finished 1
 2.72: finished 2
 3.85: finished 3
 4.77: finished 4
&quot;run! finished with 8 clock events, 0 sample steps, simulation time: 5.0&quot;

julia&gt; run!(ùê∂, 2)                               # it is not yet finished, run 2 more
 6.36: finished 5
&quot;run! finished with 2 clock events, 0 sample steps, simulation time: 7.0&quot;


julia&gt; run!(ùê∂, 3)                               # doit(5) is done with 5, nothing happens anymore
&quot;run! finished with 0 clock events, 0 sample steps, simulation time: 10.0&quot;</code></pre><h3><a class="nav-anchor" id="Delay,-wait,-take-and-put-1" href="#Delay,-wait,-take-and-put-1">Delay, wait, take and put</a></h3><p>In order to synchronize with the clock, a process can</p><ul><li>get the simulation time <a href="../usage/#Simulate.tau"><code>tau()</code></a>,</li><li><a href="../usage/#Simulate.delay!"><code>delay!</code></a>, which suspends it until after the given time <code>t</code> or</li><li><a href="../usage/#Simulate.wait!"><code>wait!</code></a> for a condition. This creates a conditional <a href="../usage/#Simulate.event!"><code>event!</code></a> which reactivates the process when the conditions become true.</li></ul><p>Processes can also interact directly e.g. via <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#Channels-1">channels</a> with <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.take!-Tuple{Channel}"><code>take!</code></a> and <a href="https://docs.julialang.org/en/v1/base/parallel/#Base.put!-Tuple{Channel,Any}"><code>put!</code></a>. This also may suspend them until there is something to take from a channel or until they are allowed to put something into it.</p><pre><code class="language-julia">function watchdog(c::Clock, name)
    delay!(c, until, 6 + rand())                    # delay until
    now!(c, fun(println, @sprintf(&quot;%5.2f %s: yawn!, bark!, yawn!&quot;, tau(), name)))
    wait!(c, ((@val :hunger :‚â• 7),(@tau :‚â• 6.5)))   # conditional wait
    while 5 ‚â§ hunger ‚â§ 10
        now!(c, fun(println, @sprintf(&quot;%5.2f %s: %s&quot;, tau(), name, repeat(&quot;wow &quot;, Int(trunc(hunger))))))
        delay!(c, rand()/2)                         # simple delay
        if scuff
            now!(c, fun(println, @sprintf(&quot;%5.2f %s: smack smack smack&quot;, tau(), name)))
            global hunger = 2
            global scuff = false
        end
    end
    delay!(c, rand())                               # simple delay
    now!(c, fun(println, @sprintf(&quot;%5.2f %s: snore ... snore ... snore&quot;, tau(), name)))
end

hunger = 0
scuff = false
reset!(ùê∂)
Random.seed!(1122)

periodic!(fun(()-&gt; global hunger += rand()), 0.5)   # a sampling function: increasing hunger
event!(fun(()-&gt; global scuff = true ), 7+rand())  # an event: scuff after 7 am
process!(Prc(1, watchdog, &quot;Snoopy&quot;), 1)           # create, register and run Snoopy</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)
 6.24 Snoopy: yawn!, bark!, yawn!
 6.50 Snoopy: wow wow wow wow wow wow wow wow
 6.98 Snoopy: wow wow wow wow wow wow wow wow wow
 7.37 Snoopy: smack smack smack
 7.38 Snoopy: snore ... snore ... snore
&quot;run! finished with 10 clock events, 20 sample steps, simulation time: 10.0&quot;</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>you <strong>must not</strong> use or invoke operations like <a href="../usage/#Simulate.delay!"><code>delay!</code></a>, <a href="../usage/#Simulate.wait!"><code>wait!</code></a>, <code>take!</code> or <code>put!</code> outside of tasks and inside the Main process, because they will suspend it.</p></div></div><h3><a class="nav-anchor" id="IO-operations-1" href="#IO-operations-1">IO-operations</a></h3><p>Tasks must transfer critical IO operations to the clock with a <a href="../usage/#Simulate.now!"><code>now!</code></a> call. When tasks invoke IO-operations like printing, reading or writing from or to files, directly, they give control back to the Julia scheduler. While the IO-operation continues the clock may advance with time and the task has got out of sync with simulation time. Processes therefore should enclose their IO-operations in a <a href="../usage/#Simulate.now!"><code>now!</code></a> call. This will transfer them for execution to the clock, which must finish them before proceeding any further.</p><pre><code class="language-julia">function bad(c::Clock)                         # bad: IO-operation DIY
    delay!(c, rand()*2)
    @printf(&quot;%5.2f: hi, here I am\n&quot;, tau())
end
Random.seed!(1234);
reset!(ùê∂)                                      # reset the clock
process!(Prc(1, bad), 5)                       # setup a process with 5 cycles</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)                             # it runs only once !!!
 1.18: hi, here I am
&quot;run! finished with 1 clock events, 0 sample steps, simulation time: 10.0&quot;</code></pre><pre><code class="language-julia">function better(c::Clock)                      # better: let the clock doit for you
    delay!(c, rand()*2)
    now!(c, fun(println, @sprintf(&quot;%5.2f: hi, I am fine&quot;, tau())))
end
Random.seed!(1234);
reset!(ùê∂)                                      # reset the clock
process!(Prc(1, better), 5)                    # setup a process with 5 cycles</code></pre><pre><code class="language-julia">julia&gt; run!(ùê∂, 10)                             # it runs all 5 cycles
 1.18: hi, I am fine
 2.72: hi, I am fine
 3.85: hi, I am fine
 4.77: hi, I am fine
 6.36: hi, I am fine
&quot;run! finished with 10 clock events, 0 sample steps, simulation time: 10.0&quot;</code></pre><h4><a class="nav-anchor" id="Types-and-functions-4" href="#Types-and-functions-4">Types and functions</a></h4><p><a href="../usage/#Simulate.Prc"><code>Prc</code></a>, <a href="../usage/#Simulate.process!"><code>process!</code></a>, <a href="../usage/#Simulate.delay!"><code>delay!</code></a>, <a href="../usage/#Simulate.wait!"><code>wait!</code></a>, <a href="../usage/#Simulate.now!"><code>now!</code></a>, <a href="../usage/#Simulate.fun"><code>fun</code></a>, <a href="../usage/#Simulate.run!"><code>run!</code></a>, <a href="../usage/#Simulate.ùê∂"><code>ùê∂</code></a>, <a href="../usage/#Simulate.reset!"><code>reset!</code></a>, <a href="../usage/#Simulate.periodic!"><code>periodic!</code></a>, <a href="../usage/#Simulate.event!"><code>event!</code></a></p><h2><a class="nav-anchor" id="continuous_sampling-1" href="#continuous_sampling-1">Continuous sampling</a></h2><p>Continuous sampling allows to bring continuous processes or real world data into a simulation or can be used for visualization or logging and collecting statistics.</p><p>If you provide the clock with a time interval <code>Œît</code>, it ticks with a fixed sample rate. At each tick it will call registered functions or expressions:</p><ul><li><a href="../usage/#Simulate.sample_time!"><code>sample_time!(Œît)</code></a>: set the clock&#39;s sample rate starting from now.</li><li><a href="../usage/#Simulate.periodic!"><code>periodic!(expr)</code></a>: register a function or expression or a tuple of them for sampling. If no sample rate is set, set it implicitly.</li></ul><p>Sampling functions or expressions are called at clock ticks in the sequence they were registered. They are called before any events scheduled for the same time.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Conditions set by conditional <a href="../usage/#Simulate.event!"><code>event!</code></a> or by <a href="../usage/#Simulate.wait!"><code>wait!</code></a> are also evaluated with the sampling rate. But the conditional event disappears after the conditions are met and the sample rate is then canceled if no sampling functions are registered.</p></div></div><p>If no sample rate is set, the clock jumps from event to event.</p><h2><a class="nav-anchor" id="Running-a-simulation-1" href="#Running-a-simulation-1">Running a simulation</a></h2><p>After you have setup the clock, scheduled events, setup sampling or started processes ‚Äì as you have seen ‚Äì you can step or run through a simulation, stop or resume it.</p><ul><li><a href="../usage/#Simulate.run!"><code>run!(clk::Clock, duration::Number)</code></a>: run a simulation for a given duration. Call all scheduled events and sampling actions in that timeframe.</li><li><a href="../usage/#Simulate.incr!"><code>incr!(clk::Clock)</code></a>: take one simulation step, call the next tick or event.</li><li><a href="../usage/#Simulate.stop!-Tuple{Clock}"><code>stop!(clk::Clock)</code></a>: stop a simulation</li><li><a href="../usage/#Simulate.resume!"><code>resume!(clk::Clock)</code></a>: resume a halted simulation.</li></ul><footer><hr/><a class="previous" href="../../news/"><span class="direction">Previous</span><span class="title">News</span></a><a class="next" href="../approach/"><span class="direction">Next</span><span class="title">Approaches to modeling and simulation</span></a></footer></article></body></html>
